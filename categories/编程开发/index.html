<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>编程开发 | star徐的博客</title><meta name=keywords content><meta name=description content="个人博客，分享技术心得和生活感悟"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://ljj1992.fun/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/index.xml title=rss><link rel=alternate hreflang=en href=http://ljj1992.fun/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="编程开发"><meta property="og:description" content="个人博客，分享技术心得和生活感悟"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="编程开发"><meta name=twitter:description content="个人博客，分享技术心得和生活感悟"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/categories/>Categories</a></div><h1>编程开发</h1></header><div class=posts><article class=post-entry><header class=entry-header><h2>AOP切面(java新手)</h2></header><div class=entry-content><p>AOP切面(java新手) 🌟 一、为什么要用 AOP？ 想象一下：你在开发一个电商网站，有几十个接口，比如
用户登录 下单 查看商品 修改地址 支付订单 这些功能都属于“业务逻辑”（核心功能）。但你发现，每个接口都需要做两件事：
记录日志（谁在什么时候调用了哪个接口？） 检查用户有没有权限（比如普通用户不能删别人订单） 如果不用 AOP，你可能会在每个方法里手动写日志和权限检查代码，像这样
问题来了：
代码重复！每个方法都要写一样的日志和权限。 业务逻辑被“污染”了，看不清核心功能。 如果哪天要改日志格式？得改几十个地方！ 👉 AOP 就是为了解决这种“横着切”的公共问题而生的！
👉 AOP 就是为了解决这种“横着切”的公共问题而生的！
✅ AOP 的核心思想： 把那些和业务无关但又到处要用的功能（比如日志、权限、事务、防重提交）抽出来，写在一个地方，自动“织入”到需要的地方。 业务代码只管做自己的事，干净清爽！
🧩 二、怎么理解 AOP？用两个真实例子 ✅ 自动记录接口日志（最常见！） 场景： 你想知道哪些用户调用了哪些接口、花了多长时间。
不用 AOP（麻烦）： 每个 Controller 方法里手写 logger.info(...)。
用 AOP（优雅）： 定义一个“切面”类（专门处理日志）： @Aspect @Component public class LogAspect { private static final Logger logger = LoggerFactory.getLogger(LogAspect.class); // 定义“切入点”：所有 Controller 包下的 public 方法 @Pointcut("execution(public * com.example.controller..*.*(..))") public void controllerMethods() {} // 在方法执行前记录开始 @Before("controllerMethods()") public void logBefore(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); logger.info("调用方法: {}, 参数: {}", methodName, Arrays.toString(args)); } // 在方法执行后记录耗时 @Around("controllerMethods()") public Object logTime(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); // 执行原方法 long time = System.currentTimeMillis() - start; logger.info("方法 {} 耗时 {}ms", joinPoint.getSignature().getName(), time); return result; } } 你的业务代码完全不用改！ @RestController public class OrderController { @PostMapping("/order") public String createOrder(@RequestBody Order order) { // 只写业务逻辑！日志自动加上了 orderService.save(order); return "success"; } } ✅ 效果：只要调用 /order，AOP 自动帮你打日志、算时间，业务代码零侵入！
...</p></div><footer class=entry-footer><span title='2025-11-23 18:30:00 +0800 +0800'>November 23, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to AOP切面(java新手)" href=http://ljj1992.fun/posts/aop%E5%88%87%E9%9D%A2/></a></article><article class=post-entry><header class=entry-header><h2>注解和Map(新手理解)</h2></header><div class=entry-content><p>注解和Map(新手理解) 把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。
Map 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：
第一列叫“键”（Key） 第二列叫“值”（Value） 只要给出一个 Key，就能立刻找到它对应的 Value。 常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。
举个生活化的例子： 如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。
注解和 Map 的关系 注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。 你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：
注解里的每一个属性（比如 @MyAnnotation(value="test", version=2) 中的 value、version） 都会被放进一个 Map 里，key 就是属性名，value 就是属性值。 当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。 所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景： 灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。
一句话总结 Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。
一、🎯 目标： 我们想做一个“用户信息校验”功能，比如：
用户名不能超过10个字符 年龄必须在18到60之间 邮箱必须包含 @ 符号 但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。
...</p></div><footer class=entry-footer><span title='2025-11-21 10:50:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 注解和Map(新手理解)" href=http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/></a></article><article class=post-entry><header class=entry-header><h2>观察者模式(YouTuber订阅)</h2></header><div class=entry-content><p>观察者模式(YouTuber订阅) 一、观察者模式到底是干嘛的？为什么会有人发明它？ 想象一下现实生活中的场景：
你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。
这里的关键问题就是：
“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”
如果没有观察者模式，我们会怎么做？最笨的办法：
老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知； 或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。 这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。
观察者模式解决的核心痛点： 解耦：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。 一对多依赖：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。 动态订阅/退订：粉丝可以随时订阅、随时取关，主题完全不关心。 松耦合：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。 一句话总结： 当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。
二、经典使用场景（你以后一定会遇到） 聊天软件：有人发消息，所有在线好友收到通知 股票软件：股价变动，所有关注这只股票的人收到推送 GUI界面：点击按钮，所有注册了点击事件的监听器执行 消息队列、事件总线（EventBus） Vue/React 中的数据响应式（本质也是观察者） Python 中的信号槽（PyQt/PySide）、Java 中的 Listener 三、用大白话理解观察者模式的四个核心角色 角色 现实中对应 代码中对应 职责 Subject（主题） YouTuber Youtuber 类 维护订阅者列表，提供 attach/detach/notify 方法 Observer（观察者接口） “订阅后必须能收到通知”这个约定 Observer 抽象类 定义 update 方法 ConcreteObserver（具体观察者） 具体的粉丝小明、小红 Fan 类 实现 update，真正干活的地方 Client（客户代码） 我们写的主程序 最后的运行逻辑 创建对象、订阅、触发通知 四、代码分析 # ------------------------------------------------- # 步骤1：定义“主题”（Youtuber） # ------------------------------------------------- class Youtuber: # 定义一个类，名叫 Youtuber，代表“被订阅的对象” def __init__(self, name): # 构造函数，创建对象时自动执行 self.name = name # 给这个YouTuber起个名字，比如“老王” self._observers = [] # 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问 # [] 表示创建一个空列表，用来装所有粉丝对象 def attach(self, observer): # “订阅”方法，参数 observer 就是一个粉丝对象 """添加一个观察者（订阅）""" if observer not in self._observers: # 判断这个粉丝是否已经订阅过，防止重复 self._observers.append(observer) # append 是列表的内置方法，把粉丝对象加到列表末尾 print(f"[{observer.name}] 订阅了 [{self.name}]") # 打印一条提示信息 def detach(self, observer): # “取消订阅”方法 """移除一个观察者（取消订阅）""" try: self._observers.remove(observer) # remove 是列表的内置方法，直接删除这个对象 print(f"[{observer.name}] 取消订阅了 [{self.name}]") except ValueError: # 如果列表里根本没有这个对象，remove 会报错 pass # 我们选择忽略这个错误，什么都不做 def notify(self, video_title): # 最最重要的“发布视频”方法，也就是状态发生变化 """通知所有观察者""" print(f"\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...") for observer in self._observers: # 遍历当前所有的粉丝对象 observer.update(self.name, video_title) # **核心中的核心！** # 调用每个粉丝的 update 方法，把视频信息告诉他 # ------------------------------------------------- # 步骤2：定义“观察者”模板和具体观察者（粉丝） # ------------------------------------------------- from abc import ABC, abstractmethod # 从 abc 模块导入工具，用来创建抽象类 class Observer(ABC): # 定义一个抽象基类（模板），所有观察者都必须遵守 @abstractmethod # 装饰器：表示下面的方法是“抽象方法”，子类必须实现 def update(self, youtuber_name, video_title): # 抽象方法，只定义签名，不写具体内容 pass # pass 表示“占个位置，啥也不干” class Fan(Observer): # Fan 类继承 Observer，代表具体的粉丝 def __init__(self, name): self.name = name # 每个粉丝也有自己的名字 def update(self, youtuber_name, video_title): # 必须实现父类的抽象方法，否则会报错 """当收到通知时，粉丝的反应""" print(f" -> 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]") # 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等 # ------------------------------------------------- # 步骤3：运行逻辑（真正看到效果的地方） # ------------------------------------------------- # 1. 创建主题和观察者 youtuber_A = Youtuber("老王") # 创建一个YouTuber，名字叫“老王” fan_1 = Fan("小明") # 创建三个粉丝对象 fan_2 = Fan("小红") fan_3 = Fan("小刚") # 2. 观察者“订阅”主题 youtuber_A.attach(fan_1) # 小明和小红先订阅 youtuber_A.attach(fan_2) # 3. 主题发布新内容（状态变更） youtuber_A.notify("观察者模式入门") # 老王发第一条视频，只有小明和小红收到 # 4. 另一个粉丝也订阅了 youtuber_A.attach(fan_3) # 小刚中途订阅 # 5. 小红取消订阅 youtuber_A.detach(fan_2) # 小红取关 # 6. 主题再次发布新内容 youtuber_A.notify("工厂模式yyds") # 老王再发一条视频，只有小明和小刚收到 运行后你会看到输出：
...</p></div><footer class=entry-footer><span title='2025-11-20 15:36:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 观察者模式(YouTuber订阅)" href=http://ljj1992.fun/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2>策略模式</h2></header><div class=entry-content><p>策略模式 🌟 什么是策略模式？ 一句话解释：
策略模式就是“把不同的做法（算法）封装成独立的类，让它们可以互相替换，而不影响主程序”。
就像你出门：
可以走路 可以骑车 可以开车 可以坐地铁 这些是不同的“策略”，你根据情况选择一种。程序里也一样，我们可以把每种“方式”封装起来，随时切换。
✅ 场景举例：不同支付方式（微信、支付宝、银行卡）
我们写一个简单的购物程序，支持多种支付方式，使用策略模式来实现。
💡 第一步：定义一个“支付策略”接口 // 定义一个统一的“支付方式”接口 // 所有具体的支付方式（如微信、支付宝）都要实现这个接口 public interface PaymentStrategy { // 这个方法表示“执行支付”，具体怎么付由子类决定 void pay(double amount); } 🔍 解释：
interface 是 Java 中的“接口”，规定了一组行为（方法）。 这里说：任何支付方式都必须有 pay(double amount) 方法。 但不关心它内部怎么实现，只关心“能付钱”。 💡 第二步：实现具体的支付策略 1. 微信支付策略 // 微信支付的具体实现类 public class WeChatPayment implements PaymentStrategy { // 实现 pay 方法：用微信支付 @Override public void pay(double amount) { System.out.println("✅ 使用微信支付：金额 " + amount + " 元"); System.out.println("📱 扫码成功，正在扣款..."); System.out.println("🔔 微信提示：支付成功！"); } } 🔍 解释：
...</p></div><footer class=entry-footer><span title='2025-11-20 15:30:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 策略模式" href=http://ljj1992.fun/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2>servlet基础知识</h2></header><div class=entry-content><p>servlet基础知识 作为安全爱好者的基础性研究
Servlet：名字的由来
Servlet = “Server” + “Applet” 早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 服务器端 的小程序，所以叫 “Server Applet”，简称 Servlet。
它在解决什么问题？
动态内容：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。 性能瓶颈：传统 CGI 为每个请求开一个进程，开销大、响应慢。 跨平台：CGI 脚本依赖操作系统，移植困难。 ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。
作用一句话
接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。
底层逻辑与框架
阶段 动作 关键角色 1. 请求到达 浏览器发 HTTP 请求到 Web 服务器（如 Tomcat） Web 服务器 2. 路由到 Servlet 服务器根据 URL 把请求交给对应的 Servlet 类 Servlet 容器 3. 生命周期 容器负责：加载类 → 创建实例 → 调用 init() → 多次 service() → 最终 destroy() Servlet 本身 4. 处理请求 service() 方法根据 HTTP 方法（GET/POST）调用 doGet()/doPost()，开发者只写业务逻辑 HttpServlet 5. 生成响应 通过 HttpServletResponse 写回 HTML、JSON 或文件 Servlet 6. 线程复用 同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁 JVM 线程池 核心优势
...</p></div><footer class=entry-footer><span title='2025-11-17 23:58:00 +0800 +0800'>November 17, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to servlet基础知识" href=http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/></a></article></div></main><footer class=footer><span>&copy; 2026 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>