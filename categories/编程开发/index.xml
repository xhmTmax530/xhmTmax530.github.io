<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>编程开发 on star徐的博客</title><link>http://ljj1992.fun/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/</link><description>Recent content in 编程开发 on star徐的博客</description><generator>Hugo -- 0.152.2</generator><language>zh-cn</language><lastBuildDate>Mon, 17 Nov 2025 23:58:00 +0800</lastBuildDate><atom:link href="http://ljj1992.fun/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>servlet基础知识</title><link>http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 17 Nov 2025 23:58:00 +0800</pubDate><guid>http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>&lt;h1 id="servlet基础知识"&gt;servlet基础知识&lt;/h1&gt;
&lt;p&gt;作为安全爱好者的基础性研究&lt;/p&gt;
&lt;p&gt;Servlet：名字的由来&lt;/p&gt;
&lt;p&gt;Servlet = “Server” + “Applet”
早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 &lt;strong&gt;服务器端&lt;/strong&gt; 的小程序，所以叫 “Server Applet”，简称 Servlet。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;它在解决什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;动态内容&lt;/strong&gt;：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;：传统 CGI 为每个请求开一个进程，开销大、响应慢。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨平台&lt;/strong&gt;：CGI 脚本依赖操作系统，移植困难。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;作用一句话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;底层逻辑与框架&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;动作&lt;/th&gt;
&lt;th&gt;关键角色&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1. 请求到达&lt;/td&gt;
&lt;td&gt;浏览器发 HTTP 请求到 Web 服务器（如 Tomcat）&lt;/td&gt;
&lt;td&gt;Web 服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2. 路由到 Servlet&lt;/td&gt;
&lt;td&gt;服务器根据 URL 把请求交给对应的 Servlet 类&lt;/td&gt;
&lt;td&gt;Servlet 容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3. 生命周期&lt;/td&gt;
&lt;td&gt;容器负责：加载类 → 创建实例 → 调用 &lt;code&gt;init()&lt;/code&gt; → 多次 &lt;code&gt;service()&lt;/code&gt; → 最终 &lt;code&gt;destroy()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Servlet 本身&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4. 处理请求&lt;/td&gt;
&lt;td&gt;&lt;code&gt;service()&lt;/code&gt; 方法根据 HTTP 方法（GET/POST）调用 &lt;code&gt;doGet()&lt;/code&gt;/&lt;code&gt;doPost()&lt;/code&gt;，开发者只写业务逻辑&lt;/td&gt;
&lt;td&gt;HttpServlet&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5. 生成响应&lt;/td&gt;
&lt;td&gt;通过 &lt;code&gt;HttpServletResponse&lt;/code&gt; 写回 HTML、JSON 或文件&lt;/td&gt;
&lt;td&gt;Servlet&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6. 线程复用&lt;/td&gt;
&lt;td&gt;同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁&lt;/td&gt;
&lt;td&gt;JVM 线程池&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;核心优势&lt;/strong&gt;&lt;/p&gt;</description></item></channel></rss>