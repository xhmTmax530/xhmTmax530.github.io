<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>基础编程 | star徐的博客</title><meta name=keywords content><meta name=description content="个人博客，分享技术心得和生活感悟"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://ljj1992.fun/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/index.xml title=rss><link rel=alternate hreflang=en href=http://ljj1992.fun/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="基础编程"><meta property="og:description" content="个人博客，分享技术心得和生活感悟"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="基础编程"><meta name=twitter:description content="个人博客，分享技术心得和生活感悟"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/tags/>Tags</a></div><h1>基础编程</h1></header><div class=posts><article class=post-entry><header class=entry-header><h2>AOP切面(java新手)</h2></header><div class=entry-content><p>AOP切面(java新手) 🌟 一、为什么要用 AOP？ 想象一下：你在开发一个电商网站，有几十个接口，比如
用户登录 下单 查看商品 修改地址 支付订单 这些功能都属于“业务逻辑”（核心功能）。但你发现，每个接口都需要做两件事：
记录日志（谁在什么时候调用了哪个接口？） 检查用户有没有权限（比如普通用户不能删别人订单） 如果不用 AOP，你可能会在每个方法里手动写日志和权限检查代码，像这样
问题来了：
代码重复！每个方法都要写一样的日志和权限。 业务逻辑被“污染”了，看不清核心功能。 如果哪天要改日志格式？得改几十个地方！ 👉 AOP 就是为了解决这种“横着切”的公共问题而生的！
👉 AOP 就是为了解决这种“横着切”的公共问题而生的！
✅ AOP 的核心思想： 把那些和业务无关但又到处要用的功能（比如日志、权限、事务、防重提交）抽出来，写在一个地方，自动“织入”到需要的地方。 业务代码只管做自己的事，干净清爽！
🧩 二、怎么理解 AOP？用两个真实例子 ✅ 自动记录接口日志（最常见！） 场景： 你想知道哪些用户调用了哪些接口、花了多长时间。
不用 AOP（麻烦）： 每个 Controller 方法里手写 logger.info(...)。
用 AOP（优雅）： 定义一个“切面”类（专门处理日志）： @Aspect @Component public class LogAspect { private static final Logger logger = LoggerFactory.getLogger(LogAspect.class); // 定义“切入点”：所有 Controller 包下的 public 方法 @Pointcut("execution(public * com.example.controller..*.*(..))") public void controllerMethods() {} // 在方法执行前记录开始 @Before("controllerMethods()") public void logBefore(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); logger.info("调用方法: {}, 参数: {}", methodName, Arrays.toString(args)); } // 在方法执行后记录耗时 @Around("controllerMethods()") public Object logTime(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); // 执行原方法 long time = System.currentTimeMillis() - start; logger.info("方法 {} 耗时 {}ms", joinPoint.getSignature().getName(), time); return result; } } 你的业务代码完全不用改！ @RestController public class OrderController { @PostMapping("/order") public String createOrder(@RequestBody Order order) { // 只写业务逻辑！日志自动加上了 orderService.save(order); return "success"; } } ✅ 效果：只要调用 /order，AOP 自动帮你打日志、算时间，业务代码零侵入！
...</p></div><footer class=entry-footer><span title='2025-11-23 18:30:00 +0800 +0800'>November 23, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to AOP切面(java新手)" href=http://ljj1992.fun/posts/aop%E5%88%87%E9%9D%A2/></a></article><article class=post-entry><header class=entry-header><h2>JNDI注入</h2></header><div class=entry-content><p>JNDI注入 什么是内存马 内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。
内存马常见类别 • Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。 • Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。 • 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。 • 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行
为什么会存在内存马 根本原因在于 Java 的“动态性”： • 类可以在运行时从网络、数据库或其他非文件源加载； • 字节码可以被 Instrumentation API 在运行时修改； • 反射和动态代理允许在不改动源码的前提下改变程序行为。 攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。
Java 架构如何助长内存马 • JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类； • 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制； • “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。 因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。
一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。
一、什么是JNDI注入 JNDI为什么会成为黑客的工具
1.1 一句话区分： JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。
...</p></div><footer class=entry-footer><span title='2025-11-21 12:44:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to JNDI注入" href=http://ljj1992.fun/posts/jndi%E6%B3%A8%E5%85%A5/></a></article><article class=post-entry><header class=entry-header><h2>注解和Map(新手理解)</h2></header><div class=entry-content><p>注解和Map(新手理解) 把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。
Map 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：
第一列叫“键”（Key） 第二列叫“值”（Value） 只要给出一个 Key，就能立刻找到它对应的 Value。 常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。
举个生活化的例子： 如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。
注解和 Map 的关系 注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。 你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：
注解里的每一个属性（比如 @MyAnnotation(value="test", version=2) 中的 value、version） 都会被放进一个 Map 里，key 就是属性名，value 就是属性值。 当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。 所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景： 灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。
一句话总结 Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。
一、🎯 目标： 我们想做一个“用户信息校验”功能，比如：
用户名不能超过10个字符 年龄必须在18到60之间 邮箱必须包含 @ 符号 但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。
...</p></div><footer class=entry-footer><span title='2025-11-21 10:50:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 注解和Map(新手理解)" href=http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/></a></article><article class=post-entry><header class=entry-header><h2>策略模式</h2></header><div class=entry-content><p>策略模式 🌟 什么是策略模式？ 一句话解释：
策略模式就是“把不同的做法（算法）封装成独立的类，让它们可以互相替换，而不影响主程序”。
就像你出门：
可以走路 可以骑车 可以开车 可以坐地铁 这些是不同的“策略”，你根据情况选择一种。程序里也一样，我们可以把每种“方式”封装起来，随时切换。
✅ 场景举例：不同支付方式（微信、支付宝、银行卡）
我们写一个简单的购物程序，支持多种支付方式，使用策略模式来实现。
💡 第一步：定义一个“支付策略”接口 // 定义一个统一的“支付方式”接口 // 所有具体的支付方式（如微信、支付宝）都要实现这个接口 public interface PaymentStrategy { // 这个方法表示“执行支付”，具体怎么付由子类决定 void pay(double amount); } 🔍 解释：
interface 是 Java 中的“接口”，规定了一组行为（方法）。 这里说：任何支付方式都必须有 pay(double amount) 方法。 但不关心它内部怎么实现，只关心“能付钱”。 💡 第二步：实现具体的支付策略 1. 微信支付策略 // 微信支付的具体实现类 public class WeChatPayment implements PaymentStrategy { // 实现 pay 方法：用微信支付 @Override public void pay(double amount) { System.out.println("✅ 使用微信支付：金额 " + amount + " 元"); System.out.println("📱 扫码成功，正在扣款..."); System.out.println("🔔 微信提示：支付成功！"); } } 🔍 解释：
...</p></div><footer class=entry-footer><span title='2025-11-20 15:30:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 策略模式" href=http://ljj1992.fun/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/></a></article></div></main><footer class=footer><span>&copy; 2025 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>