<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>openspec新人手册 | star徐的博客</title><meta name=keywords content="openspec,spec,大模型编程"><meta name=description content='openspec新人手册
为什么选择 OpenSpec？
AI 编码助手功能强大，但如果需求记录在聊天记录中，其表现就难以预测。OpenSpec 提供了一种轻量级的规范工作流程，在实现之前锁定意图，从而提供确定性且可审查的输出。
主要成果：

在工作开始前，人类和人工智能相关人员需就技术规范达成一致。
结构化的变更文件夹（提案、任务和规范更新）使范围明确且可审计。
共享对已提议、正在进行或已存档内容的可见性。
可与您已使用的 AI 工具配合使用：在支持自定义斜杠命令的地方使用自定义斜杠命令，在其他所有地方使用上下文规则。

OpenSpec 的对比（概览）

轻量级：工作流程简单，无需 API 密钥，设置极少。
先进行现有功能移植：在 0→1 之后也能很好地工作。OpenSpec 将真实数据源与提案分开：@0#（当前真实数据源）和 @1#（提案更新）。这使得不同功能之间的差异清晰明了且易于管理。
变更跟踪：提案、任务和规范增量放在一起；归档会将已批准的更新合并回规范中。
与 spec-kit 和 Kiro 相比：它们在全新特性（0→1）方面表现出色。OpenSpec 在修改现有行为（1→n）方面也同样优秀，尤其是在更新涉及多个规范时。

工作原理
┌──────────────────────────────┐
│  1. 意图“翻译” (Draft)        │
│  (把“人话”变成“技术文档”)       │
└──────────────┬───────────────┘
               │  你的原始需求："给网页加个夜间模式"
               ▼
┌──────────────────────────────┐
│  2. 签订“施工合同” (Review)   │◀───[ 拒绝无效返工 ]───┐
│  (锁定修改范围，禁止AI乱动)     │                      │
└──────────────┬───────────────┘                      │
               │  你点头确认："就改这3个文件，别的别动"     │
               ▼                                      │
┌──────────────────────────────┐                      │
│  3. 傻瓜式执行 (Implement)    │ 🚧 发现逻辑漏洞？      │
│  (AI 闭嘴干活，只写代码)       │ 🛑 停！回去改文档！────┘
└──────────────┬───────────────┘
               │  代码跑通，测试通过
               ▼
┌──────────────────────────────┐
│  4. 更新“项目宪法” (Archive)  │
│  (让项目永远保持最新状态)       │
└──────────────────────────────┘
我把这个流程分成了四个更有深度的阶段，咱们一个个来看：'><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/openspec%E6%96%B0%E4%BA%BA%E6%89%8B%E5%86%8C/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/openspec%E6%96%B0%E4%BA%BA%E6%89%8B%E5%86%8C/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/openspec%E6%96%B0%E4%BA%BA%E6%89%8B%E5%86%8C/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="openspec新人手册"><meta property="og:description" content='openspec新人手册 为什么选择 OpenSpec？ AI 编码助手功能强大，但如果需求记录在聊天记录中，其表现就难以预测。OpenSpec 提供了一种轻量级的规范工作流程，在实现之前锁定意图，从而提供确定性且可审查的输出。
主要成果： 在工作开始前，人类和人工智能相关人员需就技术规范达成一致。 结构化的变更文件夹（提案、任务和规范更新）使范围明确且可审计。 共享对已提议、正在进行或已存档内容的可见性。 可与您已使用的 AI 工具配合使用：在支持自定义斜杠命令的地方使用自定义斜杠命令，在其他所有地方使用上下文规则。 OpenSpec 的对比（概览） 轻量级：工作流程简单，无需 API 密钥，设置极少。 先进行现有功能移植：在 0→1 之后也能很好地工作。OpenSpec 将真实数据源与提案分开：@0#（当前真实数据源）和 @1#（提案更新）。这使得不同功能之间的差异清晰明了且易于管理。 变更跟踪：提案、任务和规范增量放在一起；归档会将已批准的更新合并回规范中。 与 spec-kit 和 Kiro 相比：它们在全新特性（0→1）方面表现出色。OpenSpec 在修改现有行为（1→n）方面也同样优秀，尤其是在更新涉及多个规范时。 工作原理 ┌──────────────────────────────┐│ 1. 意图“翻译” (Draft) ││ (把“人话”变成“技术文档”) │└──────────────┬───────────────┘│ 你的原始需求："给网页加个夜间模式"▼┌──────────────────────────────┐│ 2. 签订“施工合同” (Review) │◀───[ 拒绝无效返工 ]───┐│ (锁定修改范围，禁止AI乱动) │ │└──────────────┬───────────────┘ ││ 你点头确认："就改这3个文件，别的别动" │▼ │┌──────────────────────────────┐ ││ 3. 傻瓜式执行 (Implement) │ 🚧 发现逻辑漏洞？ ││ (AI 闭嘴干活，只写代码) │ 🛑 停！回去改文档！────┘└──────────────┬───────────────┘│ 代码跑通，测试通过▼┌──────────────────────────────┐│ 4. 更新“项目宪法” (Archive) ││ (让项目永远保持最新状态) │└──────────────────────────────┘ 我把这个流程分成了四个更有深度的阶段，咱们一个个来看：'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-13T15:30:00+08:00"><meta property="article:modified_time" content="2025-12-13T15:30:00+08:00"><meta property="article:tag" content="Openspec"><meta property="article:tag" content="Spec"><meta property="article:tag" content="大模型编程"><meta name=twitter:card content="summary"><meta name=twitter:title content="openspec新人手册"><meta name=twitter:description content='openspec新人手册
为什么选择 OpenSpec？
AI 编码助手功能强大，但如果需求记录在聊天记录中，其表现就难以预测。OpenSpec 提供了一种轻量级的规范工作流程，在实现之前锁定意图，从而提供确定性且可审查的输出。
主要成果：

在工作开始前，人类和人工智能相关人员需就技术规范达成一致。
结构化的变更文件夹（提案、任务和规范更新）使范围明确且可审计。
共享对已提议、正在进行或已存档内容的可见性。
可与您已使用的 AI 工具配合使用：在支持自定义斜杠命令的地方使用自定义斜杠命令，在其他所有地方使用上下文规则。

OpenSpec 的对比（概览）

轻量级：工作流程简单，无需 API 密钥，设置极少。
先进行现有功能移植：在 0→1 之后也能很好地工作。OpenSpec 将真实数据源与提案分开：@0#（当前真实数据源）和 @1#（提案更新）。这使得不同功能之间的差异清晰明了且易于管理。
变更跟踪：提案、任务和规范增量放在一起；归档会将已批准的更新合并回规范中。
与 spec-kit 和 Kiro 相比：它们在全新特性（0→1）方面表现出色。OpenSpec 在修改现有行为（1→n）方面也同样优秀，尤其是在更新涉及多个规范时。

工作原理
┌──────────────────────────────┐
│  1. 意图“翻译” (Draft)        │
│  (把“人话”变成“技术文档”)       │
└──────────────┬───────────────┘
               │  你的原始需求："给网页加个夜间模式"
               ▼
┌──────────────────────────────┐
│  2. 签订“施工合同” (Review)   │◀───[ 拒绝无效返工 ]───┐
│  (锁定修改范围，禁止AI乱动)     │                      │
└──────────────┬───────────────┘                      │
               │  你点头确认："就改这3个文件，别的别动"     │
               ▼                                      │
┌──────────────────────────────┐                      │
│  3. 傻瓜式执行 (Implement)    │ 🚧 发现逻辑漏洞？      │
│  (AI 闭嘴干活，只写代码)       │ 🛑 停！回去改文档！────┘
└──────────────┬───────────────┘
               │  代码跑通，测试通过
               ▼
┌──────────────────────────────┐
│  4. 更新“项目宪法” (Archive)  │
│  (让项目永远保持最新状态)       │
└──────────────────────────────┘
我把这个流程分成了四个更有深度的阶段，咱们一个个来看：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"openspec新人手册","item":"http://ljj1992.fun/posts/openspec%E6%96%B0%E4%BA%BA%E6%89%8B%E5%86%8C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"openspec新人手册","name":"openspec新人手册","description":"openspec新人手册 为什么选择 OpenSpec？ AI 编码助手功能强大，但如果需求记录在聊天记录中，其表现就难以预测。OpenSpec 提供了一种轻量级的规范工作流程，在实现之前锁定意图，从而提供确定性且可审查的输出。\n主要成果： 在工作开始前，人类和人工智能相关人员需就技术规范达成一致。 结构化的变更文件夹（提案、任务和规范更新）使范围明确且可审计。 共享对已提议、正在进行或已存档内容的可见性。 可与您已使用的 AI 工具配合使用：在支持自定义斜杠命令的地方使用自定义斜杠命令，在其他所有地方使用上下文规则。 OpenSpec 的对比（概览） 轻量级：工作流程简单，无需 API 密钥，设置极少。 先进行现有功能移植：在 0→1 之后也能很好地工作。OpenSpec 将真实数据源与提案分开：@0#（当前真实数据源）和 @1#（提案更新）。这使得不同功能之间的差异清晰明了且易于管理。 变更跟踪：提案、任务和规范增量放在一起；归档会将已批准的更新合并回规范中。 与 spec-kit 和 Kiro 相比：它们在全新特性（0→1）方面表现出色。OpenSpec 在修改现有行为（1→n）方面也同样优秀，尤其是在更新涉及多个规范时。 工作原理 ┌──────────────────────────────┐\r│ 1. 意图“翻译” (Draft) │\r│ (把“人话”变成“技术文档”) │\r└──────────────┬───────────────┘\r│ 你的原始需求：\u0026#34;给网页加个夜间模式\u0026#34;\r▼\r┌──────────────────────────────┐\r│ 2. 签订“施工合同” (Review) │◀───[ 拒绝无效返工 ]───┐\r│ (锁定修改范围，禁止AI乱动) │ │\r└──────────────┬───────────────┘ │\r│ 你点头确认：\u0026#34;就改这3个文件，别的别动\u0026#34; │\r▼ │\r┌──────────────────────────────┐ │\r│ 3. 傻瓜式执行 (Implement) │ 🚧 发现逻辑漏洞？ │\r│ (AI 闭嘴干活，只写代码) │ 🛑 停！回去改文档！────┘\r└──────────────┬───────────────┘\r│ 代码跑通，测试通过\r▼\r┌──────────────────────────────┐\r│ 4. 更新“项目宪法” (Archive) │\r│ (让项目永远保持最新状态) │\r└──────────────────────────────┘ 我把这个流程分成了四个更有深度的阶段，咱们一个个来看：\n","keywords":["openspec","spec","大模型编程"],"articleBody":"openspec新人手册 为什么选择 OpenSpec？ AI 编码助手功能强大，但如果需求记录在聊天记录中，其表现就难以预测。OpenSpec 提供了一种轻量级的规范工作流程，在实现之前锁定意图，从而提供确定性且可审查的输出。\n主要成果： 在工作开始前，人类和人工智能相关人员需就技术规范达成一致。 结构化的变更文件夹（提案、任务和规范更新）使范围明确且可审计。 共享对已提议、正在进行或已存档内容的可见性。 可与您已使用的 AI 工具配合使用：在支持自定义斜杠命令的地方使用自定义斜杠命令，在其他所有地方使用上下文规则。 OpenSpec 的对比（概览） 轻量级：工作流程简单，无需 API 密钥，设置极少。 先进行现有功能移植：在 0→1 之后也能很好地工作。OpenSpec 将真实数据源与提案分开：@0#（当前真实数据源）和 @1#（提案更新）。这使得不同功能之间的差异清晰明了且易于管理。 变更跟踪：提案、任务和规范增量放在一起；归档会将已批准的更新合并回规范中。 与 spec-kit 和 Kiro 相比：它们在全新特性（0→1）方面表现出色。OpenSpec 在修改现有行为（1→n）方面也同样优秀，尤其是在更新涉及多个规范时。 工作原理 ┌──────────────────────────────┐\r│ 1. 意图“翻译” (Draft) │\r│ (把“人话”变成“技术文档”) │\r└──────────────┬───────────────┘\r│ 你的原始需求：\"给网页加个夜间模式\"\r▼\r┌──────────────────────────────┐\r│ 2. 签订“施工合同” (Review) │◀───[ 拒绝无效返工 ]───┐\r│ (锁定修改范围，禁止AI乱动) │ │\r└──────────────┬───────────────┘ │\r│ 你点头确认：\"就改这3个文件，别的别动\" │\r▼ │\r┌──────────────────────────────┐ │\r│ 3. 傻瓜式执行 (Implement) │ 🚧 发现逻辑漏洞？ │\r│ (AI 闭嘴干活，只写代码) │ 🛑 停！回去改文档！────┘\r└──────────────┬───────────────┘\r│ 代码跑通，测试通过\r▼\r┌──────────────────────────────┐\r│ 4. 更新“项目宪法” (Archive) │\r│ (让项目永远保持最新状态) │\r└──────────────────────────────┘ 我把这个流程分成了四个更有深度的阶段，咱们一个个来看：\n第一阶段：意图“翻译” (The Translation) 原来叫： Draft Change Proposal 白话理解： “拒绝口头支票” 你在聊天框里跟 AI 说得再天花乱坠，那都是“口头支票”，AI 转头就忘。 这一步的核心在于固化。OpenSpec 逼着 AI 把它脑子里的想法写成 Markdown 文档。 心法： 所有的需求，必须先落实在纸面上，才能开始动工。 第二阶段：签订“施工合同” (The Contract) 原来叫： Review \u0026 Align 白话理解： “画圈圈，立规矩” 这是整个流程里你权力最大的时候。 OpenSpec 会生成一个 spec.md（规格书）。这就像一份合同，规定了 AI 能动哪里，不能动哪里。 这一步是为了解决 AI “胡乱发挥”的毛病。如果没有这份合同，AI 可能会为了修个水龙头把整栋楼拆了。 心法： 文档没改对，一行代码都不许写。 第三阶段：傻瓜式执行 (The Execution) 原来叫： Implement Tasks 白话理解： “带着镣铐跳舞” 注意看右边那个回流箭头（拒绝无效返工）。 传统的 AI 编程是：写错了 -\u003e 手动改代码 -\u003e 再跑 -\u003e 又错了。这是恶性循环。 OpenSpec 的逻辑是：如果 AI 发现代码写不下去，说明刚才的合同（文档）有漏洞。 这时候严禁硬写！必须退回第二阶段，把文档改清楚了，再重新执行。 心法： 修 bug 先修文档，治标更要治本。 第四阶段：更新“项目宪法” (The Constitution) 原来叫： Archive \u0026 Update Specs 白话理解： “刷新记忆库” 很多项目做久了，AI 就不认识了，因为代码变了，但文档没变。 OpenSpec 的“归档”动作，就是把刚才这次修改，合并到项目的总说明书（Source of Truth）里。 这样，下一次你再让 AI 干活时，它看到的是一个完全与时俱进的项目描述，而不是一个月前的旧版本。 心法： 铁打的文档，流水的代码。文档才是项目的灵魂。 核心命令使用(claude-code) 一棒：/openspec:proposal (发起提案) 🧐 它的作用： 告诉 AI：“我有新想法了，别急着写代码，先给我出个方案。” 这是**“立项”**命令。\n📝 语法格式： /openspec:proposal \u003c你想做什么\u003e\n🎬 实战演示： 在你的 Claude Code 或 Cursor 聊天框里输入：\n/openspec:proposal 在首页底部增加一个“联系我们”的表单，包含姓名、邮箱和留言三个输入框。 ⚙️ 发生什么了？ AI 不会修改你的 index.html 或 app.js。 它会在后台悄悄创建一个文件夹（比如 openspec/changes/add-contact-form/），并在里面生成三个文件：\nproposal.md：写着为什么要加表单。 tasks.md：写着第一步改 HTML，第二步写 CSS，第三步写 JS 验证。 spec.md：写着表单的具体字段要求。 点评： 这一步是安全网。这时候后悔还来得及，反正代码还没动。\n(中间插曲：人工审核) 这一步虽然没有命令，但必不可少。你看一眼 AI 生成的文档，如果不满意，就用自然语言让它改。\n第二棒：/openspec:apply (执行施工) 🧐 它的作用： 告诉 AI：“方案我看过了，没问题，动手写代码吧！” 这是**“落地”**命令。\n📝 语法格式： /openspec:apply \u003c提案名称\u003e (注：通常 AI 知道你在聊哪个提案，所以有时直接输 /openspec:apply 也可以，但加上名字最保险)\n🎬 实战演示： 你觉得方案 OK 了，输入：\n/openspec:apply add-contact-form (注：add-contact-form 是 AI 刚才生成的文件夹名字，你不用死记，AI 通常会提示你，或者你直接说“apply the current proposal”也行)\n⚙️ 发生什么了？ 这次 AI 动真格的了。 它会读取 tasks.md，然后像个疯狂的打字员一样：\n打开 index.html，插入 … 代码。 打开 style.css，加上表单的样式。 每做完一步，就在 tasks.md 里打个 ✅。 点评： 这是最爽的一步。你喝着咖啡，看着屏幕上的代码自动生成。\n(中间插曲：验收测试) 你去网页上点一点那个表单，看看能不能用。如果不能用，别急着归档，先修 Bug。\n第三棒：/openspec:archive (归档入库) 🧐 它的作用： 告诉 AI：“活儿干得漂亮，结账收工，把这段记忆存进大脑。” 这是**“更新记忆”**命令。\n📝 语法格式： /openspec:archive \u003c提案名称\u003e\n🎬 实战演示： 测试没问题了，输入：\n/openspec:archive add-contact-form ⚙️ 发生什么了？\n合并记忆： OpenSpec 会把这次新增的“表单功能说明”合并到项目的总文档 openspec/project.md 里。以后 AI 就知道这个项目有联系表单了。 清理现场： openspec/changes/add-contact-form/ 这个临时文件夹会被移走（移到 archive 目录），保证工作区干干净净。 点评： 如果不做这一步，你的项目文件夹里会堆满临时的提案垃圾，而且 AI 以后可能会忘掉它做过这个功能。\n把这张小纸条存下来，以后忘了就看一眼：\n命令 英文原意 中文大白话 什么时候用？ /openspec:proposal Proposal (提案) “给我出个方案” 刚开始有想法，还没写代码时 /openspec:apply Apply (应用) “照方案干活” 方案审核通过，准备写代码时 /openspec:archive Archive (归档) “完工入库” 代码测试通过，准备做下一个功能时 大白话解释 第一部分：OpenSpec 是干嘛的？（大白话定义） 想象一下，你是一个装修队的工头（人类），你雇了一个干活巨快但记性不太好、而且特别喜欢“自我发挥”的工人（AI大模型）。\n没有 OpenSpec 之前： 你跟工人说：“给我把这面墙刷得好看点。” 工人（AI）直接上手就干，刷成了粉色。 你急了：“不对，我要的是工业风的水泥灰！” 工人：“哦哦好的。”然后把粉色铲了，又刷了一遍灰的，但把窗框也刷灰了。 你又急了：“窗框别动啊！” 结果： 浪费了油漆（Token费），浪费了时间，最后出来的东西还未必是你想要的。这就叫“Vibe Coding”（凭感觉编程）。\n有了 OpenSpec 之后： 你不需要直接喊工人干活。你先用 OpenSpec 写一张**“施工图纸”**（Spec）。\n你告诉 OpenSpec：“我要弄这面墙。” OpenSpec 帮你生成一份文档：“目标：刷墙。颜色：水泥灰 #808080。范围：只刷墙面，不碰窗框。验收标准：平整无气泡。” 你检查一下文档，说：“对，就是这样。” 然后把这份文档甩给工人（AI）：“照着这个干，不许自由发挥。” 结果： 工人一次性把活干完，完全符合要求。 总结： OpenSpec 就是一个用来给 AI 立“规矩”和写“说明书”的工具。 它强迫你在 AI 写代码之前，先和 AI 确认好“我们要干什么”，从而避免 AI 写出垃圾代码或错误代码。\n第二部分：它解决了什么痛点？ 在目前的大模型编程（比如用 Cursor, GitHub Copilot, Claude）中，主要有这三个痛点，OpenSpec 都能解决：\nAI 的“失忆症”： 你在对话框里聊了50句，AI 可能就忘了第1句你要求的“按钮要是圆角的”。 OpenSpec 解决： 它把要求写在文件里，永久保存，AI 随时都能看到。 AI 的“胡乱发挥”： 你让它加个功能，它可能顺手把你之前的逻辑改坏了。 OpenSpec 解决： 通过“提案（Proposal）”机制，锁定了修改范围，AI 只能动你允许它动的地方。 沟通成本高（费钱）： 反反复复修改代码非常消耗 Token（钱）。 OpenSpec 解决： 先修改文档，文档改对了再写代码，一次成型，省钱。 第三部分：它的工作原理（设计与使用） OpenSpec 不需要你懂什么复杂的底层算法，它其实就是一套**“文件管理流程”**。\n1. 设计原理：Markdown 为王 它不依赖任何 API Key（不直接调大模型），它只是生成一堆 .md (Markdown) 格式的文档。因为大模型最擅长读懂 Markdown。它把你的项目分成了两个状态：\n现状（Source of Truth）： 项目现在是什么样子的？ 变更（Change Proposal）： 我们打算把项目改成什么样子？ 2. 使用原理（核心三步走） OpenSpec 创造了一个标准的“工作流”：\n第一步：起草 (Draft) 你告诉 AI：“我想加个夜间模式”。OpenSpec 会让 AI 生成一份 proposal.md（提案），里面写清楚了为什么要加、怎么加、涉及哪些文件。 第二步：审核 (Review) 你看一眼提案。如果觉得 AI 理解错了，直接改文档，或者让 AI 重写文档。这时候一行代码都还没写呢，改起来成本极低。 第三步：执行 (Apply) 你点头同意后，AI 读取这个提案，开始写代码。写完后，OpenSpec 会把这次变动“归档”，更新项目的整体说明书。 你好！我是人工智能应用方面的专家，很高兴能作为你的“老师”来为你深度剖析 OpenSpec 这个技术。\n你发给我的链接指向的是 Fission-AI 开发的 OpenSpec 项目。别被满屏的代码吓到了，这个工具的核心逻辑非常简单，但它解决了一个目前大模型编程（AI Coding）中最让人头疼的问题。\n为了让你彻底明白，我们不讲晦涩的术语，我把整个概念“嚼碎”了讲给你听。\n第一部分：OpenSpec 是干嘛的？（大白话定义） 想象一下，你是一个装修队的工头（人类），你雇了一个干活巨快但记性不太好、而且特别喜欢“自我发挥”的工人（AI大模型）。\n没有 OpenSpec 之前： 你跟工人说：“给我把这面墙刷得好看点。” 工人（AI）直接上手就干，刷成了粉色。 你急了：“不对，我要的是工业风的水泥灰！” 工人：“哦哦好的。”然后把粉色铲了，又刷了一遍灰的，但把窗框也刷灰了。 你又急了：“窗框别动啊！” 结果： 浪费了油漆（Token费），浪费了时间，最后出来的东西还未必是你想要的。这就叫“Vibe Coding”（凭感觉编程）。\n有了 OpenSpec 之后： 你不需要直接喊工人干活。你先用 OpenSpec 写一张**“施工图纸”**（Spec）。[1]\n你告诉 OpenSpec：“我要弄这面墙。” OpenSpec 帮你生成一份文档：“目标：刷墙。颜色：水泥灰 #808080。范围：只刷墙面，不碰窗框。验收标准：平整无气泡。” 你检查一下文档，说：“对，就是这样。” 然后把这份文档甩给工人（AI）：“照着这个干，不许自由发挥。” 结果： 工人一次性把活干完，完全符合要求。 总结： OpenSpec 就是一个用来给 AI 立“规矩”和写“说明书”的工具。 它强迫你在 AI 写代码之前，先和 AI 确认好“我们要干什么”，从而避免 AI 写出垃圾代码或错误代码。[2]\n第二部分：它解决了什么痛点？ 在目前的大模型编程（比如用 Cursor, GitHub Copilot, Claude）中，主要有这三个痛点，OpenSpec 都能解决：\nAI 的“失忆症”： 你在对话框里聊了50句，AI 可能就忘了第1句你要求的“按钮要是圆角的”。 OpenSpec 解决： 它把要求写在文件里，永久保存，AI 随时都能看到。 AI 的“胡乱发挥”： 你让它加个功能，它可能顺手把你之前的逻辑改坏了。 OpenSpec 解决： 通过“提案（Proposal）”机制，锁定了修改范围，AI 只能动你允许它动的地方。 沟通成本高（费钱）： 反反复复修改代码非常消耗 Token（钱）。 OpenSpec 解决： 先修改文档，文档改对了再写代码，一次成型，省钱。 第三部分：它的工作原理（设计与使用） OpenSpec 不需要你懂什么复杂的底层算法，它其实就是一套**“文件管理流程”**。\n1. 设计原理：Markdown 为王 它不依赖任何 API Key（不直接调大模型），它只是生成一堆 .md (Markdown) 格式的文档。因为大模型最擅长读懂 Markdown。它把你的项目分成了两个状态：\n现状（Source of Truth）： 项目现在是什么样子的？ 变更（Change Proposal）： 我们打算把项目改成什么样子？ 2. 使用原理（核心三步走） OpenSpec 创造了一个标准的“工作流”：\n第一步：起草 (Draft) 你告诉 AI：“我想加个夜间模式”。OpenSpec 会让 AI 生成一份 proposal.md（提案），里面写清楚了为什么要加、怎么加、涉及哪些文件。 第二步：审核 (Review) 你看一眼提案。如果觉得 AI 理解错了，直接改文档，或者让 AI 重写文档。这时候一行代码都还没写呢，改起来成本极低。 第三步：执行 (Apply) 你点头同意后，AI 读取这个提案，开始写代码。写完后，OpenSpec 会把这次变动“归档”，更新项目的整体说明书。 第四部分：安装和使用 假设你现在有一个项目（或者新建一个空文件夹），我们来实操一下。\n1. 安装前的准备 你需要电脑上有 Node.js 环境（版本最好在 20 以上）。\n打开终端（命令行），输入：\nnode -v 如果有版本号蹦出来，说明环境OK。\n2. 安装 OpenSpec 在终端输入这行命令，把它安装到你电脑的全局环境中：\nnpm install -g @fission-ai/openspec@latest 3. 开始使用（初始化） 进入你的项目文件夹：\ncd my-project 初始化 OpenSpec：\nopenspec init 这时候它会问你：“你在用什么 AI 工具？”（比如 Claude Code, Cursor, Copilot 等）。选你正在用的那个。 完成后，你会发现项目里多了一个 openspec/ 文件夹，里面有个 project.md，这里面就是你项目的“户口本”（项目简介、技术栈等）。\n4. 实战案例：给网页加个“重置”按钮 假设你在做一个网页，现在想加个按钮。\nStep 1: 告诉 AI 你的想法 在你的 AI 聊天窗口（比如 Cursor 的 Chat）里，输入：\n“帮我创建一个 OpenSpec 提案：在首页添加一个重置按钮，点击后清空所有输入框。”\nStep 2: AI 生成“施工图” AI 会调用 OpenSpec，在 openspec/changes/ 目录下生成一个文件夹，里面有：\nproposal.md：写了我们要加按钮。 tasks.md：写了具体步骤（1. 改HTML，2. 改CSS，3. 改JS）。 spec.md：详细的技术规格。 Step 3: 你来当监工 打开 proposal.md 看看。\n你发现 AI 忘了说按钮颜色。 你直接对 AI 说：“在 Spec 里补充一下，按钮必须是红色的。” AI 更新文档。 Step 4: 动手施工 文档确认无误后，你输入指令（或告诉 AI）：\n“执行这个 OpenSpec 提案。” (通常命令是 /openspec apply)\nAI 就会严格按照 tasks.md 里的步骤，一步步把代码写好。\nStep 5: 完工归档 测试按钮没问题了，告诉 AI：\n“归档这个提案。”(命令 /openspec archive)\nOpenSpec 会把这次修改记录下来，以后 AI 再看你的项目，就知道“哦，这有个红色的重置按钮”。\n第五部分：如何提高使用效率？ 善用 project.md： 这是 OpenSpec 的核心大脑。把你项目的**“家规”**写进去。比如：“所有变量必须用驼峰命名”、“必须写注释”、“不许使用 jQuery”。这样 AI 以后生成的每一个提案都会遵守这些家规。 不要在 Chat 里长篇大论： 以后不要在聊天框里写几百字的 Prompt 了。把复杂的逻辑让 AI 先生成 Proposal，你在文档里改。改文档比改代码容易一万倍。 小步快跑： 不要一个提案里包含“重构整个系统”。一个提案做一个功能（比如“加按钮”是一个提案，“修Bug”是另一个）。这样不容易出错。 官方案例 1. 起草提案 (Draft the Proposal) 首先，让你的 AI 创建一个变更提案。\n你 (User): 创建一个 OpenSpec 变更提案：添加基于角色和团队的个人资料搜索过滤器。\r(对于支持斜杠命令的工具如 Claude Code，可以使用快捷键: /openspec:proposal 添加个人资料搜索过滤器)\rAI:好的，我将为个人资料过滤器创建一个 OpenSpec 变更提案。\r正在搭建脚手架目录 openspec/changes/add-profile-filters/，包含 proposal.md, tasks.md, spec deltas（规格变更量）。 🧑‍🏫 深度解析 这一步做了什么： 这是项目的**“立项”**阶段。你只是动了动嘴（或者敲了一行命令），OpenSpec 就不仅听懂了，还帮你创建了一个专属的文件夹。它把你脑子里模糊的想法，变成了三个实实在在的文件（提案、任务清单、规格变更）。 目的是什么： 拒绝口头支票。把需求“物理化”，防止 AI 听完就忘，或者理解偏差。 接下去将展开： 现在只是有了“草稿”，但草稿对不对呢？我们需要进入下一步——检查。 2. 验证与审查 (Verify \u0026 Review) 检查变更是否正确创建，并审查提案内容。\n$ openspec list # 确认变更文件夹是否已存在（查看当前有哪些正在进行的提案）\r$ openspec validate add-profile-filters # 验证 spec 的格式是否正确（确保没有语法错误）\r$ openspec show add-profile-filters # 查看提案、任务清单和规格变更的详细内容（这是给你人工审核用的） 🧑‍🏫 深度解析 这一步做了什么： 这是**“安检”**阶段。在你还没开始真正干活之前，先用这三个命令确认一下：文件夹建好了没？格式对不对？内容是不是我想要的？ 目的是什么： 排雷。如果格式有错（validate 报错），或者 AI 理解反了（show 显示的内容不对），现在发现只需要改改文档。要是等到写代码时才发现，成本就高了。 接下去将展开： 通常你看完 openspec show 的内容后，会发现 AI 的理解可能还不够完美，或者漏了点细节。所以下一步是——修改和完善。 3. 完善规格说明 (Refine the Specs) 反复迭代规格说明，直到它们符合你的需求。\n你 (User): 你能为角色和团队过滤器添加验收标准吗？（比如：必须能多选，或者搜不到时显示什么）\rAI: 好的，我将更新规格变更，增加角色和团队过滤器的场景描述。\r*正在编辑 openspec/changes/add-profile-filters/specs/profile/spec.md 和 tasks.md 文件。* 🧑‍🏫 深度解析 这一步做了什么： 这是**“讨价还价”**阶段，也是 OpenSpec 最核心的价值所在。你发现 AI 漏了“验收标准”，于是你指出来，AI 乖乖回去改文档（而不是改代码）。 目的是什么： 精准对齐。通过修改 Markdown 文档，把你脑子里的细节 100% 复制到 AI 的脑子里。在这个阶段，改文档几乎是零成本的。 接下去将展开： 当你觉得文档已经完美无缺，没有任何漏洞了，就可以下令进入最激动人心的环节——执行。 4. 执行变更 (Implement the Change) 一旦规格说明看起来没问题了，就开始实施。\n你 (User): 规格说明看起来不错。我们要开始实施这个变更了。\r(对于支持斜杠命令的工具，快捷键: /openspec:apply add-profile-filters)\rAI: 好的，我将开始处理 add-profile-filters 变更中的任务。\r*正在根据 openspec/changes/add-profile-filters/tasks.md 中的步骤实施代码修改*\r*标记任务完成: 任务 1.1 ✓, 任务 1.2 ✓, 任务 2.1 ✓...* 🧑‍🏫 深度解析 这一步做了什么： 这是**“自动驾驶”**阶段。你发令枪一响，AI 就变身成了一个没有感情的编码机器。它读取刚才那份被你确认过的 tasks.md，一步一步地去修改你的源代码文件。 目的是什么： 落地变现。把纸面上的文档变成能跑的代码。注意，因为前一步你已经把文档审得很细了，所以这一步通常是一次过的，极少出错。 接下去将展开： 代码写完了，任务也都打钩了（✓）。这时候你的项目里多了一堆新代码，和一堆用过的 OpenSpec 临时文件。我们需要——收尾。 5. 归档已完成的变更 (Archive the Completed Change) 实施完成后，对变更进行归档。\nAI:所有任务已完成。实施工作已就绪。\r你 (User): 请归档这个变更。\r(对于支持斜杠命令的工具，快捷键: /openspec:archive add-profile-filters)\rAI:好的，我将归档 add-profile-filters 这个变更。\r*后台运行命令: openspec archive add-profile-filters --yes*\r✓ 变更归档成功。规格说明已更新。准备好开发下一个功能了！ 或者你可以自己在终端里运行命令：\n$ openspec archive add-profile-filters --yes # 归档已完成的变更，且不进行交互式提示（直接确定） 注意： 那些原生支持斜杠命令的工具（如 Claude Code, CodeBuddy, Cursor, Codex, Qoder, RooCode）可以使用上面展示的快捷键。其他工具则使用自然语言请求，比如直接说“创建一个 OpenSpec 提案”、“应用 OpenSpec 变更”或“归档变更”。\n🧑‍🏫 深度解析 这一步做了什么： 这是**“入库”**阶段。OpenSpec 会把刚才那个临时文件夹里的精华（新的规格说明）合并到项目的总文档里，然后把临时文件夹移走。 目的是什么： 更新记忆。这一次的修改变成了项目历史的一部分。下次你再让 AI 改别的东西时，它就知道：“哦，这个项目已经有搜索过滤器了”。 接下去将展开： 这一个轮回结束了。你可以喝杯咖啡，准备开始下一个轮回（回到第1步 Draft）。 命令参考手册 (Command Reference) openspec list # 查看当前活跃的变更文件夹（看看有哪些活儿还没干完）\ropenspec view # 启动一个交互式的仪表盘，可视化查看规格和变更（不用对着黑乎乎的终端看）\ropenspec show # 显示某个变更的详情（包括提案、任务列表、规格更新内容）\ropenspec validate # 检查规格说明的格式和结构是否标准（语法检查）\ropenspec archive [--yes|-y] # 将已完成的变更移动到 archive/ 目录（加上 --yes 表示不需要我再确认，直接移） 示例：AI 是如何创建 OpenSpec 文件的 当你要求你的 AI 助手“添加双因素认证（2FA）”时，它会创建如下结构：\nopenspec/\r├── specs/\r│ └── auth/\r│ └── spec.md # 当前已有的认证规格说明 (如果项目里本来就有的话)\r└── changes/\r└── add-2fa/ # AI 自动创建的整个结构，这就是\"提案文件夹\"\r├── proposal.md # 原因和变更内容 (Why \u0026 What)\r├── tasks.md # 实施清单 (How - 一步步怎么做)\r├── design.md # 技术决策 (可选文件，比如为什么选这个算法)\r└── specs/\r└── auth/\r└── spec.md # 增量文件，展示了这次要在原基础上“加”什么 AI 生成的规格说明 (位于 openspec/specs/auth/spec.md)： 这是项目里原本就有的“真理”文件\n# 认证规格说明 (Auth Specification)\r## 目的 (Purpose)\r负责认证和会话管理。\r## 需求 (Requirements)\r### 需求：用户登录\r系统必须 (SHALL) 在登录成功后签发一个 JWT 令牌。\r#### 场景：凭证有效\r- 当 (WHEN) 用户提交有效的凭证\r- 那么 (THEN) 返回一个 JWT 令牌 AI 生成的变更增量 (位于 openspec/changes/add-2fa/tasks.md 等)： 这是 AI 打算怎么干活的任务清单\n## 1. 数据库设置 (Database Setup)\r- [ ] 1.1 在 users 表中添加 OTP 密钥列\r- [ ] 1.2 创建 OTP 验证日志表\r## 2. 后端实现 (Backend Implementation)\r- [ ] 2.1 添加 OTP 生成接口 (Endpoint)\r- [ ] 2.2 修改登录流程以要求 OTP\r- [ ] 2.3 添加 OTP 验证接口\r## 3. 前端更新 (Frontend Updates)\r- [ ] 3.1 创建 OTP 输入组件\r- [ ] 3.2 更新登录界面的 UI 重要提示： 你不需要手动创建这些文件。你的 AI 助手会根据你的要求和现有的代码库自动生成它们。\n理解 OpenSpec 文件 (Understanding OpenSpec Files) 增量格式 (Delta Format) “增量 (Deltas)” 就像是补丁，用来展示规格说明是如何变化的：\n## ADDED Requirements - 新增的能力（这一块是新加的） ## MODIFIED Requirements - 变更的行为（这一块改了，要包含修改后的完整文本） ## REMOVED Requirements - 废弃的功能（这一块不要了） 格式要求：\n使用 ### Requirement: \u003c名称\u003e 作为标题 每个需求至少需要包含一个 #### Scenario:（场景）块 在需求文本中必须使用 SHALL（必须）/ MUST（一定）等关键词（这是 RFC 标准术语，表示强制性） 🧑‍🏫 总结 这最后一部分是在教 AI “怎么写文档”。 OpenSpec 规定了一种很严谨的格式（类似法律条文）。为什么？ 因为只有格式严谨了，AI 执行起来才不会产生歧义。\n你看，它要求用 SHALL（必须），要求写 Scenario（场景：当…时，发生…）。这其实就是把我们平时说的“大白话”翻译成了“机器能听懂的逻辑语言”。\n全课总结： 这一整套流程，看着步骤多，其实就是为了解决一个核心问题：消除歧义。 通过 提案 -\u003e 审核 -\u003e 清单 -\u003e 执行 -\u003e 归档 这五步，你和 AI 之间就建立了一种极其高效、极其精准的合作关系。\n其他补充 需不要把AGENTS.md复制给AI 1. 为什么会有“复制”这个动作？\n官方教程里提到的“复制 AGENTS.md”其实是一个兜底方案（Fallback）。 它是为了兼容那些不支持自动读取配置的“傻瓜式”聊天界面（比如网页版的 ChatGPT 或 Claude 网页版），因为那些界面不知道你本地有个文件叫 AGENTS.md。\n但在 CLI（命令行）环境下，Claude Code 是有能力直接读取本地文件的。\n2. 如何验证你是否需要复制？（一招辨别）\n打开你的终端，进入项目目录，运行 claude 进入交互模式，然后直接输入斜杠 /：\n测试动作： 输入 /openspec 然后按 Tab 键（或者看提示）。 判断标准： ✅ 如果你看到了类似 /openspec:proposal、/openspec:apply 这样的命令提示： 恭喜你！OpenSpec 已经成功“注入”了 Claude Code。你不需要复制任何东西。直接下命令，Claude 会自动去后台读取 AGENTS.md 的规则。 ❌ 如果你输入 /openspec 没有任何反应，或者 Claude 说“不认识这个命令”： 说明自动配置没生效，这时候才需要手动干预（但也不用每次都复制，看下面）。 3. 如果没生效，怎么做“一次性配置”？\n如果上面的测试失败了，不要每次都复制粘贴。我们可以利用 Claude Code 的 CLAUDE.md 机制来做个“永久软链接”。\n“聪明人”的做法：\n在你的项目根目录下，创建一个名为 CLAUDE.md 的文件（如果已有，就编辑它），在里面写上一句话：\n# Project Instructions\rPlease strictly follow the guidelines and workflows defined in ./openspec/AGENTS.md 原理： Claude Code CLI 启动时，默认会自动寻找并读取项目根目录下的 CLAUDE.md。 通过这行字，你相当于告诉 Claude：“兄弟，在这个项目里怎么干活，你去读那个文件，我就不啰嗦了。”\n什么时候需要spec ![](Spec vs Vibe Coding-2025-12-14-075511.svg)\n","wordCount":"1272","inLanguage":"en","datePublished":"2025-12-13T15:30:00+08:00","dateModified":"2025-12-13T15:30:00+08:00","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/openspec%E6%96%B0%E4%BA%BA%E6%89%8B%E5%86%8C/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">openspec新人手册</h1><div class=post-meta><span title='2025-12-13 15:30:00 +0800 +0800'>December 13, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h1 id=openspec新人手册>openspec新人手册<a hidden class=anchor aria-hidden=true href=#openspec新人手册>#</a></h1><h2 id=为什么选择-openspec>为什么选择 OpenSpec？<a hidden class=anchor aria-hidden=true href=#为什么选择-openspec>#</a></h2><p>AI 编码助手功能强大，但如果需求记录在聊天记录中，其表现就难以预测。OpenSpec 提供了一种轻量级的规范工作流程，在实现之前锁定意图，从而提供确定性且可审查的输出。</p><h3 id=主要成果>主要成果：<a hidden class=anchor aria-hidden=true href=#主要成果>#</a></h3><ul><li>在工作开始前，人类和人工智能相关人员需就技术规范达成一致。</li><li>结构化的变更文件夹（提案、任务和规范更新）使范围明确且可审计。</li><li>共享对已提议、正在进行或已存档内容的可见性。</li><li>可与您已使用的 AI 工具配合使用：在支持自定义斜杠命令的地方使用自定义斜杠命令，在其他所有地方使用上下文规则。</li></ul><h2 id=openspec-的对比概览>OpenSpec 的对比（概览）<a hidden class=anchor aria-hidden=true href=#openspec-的对比概览>#</a></h2><ul><li>轻量级：工作流程简单，无需 API 密钥，设置极少。</li><li>先进行现有功能移植：在 0→1 之后也能很好地工作。OpenSpec 将真实数据源与提案分开：@0#（当前真实数据源）和 @1#（提案更新）。这使得不同功能之间的差异清晰明了且易于管理。</li><li>变更跟踪：提案、任务和规范增量放在一起；归档会将已批准的更新合并回规范中。</li><li>与 spec-kit 和 Kiro 相比：它们在全新特性（0→1）方面表现出色。OpenSpec 在修改现有行为（1→n）方面也同样优秀，尤其是在更新涉及多个规范时。</li></ul><h2 id=工作原理>工作原理<a hidden class=anchor aria-hidden=true href=#工作原理>#</a></h2><pre tabindex=0><code>┌──────────────────────────────┐
│  1. 意图“翻译” (Draft)        │
│  (把“人话”变成“技术文档”)       │
└──────────────┬───────────────┘
               │  你的原始需求：&#34;给网页加个夜间模式&#34;
               ▼
┌──────────────────────────────┐
│  2. 签订“施工合同” (Review)   │◀───[ 拒绝无效返工 ]───┐
│  (锁定修改范围，禁止AI乱动)     │                      │
└──────────────┬───────────────┘                      │
               │  你点头确认：&#34;就改这3个文件，别的别动&#34;     │
               ▼                                      │
┌──────────────────────────────┐                      │
│  3. 傻瓜式执行 (Implement)    │ 🚧 发现逻辑漏洞？      │
│  (AI 闭嘴干活，只写代码)       │ 🛑 停！回去改文档！────┘
└──────────────┬───────────────┘
               │  代码跑通，测试通过
               ▼
┌──────────────────────────────┐
│  4. 更新“项目宪法” (Archive)  │
│  (让项目永远保持最新状态)       │
└──────────────────────────────┘
</code></pre><p>我把这个流程分成了四个更有深度的阶段，咱们一个个来看：</p><h4 id=第一阶段意图翻译-the-translation>第一阶段：意图“翻译” (The Translation)<a hidden class=anchor aria-hidden=true href=#第一阶段意图翻译-the-translation>#</a></h4><ul><li><strong>原来叫：</strong> Draft Change Proposal</li><li><strong>白话理解：</strong> <strong>“拒绝口头支票”</strong><ul><li>你在聊天框里跟 AI 说得再天花乱坠，那都是“口头支票”，AI 转头就忘。</li><li>这一步的核心在于<strong>固化</strong>。OpenSpec 逼着 AI 把它脑子里的想法写成 Markdown 文档。</li><li><strong>心法：</strong> <em>所有的需求，必须先落实在纸面上，才能开始动工。</em></li></ul></li></ul><h4 id=第二阶段签订施工合同-the-contract>第二阶段：签订“施工合同” (The Contract)<a hidden class=anchor aria-hidden=true href=#第二阶段签订施工合同-the-contract>#</a></h4><ul><li><strong>原来叫：</strong> Review & Align</li><li><strong>白话理解：</strong> <strong>“画圈圈，立规矩”</strong><ul><li>这是整个流程里<strong>你权力最大</strong>的时候。</li><li>OpenSpec 会生成一个 spec.md（规格书）。这就像一份合同，规定了 AI <strong>能动哪里，不能动哪里</strong>。</li><li>这一步是为了解决 AI “胡乱发挥”的毛病。如果没有这份合同，AI 可能会为了修个水龙头把整栋楼拆了。</li><li><strong>心法：</strong> <em>文档没改对，一行代码都不许写。</em></li></ul></li></ul><h4 id=第三阶段傻瓜式执行-the-execution>第三阶段：傻瓜式执行 (The Execution)<a hidden class=anchor aria-hidden=true href=#第三阶段傻瓜式执行-the-execution>#</a></h4><ul><li><strong>原来叫：</strong> Implement Tasks</li><li><strong>白话理解：</strong> <strong>“带着镣铐跳舞”</strong><ul><li>注意看右边那个<strong>回流箭头</strong>（拒绝无效返工）。</li><li>传统的 AI 编程是：写错了 -> 手动改代码 -> 再跑 -> 又错了。这是恶性循环。</li><li>OpenSpec 的逻辑是：如果 AI 发现代码写不下去，说明<strong>刚才的合同（文档）有漏洞</strong>。</li><li>这时候<strong>严禁</strong>硬写！必须<strong>退回第二阶段</strong>，把文档改清楚了，再重新执行。</li><li><strong>心法：</strong> <em>修 bug 先修文档，治标更要治本。</em></li></ul></li></ul><h4 id=第四阶段更新项目宪法-the-constitution>第四阶段：更新“项目宪法” (The Constitution)<a hidden class=anchor aria-hidden=true href=#第四阶段更新项目宪法-the-constitution>#</a></h4><ul><li><strong>原来叫：</strong> Archive & Update Specs</li><li><strong>白话理解：</strong> <strong>“刷新记忆库”</strong><ul><li>很多项目做久了，AI 就不认识了，因为代码变了，但文档没变。</li><li>OpenSpec 的“归档”动作，就是把刚才这次修改，合并到项目的总说明书（Source of Truth）里。</li><li>这样，下一次你再让 AI 干活时，它看到的是一个<strong>完全与时俱进</strong>的项目描述，而不是一个月前的旧版本。</li><li><strong>心法：</strong> <em>铁打的文档，流水的代码。文档才是项目的灵魂。</em></li></ul></li></ul><h2 id=核心命令使用claude-code>核心命令使用(claude-code)<a hidden class=anchor aria-hidden=true href=#核心命令使用claude-code>#</a></h2><h3 id=一棒openspecproposal-发起提案>一棒：/openspec:proposal (发起提案)<a hidden class=anchor aria-hidden=true href=#一棒openspecproposal-发起提案>#</a></h3><p><strong>🧐 它的作用：</strong>
告诉 AI：“我有新想法了，别急着写代码，先给我出个方案。”
这是**“立项”**命令。</p><p><strong>📝 语法格式：</strong>
/openspec:proposal &lt;你想做什么></p><p><strong>🎬 实战演示：</strong>
在你的 Claude Code 或 Cursor 聊天框里输入：</p><pre tabindex=0><code>/openspec:proposal 在首页底部增加一个“联系我们”的表单，包含姓名、邮箱和留言三个输入框。
</code></pre><p><strong>⚙️ 发生什么了？</strong>
AI <strong>不会</strong>修改你的 index.html 或 app.js。
它会在后台悄悄创建一个文件夹（比如 openspec/changes/add-contact-form/），并在里面生成三个文件：</p><ol><li>proposal.md：写着为什么要加表单。</li><li>tasks.md：写着第一步改 HTML，第二步写 CSS，第三步写 JS 验证。</li><li>spec.md：写着表单的具体字段要求。</li></ol><p><strong>点评：</strong>
这一步是<strong>安全网</strong>。这时候后悔还来得及，反正代码还没动。</p><h3 id=中间插曲人工审核>(中间插曲：人工审核)<a hidden class=anchor aria-hidden=true href=#中间插曲人工审核>#</a></h3><p><em>这一步虽然没有命令，但必不可少。你看一眼 AI 生成的文档，如果不满意，就用自然语言让它改。</em></p><hr><h3 id=第二棒openspecapply-执行施工>第二棒：/openspec:apply (执行施工)<a hidden class=anchor aria-hidden=true href=#第二棒openspecapply-执行施工>#</a></h3><p><strong>🧐 它的作用：</strong>
告诉 AI：“方案我看过了，没问题，<strong>动手写代码吧！</strong>”
这是**“落地”**命令。</p><p><strong>📝 语法格式：</strong>
/openspec:apply &lt;提案名称>
<em>(注：通常 AI 知道你在聊哪个提案，所以有时直接输 /openspec:apply 也可以，但加上名字最保险)</em></p><p><strong>🎬 实战演示：</strong>
你觉得方案 OK 了，输入：</p><pre tabindex=0><code>/openspec:apply add-contact-form
</code></pre><p><em>(注：add-contact-form 是 AI 刚才生成的文件夹名字，你不用死记，AI 通常会提示你，或者你直接说“apply the current proposal”也行)</em></p><p><strong>⚙️ 发生什么了？</strong>
这次 AI <strong>动真格的了</strong>。
它会读取 tasks.md，然后像个疯狂的打字员一样：</p><ol><li>打开 index.html，插入<form>&mldr;</form>代码。</li><li>打开 style.css，加上表单的样式。</li><li>每做完一步，就在 tasks.md 里打个 ✅。</li></ol><p><strong>点评：</strong>
这是最爽的一步。你喝着咖啡，看着屏幕上的代码自动生成。</p><hr><h3 id=中间插曲验收测试>(中间插曲：验收测试)<a hidden class=anchor aria-hidden=true href=#中间插曲验收测试>#</a></h3><p><em>你去网页上点一点那个表单，看看能不能用。如果不能用，别急着归档，先修 Bug。</em></p><h3 id=第三棒openspecarchive-归档入库>第三棒：/openspec:archive (归档入库)<a hidden class=anchor aria-hidden=true href=#第三棒openspecarchive-归档入库>#</a></h3><p><strong>🧐 它的作用：</strong>
告诉 AI：“活儿干得漂亮，<strong>结账收工</strong>，把这段记忆存进大脑。”
这是**“更新记忆”**命令。</p><p><strong>📝 语法格式：</strong>
/openspec:archive &lt;提案名称></p><p><strong>🎬 实战演示：</strong>
测试没问题了，输入：</p><pre tabindex=0><code>/openspec:archive add-contact-form
</code></pre><p><strong>⚙️ 发生什么了？</strong></p><ol><li><strong>合并记忆：</strong> OpenSpec 会把这次新增的“表单功能说明”合并到项目的总文档 openspec/project.md 里。以后 AI 就知道这个项目有联系表单了。</li><li><strong>清理现场：</strong> openspec/changes/add-contact-form/ 这个临时文件夹会被移走（移到 archive 目录），保证工作区干干净净。</li></ol><p><strong>点评：</strong>
如果不做这一步，你的项目文件夹里会堆满临时的提案垃圾，而且 AI 以后可能会忘掉它做过这个功能。</p><hr><p>把这张小纸条存下来，以后忘了就看一眼：</p><table><thead><tr><th>命令</th><th>英文原意</th><th>中文大白话</th><th>什么时候用？</th></tr></thead><tbody><tr><td><strong>/openspec:proposal</strong></td><td>Proposal (提案)</td><td><strong>“给我出个方案”</strong></td><td>刚开始有想法，还没写代码时</td></tr><tr><td><strong>/openspec:apply</strong></td><td>Apply (应用)</td><td><strong>“照方案干活”</strong></td><td>方案审核通过，准备写代码时</td></tr><tr><td><strong>/openspec:archive</strong></td><td>Archive (归档)</td><td><strong>“完工入库”</strong></td><td>代码测试通过，准备做下一个功能时</td></tr></tbody></table><hr><h2 id=大白话解释>大白话解释<a hidden class=anchor aria-hidden=true href=#大白话解释>#</a></h2><h3 id=第一部分openspec-是干嘛的大白话定义>第一部分：OpenSpec 是干嘛的？（大白话定义）<a hidden class=anchor aria-hidden=true href=#第一部分openspec-是干嘛的大白话定义>#</a></h3><p>想象一下，你是一个<strong>装修队的工头</strong>（人类），你雇了一个<strong>干活巨快但记性不太好、而且特别喜欢“自我发挥”的工人</strong>（AI大模型）。</p><p><strong>没有 OpenSpec 之前：</strong>
你跟工人说：“给我把这面墙刷得好看点。”
工人（AI）直接上手就干，刷成了粉色。
你急了：“不对，我要的是工业风的水泥灰！”
工人：“哦哦好的。”然后把粉色铲了，又刷了一遍灰的，但把窗框也刷灰了。
你又急了：“窗框别动啊！”
<strong>结果：</strong> 浪费了油漆（Token费），浪费了时间，最后出来的东西还未必是你想要的。这就叫“<strong>Vibe Coding</strong>”（凭感觉编程）。</p><p><strong>有了 OpenSpec 之后：</strong>
你不需要直接喊工人干活。你先用 OpenSpec 写一张**“施工图纸”**（Spec）。</p><ol><li>你告诉 OpenSpec：“我要弄这面墙。”</li><li>OpenSpec 帮你生成一份文档：<em>“目标：刷墙。颜色：水泥灰 #808080。范围：只刷墙面，不碰窗框。验收标准：平整无气泡。”</em></li><li>你检查一下文档，说：“对，就是这样。”</li><li>然后把这份文档甩给工人（AI）：“照着这个干，不许自由发挥。”
<strong>结果：</strong> 工人一次性把活干完，完全符合要求。</li></ol><p><strong>总结：</strong>
<strong>OpenSpec 就是一个用来给 AI 立“规矩”和写“说明书”的工具。</strong> 它强迫你在 AI 写代码之前，先和 AI 确认好“我们要干什么”，从而避免 AI 写出垃圾代码或错误代码。</p><h3 id=第二部分它解决了什么痛点>第二部分：它解决了什么痛点？<a hidden class=anchor aria-hidden=true href=#第二部分它解决了什么痛点>#</a></h3><p>在目前的大模型编程（比如用 Cursor, GitHub Copilot, Claude）中，主要有这三个痛点，OpenSpec 都能解决：</p><ol><li><strong>AI 的“失忆症”：</strong>
你在对话框里聊了50句，AI 可能就忘了第1句你要求的“按钮要是圆角的”。
<em>OpenSpec 解决：</em> 它把要求写在文件里，永久保存，AI 随时都能看到。</li><li><strong>AI 的“胡乱发挥”：</strong>
你让它加个功能，它可能顺手把你之前的逻辑改坏了。
<em>OpenSpec 解决：</em> 通过“提案（Proposal）”机制，锁定了修改范围，AI 只能动你允许它动的地方。</li><li><strong>沟通成本高（费钱）：</strong>
反反复复修改代码非常消耗 Token（钱）。
<em>OpenSpec 解决：</em> 先修改文档，文档改对了再写代码，一次成型，省钱。</li></ol><h3 id=第三部分它的工作原理设计与使用>第三部分：它的工作原理（设计与使用）<a hidden class=anchor aria-hidden=true href=#第三部分它的工作原理设计与使用>#</a></h3><p>OpenSpec 不需要你懂什么复杂的底层算法，它其实就是一套**“文件管理流程”**。</p><h4 id=1-设计原理markdown-为王>1. 设计原理：Markdown 为王<a hidden class=anchor aria-hidden=true href=#1-设计原理markdown-为王>#</a></h4><p>它不依赖任何 API Key（不直接调大模型），它只是生成一堆 .md (Markdown) 格式的文档。因为大模型最擅长读懂 Markdown。它把你的项目分成了两个状态：</p><ul><li><strong>现状（Source of Truth）：</strong> 项目现在是什么样子的？</li><li><strong>变更（Change Proposal）：</strong> 我们打算把项目改成什么样子？</li></ul><h4 id=2-使用原理核心三步走>2. 使用原理（核心三步走）<a hidden class=anchor aria-hidden=true href=#2-使用原理核心三步走>#</a></h4><p>OpenSpec 创造了一个标准的“工作流”：</p><ul><li><strong>第一步：起草 (Draft)</strong>
你告诉 AI：“我想加个夜间模式”。OpenSpec 会让 AI 生成一份 proposal.md（提案），里面写清楚了为什么要加、怎么加、涉及哪些文件。</li><li><strong>第二步：审核 (Review)</strong>
你看一眼提案。如果觉得 AI 理解错了，直接改文档，或者让 AI 重写文档。这时候一行代码都还没写呢，改起来成本极低。</li><li><strong>第三步：执行 (Apply)</strong>
你点头同意后，AI 读取这个提案，开始写代码。写完后，OpenSpec 会把这次变动“归档”，更新项目的整体说明书。</li></ul><p>你好！我是人工智能应用方面的专家，很高兴能作为你的“老师”来为你深度剖析 <strong>OpenSpec</strong> 这个技术。</p><p>你发给我的链接指向的是 <strong>Fission-AI</strong> 开发的 <strong>OpenSpec</strong> 项目。别被满屏的代码吓到了，这个工具的核心逻辑非常简单，但它解决了一个目前大模型编程（AI Coding）中最让人头疼的问题。</p><p>为了让你彻底明白，我们不讲晦涩的术语，我把整个概念“嚼碎”了讲给你听。</p><hr><h3 id=第一部分openspec-是干嘛的大白话定义-1>第一部分：OpenSpec 是干嘛的？（大白话定义）<a hidden class=anchor aria-hidden=true href=#第一部分openspec-是干嘛的大白话定义-1>#</a></h3><p>想象一下，你是一个<strong>装修队的工头</strong>（人类），你雇了一个<strong>干活巨快但记性不太好、而且特别喜欢“自我发挥”的工人</strong>（AI大模型）。</p><p><strong>没有 OpenSpec 之前：</strong>
你跟工人说：“给我把这面墙刷得好看点。”
工人（AI）直接上手就干，刷成了粉色。
你急了：“不对，我要的是工业风的水泥灰！”
工人：“哦哦好的。”然后把粉色铲了，又刷了一遍灰的，但把窗框也刷灰了。
你又急了：“窗框别动啊！”
<strong>结果：</strong> 浪费了油漆（Token费），浪费了时间，最后出来的东西还未必是你想要的。这就叫“<strong>Vibe Coding</strong>”（凭感觉编程）。</p><p><strong>有了 OpenSpec 之后：</strong>
你不需要直接喊工人干活。你先用 OpenSpec 写一张**“施工图纸”**（Spec）。[<a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQH0YkOFTwYUdHOP13RT8aW_V1sE2sgt1cxzy_H00lmAMRBedgJ8ALuXbEvLnqHMliZxqKbTNDIDsML5XhUeb_s9AbnDYLRt50lzWTI2htgPZJnmO4NLVUdwyRuhqWaUEMNjxdU-QcawG6JwRMi_8ZJimNzLTXQMq9411e1ogo5pTPrmKkFblizbBKtHKA3pxPKfcRIrYxQE3n_RdFcXKRRdRdYkjGOXY3_yg0i7Vi3cCnZNXg%3D%3D">1</a>]</p><ol><li></li><li>你告诉 OpenSpec：“我要弄这面墙。”</li><li>OpenSpec 帮你生成一份文档：<em>“目标：刷墙。颜色：水泥灰 #808080。范围：只刷墙面，不碰窗框。验收标准：平整无气泡。”</em></li><li>你检查一下文档，说：“对，就是这样。”</li><li>然后把这份文档甩给工人（AI）：“照着这个干，不许自由发挥。”
<strong>结果：</strong> 工人一次性把活干完，完全符合要求。</li></ol><p><strong>总结：</strong>
<strong>OpenSpec 就是一个用来给 AI 立“规矩”和写“说明书”的工具。</strong> 它强迫你在 AI 写代码之前，先和 AI 确认好“我们要干什么”，从而避免 AI 写出垃圾代码或错误代码。[<a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHhbZy90omoS8MFAGrCKp1tcFD7Ot2gy8wLauRfC49gnMg87SeTCzt7RA2930xvT3U5phvLDKL8qnnR6ytLAWPqYAyHafC8MIPw6NhFHcUeQiqRESiScLk9WTMPgKc1bfMy5Rua-VY%3D">2</a>]</p><hr><h3 id=第二部分它解决了什么痛点-1>第二部分：它解决了什么痛点？<a hidden class=anchor aria-hidden=true href=#第二部分它解决了什么痛点-1>#</a></h3><p>在目前的大模型编程（比如用 Cursor, GitHub Copilot, Claude）中，主要有这三个痛点，OpenSpec 都能解决：</p><ol><li><strong>AI 的“失忆症”：</strong>
你在对话框里聊了50句，AI 可能就忘了第1句你要求的“按钮要是圆角的”。
<em>OpenSpec 解决：</em> 它把要求写在文件里，永久保存，AI 随时都能看到。</li><li><strong>AI 的“胡乱发挥”：</strong>
你让它加个功能，它可能顺手把你之前的逻辑改坏了。
<em>OpenSpec 解决：</em> 通过“提案（Proposal）”机制，锁定了修改范围，AI 只能动你允许它动的地方。</li><li><strong>沟通成本高（费钱）：</strong>
反反复复修改代码非常消耗 Token（钱）。
<em>OpenSpec 解决：</em> 先修改文档，文档改对了再写代码，一次成型，省钱。</li></ol><hr><h3 id=第三部分它的工作原理设计与使用-1>第三部分：它的工作原理（设计与使用）<a hidden class=anchor aria-hidden=true href=#第三部分它的工作原理设计与使用-1>#</a></h3><p>OpenSpec 不需要你懂什么复杂的底层算法，它其实就是一套**“文件管理流程”**。</p><h4 id=1-设计原理markdown-为王-1>1. 设计原理：Markdown 为王<a hidden class=anchor aria-hidden=true href=#1-设计原理markdown-为王-1>#</a></h4><p>它不依赖任何 API Key（不直接调大模型），它只是生成一堆 .md (Markdown) 格式的文档。因为大模型最擅长读懂 Markdown。它把你的项目分成了两个状态：</p><ul><li></li><li><strong>现状（Source of Truth）：</strong> 项目现在是什么样子的？</li><li><strong>变更（Change Proposal）：</strong> 我们打算把项目改成什么样子？</li></ul><h4 id=2-使用原理核心三步走-1>2. 使用原理（核心三步走）<a hidden class=anchor aria-hidden=true href=#2-使用原理核心三步走-1>#</a></h4><p>OpenSpec 创造了一个标准的“工作流”：</p><ul><li></li><li><strong>第一步：起草 (Draft)</strong>
你告诉 AI：“我想加个夜间模式”。OpenSpec 会让 AI 生成一份 proposal.md（提案），里面写清楚了为什么要加、怎么加、涉及哪些文件。</li><li><strong>第二步：审核 (Review)</strong>
你看一眼提案。如果觉得 AI 理解错了，直接改文档，或者让 AI 重写文档。这时候一行代码都还没写呢，改起来成本极低。</li><li><strong>第三步：执行 (Apply)</strong>
你点头同意后，AI 读取这个提案，开始写代码。写完后，OpenSpec 会把这次变动“归档”，更新项目的整体说明书。</li></ul><hr><h3 id=第四部分安装和使用>第四部分：安装和使用<a hidden class=anchor aria-hidden=true href=#第四部分安装和使用>#</a></h3><p>假设你现在有一个项目（或者新建一个空文件夹），我们来实操一下。</p><h4 id=1-安装前的准备>1. 安装前的准备<a hidden class=anchor aria-hidden=true href=#1-安装前的准备>#</a></h4><p>你需要电脑上有 Node.js 环境（版本最好在 20 以上）。</p><ul><li><p>打开终端（命令行），输入：</p><pre tabindex=0><code>node -v
</code></pre><p>如果有版本号蹦出来，说明环境OK。</p></li></ul><h4 id=2-安装-openspec>2. 安装 OpenSpec<a hidden class=anchor aria-hidden=true href=#2-安装-openspec>#</a></h4><p>在终端输入这行命令，把它安装到你电脑的全局环境中：</p><pre tabindex=0><code>npm install -g @fission-ai/openspec@latest
</code></pre><h4 id=3-开始使用初始化>3. 开始使用（初始化）<a hidden class=anchor aria-hidden=true href=#3-开始使用初始化>#</a></h4><p>进入你的项目文件夹：</p><pre tabindex=0><code>cd my-project
</code></pre><p>初始化 OpenSpec：</p><pre tabindex=0><code>openspec init
</code></pre><p>这时候它会问你：“你在用什么 AI 工具？”（比如 Claude Code, Cursor, Copilot 等）。选你正在用的那个。
完成后，你会发现项目里多了一个 openspec/ 文件夹，里面有个 project.md，这里面就是你项目的“户口本”（项目简介、技术栈等）。</p><h4 id=4-实战案例给网页加个重置按钮>4. 实战案例：给网页加个“重置”按钮<a hidden class=anchor aria-hidden=true href=#4-实战案例给网页加个重置按钮>#</a></h4><p>假设你在做一个网页，现在想加个按钮。</p><p><strong>Step 1: 告诉 AI 你的想法</strong>
在你的 AI 聊天窗口（比如 Cursor 的 Chat）里，输入：</p><blockquote><p>“帮我创建一个 OpenSpec 提案：在首页添加一个重置按钮，点击后清空所有输入框。”</p></blockquote><p><strong>Step 2: AI 生成“施工图”</strong>
AI 会调用 OpenSpec，在 openspec/changes/ 目录下生成一个文件夹，里面有：</p><ul><li>proposal.md：写了我们要加按钮。</li><li>tasks.md：写了具体步骤（1. 改HTML，2. 改CSS，3. 改JS）。</li><li>spec.md：详细的技术规格。</li></ul><p><strong>Step 3: 你来当监工</strong>
打开 proposal.md 看看。</p><ul><li>你发现 AI 忘了说按钮颜色。</li><li>你直接对 AI 说：“在 Spec 里补充一下，按钮必须是红色的。”</li><li>AI 更新文档。</li></ul><p><strong>Step 4: 动手施工</strong>
文档确认无误后，你输入指令（或告诉 AI）：</p><blockquote><p>“执行这个 OpenSpec 提案。” (通常命令是 /openspec apply)</p></blockquote><p>AI 就会严格按照 tasks.md 里的步骤，一步步把代码写好。</p><p><strong>Step 5: 完工归档</strong>
测试按钮没问题了，告诉 AI：</p><blockquote><p>“归档这个提案。”(命令 /openspec archive)</p></blockquote><p>OpenSpec 会把这次修改记录下来，以后 AI 再看你的项目，就知道“哦，这有个红色的重置按钮”。</p><h3 id=第五部分如何提高使用效率>第五部分：如何提高使用效率？<a hidden class=anchor aria-hidden=true href=#第五部分如何提高使用效率>#</a></h3><ol><li><strong>善用 project.md：</strong>
这是 OpenSpec 的核心大脑。把你项目的**“家规”**写进去。比如：“所有变量必须用驼峰命名”、“必须写注释”、“不许使用 jQuery”。这样 AI 以后生成的每一个提案都会遵守这些家规。</li><li><strong>不要在 Chat 里长篇大论：</strong>
以后不要在聊天框里写几百字的 Prompt 了。把复杂的逻辑让 AI 先生成 Proposal，你在文档里改。<strong>改文档比改代码容易一万倍。</strong></li><li><strong>小步快跑：</strong>
不要一个提案里包含“重构整个系统”。一个提案做一个功能（比如“加按钮”是一个提案，“修Bug”是另一个）。这样不容易出错。</li></ol><h2 id=官方案例>官方案例<a hidden class=anchor aria-hidden=true href=#官方案例>#</a></h2><h3 id=1-起草提案-draft-the-proposal>1. 起草提案 (Draft the Proposal)<a hidden class=anchor aria-hidden=true href=#1-起草提案-draft-the-proposal>#</a></h3><p>首先，让你的 AI 创建一个变更提案。</p><pre tabindex=0><code>你 (User): 创建一个 OpenSpec 变更提案：添加基于角色和团队的个人资料搜索过滤器。
           (对于支持斜杠命令的工具如 Claude Code，可以使用快捷键: /openspec:proposal 添加个人资料搜索过滤器)

AI:好的，我将为个人资料过滤器创建一个 OpenSpec 变更提案。
正在搭建脚手架目录 openspec/changes/add-profile-filters/，包含 proposal.md, tasks.md, spec deltas（规格变更量）。
</code></pre><h4 id=-深度解析>🧑‍🏫 深度解析<a hidden class=anchor aria-hidden=true href=#-深度解析>#</a></h4><ul><li><strong>这一步做了什么：</strong>
这是项目的**“立项”**阶段。你只是动了动嘴（或者敲了一行命令），OpenSpec 就不仅听懂了，还帮你创建了一个专属的文件夹。它把你脑子里模糊的想法，变成了三个实实在在的文件（提案、任务清单、规格变更）。</li><li><strong>目的是什么：</strong>
<strong>拒绝口头支票</strong>。把需求“物理化”，防止 AI 听完就忘，或者理解偏差。</li><li><strong>接下去将展开：</strong>
现在只是有了“草稿”，但草稿对不对呢？我们需要进入下一步——<strong>检查</strong>。</li></ul><hr><h3 id=2-验证与审查-verify--review>2. 验证与审查 (Verify & Review)<a hidden class=anchor aria-hidden=true href=#2-验证与审查-verify--review>#</a></h3><p>检查变更是否正确创建，并审查提案内容。</p><pre tabindex=0><code>$ openspec list                             # 确认变更文件夹是否已存在（查看当前有哪些正在进行的提案）
$ openspec validate add-profile-filters     # 验证 spec 的格式是否正确（确保没有语法错误）
$ openspec show add-profile-filters         # 查看提案、任务清单和规格变更的详细内容（这是给你人工审核用的）
</code></pre><h4 id=-深度解析-1>🧑‍🏫 深度解析<a hidden class=anchor aria-hidden=true href=#-深度解析-1>#</a></h4><ul><li><strong>这一步做了什么：</strong>
这是**“安检”**阶段。在你还没开始真正干活之前，先用这三个命令确认一下：文件夹建好了没？格式对不对？内容是不是我想要的？</li><li><strong>目的是什么：</strong>
<strong>排雷</strong>。如果格式有错（validate 报错），或者 AI 理解反了（show 显示的内容不对），现在发现只需要改改文档。要是等到写代码时才发现，成本就高了。</li><li><strong>接下去将展开：</strong>
通常你看完 openspec show 的内容后，会发现 AI 的理解可能还不够完美，或者漏了点细节。所以下一步是——<strong>修改和完善</strong>。</li></ul><hr><h3 id=3-完善规格说明-refine-the-specs>3. 完善规格说明 (Refine the Specs)<a hidden class=anchor aria-hidden=true href=#3-完善规格说明-refine-the-specs>#</a></h3><p>反复迭代规格说明，直到它们符合你的需求。</p><pre tabindex=0><code>你 (User): 你能为角色和团队过滤器添加验收标准吗？（比如：必须能多选，或者搜不到时显示什么）

AI: 好的，我将更新规格变更，增加角色和团队过滤器的场景描述。
   *正在编辑 openspec/changes/add-profile-filters/specs/profile/spec.md 和 tasks.md 文件。*
</code></pre><h4 id=-深度解析-2>🧑‍🏫 深度解析<a hidden class=anchor aria-hidden=true href=#-深度解析-2>#</a></h4><ul><li><strong>这一步做了什么：</strong>
这是**“讨价还价”**阶段，也是 OpenSpec 最核心的价值所在。你发现 AI 漏了“验收标准”，于是你指出来，AI 乖乖回去改文档（而不是改代码）。</li><li><strong>目的是什么：</strong>
<strong>精准对齐</strong>。通过修改 Markdown 文档，把你脑子里的细节 100% 复制到 AI 的脑子里。在这个阶段，改文档几乎是零成本的。</li><li><strong>接下去将展开：</strong>
当你觉得文档已经完美无缺，没有任何漏洞了，就可以下令进入最激动人心的环节——<strong>执行</strong>。</li></ul><hr><h3 id=4-执行变更-implement-the-change>4. 执行变更 (Implement the Change)<a hidden class=anchor aria-hidden=true href=#4-执行变更-implement-the-change>#</a></h3><p>一旦规格说明看起来没问题了，就开始实施。</p><pre tabindex=0><code>你 (User): 规格说明看起来不错。我们要开始实施这个变更了。
           (对于支持斜杠命令的工具，快捷键: /openspec:apply add-profile-filters)

AI: 好的，我将开始处理 add-profile-filters 变更中的任务。
    *正在根据 openspec/changes/add-profile-filters/tasks.md 中的步骤实施代码修改*
    *标记任务完成: 任务 1.1 ✓, 任务 1.2 ✓, 任务 2.1 ✓...*
</code></pre><h4 id=-深度解析-3>🧑‍🏫 深度解析<a hidden class=anchor aria-hidden=true href=#-深度解析-3>#</a></h4><ul><li><strong>这一步做了什么：</strong>
这是**“自动驾驶”**阶段。你发令枪一响，AI 就变身成了一个没有感情的编码机器。它读取刚才那份被你确认过的 tasks.md，一步一步地去修改你的源代码文件。</li><li><strong>目的是什么：</strong>
<strong>落地变现</strong>。把纸面上的文档变成能跑的代码。注意，因为前一步你已经把文档审得很细了，所以这一步通常是一次过的，极少出错。</li><li><strong>接下去将展开：</strong>
代码写完了，任务也都打钩了（✓）。这时候你的项目里多了一堆新代码，和一堆用过的 OpenSpec 临时文件。我们需要——<strong>收尾</strong>。</li></ul><hr><h3 id=5-归档已完成的变更-archive-the-completed-change>5. 归档已完成的变更 (Archive the Completed Change)<a hidden class=anchor aria-hidden=true href=#5-归档已完成的变更-archive-the-completed-change>#</a></h3><p>实施完成后，对变更进行归档。</p><pre tabindex=0><code>AI:所有任务已完成。实施工作已就绪。

你 (User): 请归档这个变更。
           (对于支持斜杠命令的工具，快捷键: /openspec:archive add-profile-filters)

AI:好的，我将归档 add-profile-filters 这个变更。
   *后台运行命令: openspec archive add-profile-filters --yes*
   ✓ 变更归档成功。规格说明已更新。准备好开发下一个功能了！
</code></pre><p>或者你可以自己在终端里运行命令：</p><pre tabindex=0><code>$ openspec archive add-profile-filters --yes  # 归档已完成的变更，且不进行交互式提示（直接确定）
</code></pre><p><strong>注意：</strong> 那些原生支持斜杠命令的工具（如 Claude Code, CodeBuddy, Cursor, Codex, Qoder, RooCode）可以使用上面展示的快捷键。其他工具则使用自然语言请求，比如直接说“创建一个 OpenSpec 提案”、“应用 OpenSpec 变更”或“归档变更”。</p><h4 id=-深度解析-4>🧑‍🏫 深度解析<a hidden class=anchor aria-hidden=true href=#-深度解析-4>#</a></h4><ul><li><strong>这一步做了什么：</strong>
这是**“入库”**阶段。OpenSpec 会把刚才那个临时文件夹里的精华（新的规格说明）合并到项目的总文档里，然后把临时文件夹移走。</li><li><strong>目的是什么：</strong>
<strong>更新记忆</strong>。这一次的修改变成了项目历史的一部分。下次你再让 AI 改别的东西时，它就知道：“哦，这个项目已经有搜索过滤器了”。</li><li><strong>接下去将展开：</strong>
这一个轮回结束了。你可以喝杯咖啡，准备开始下一个轮回（回到第1步 Draft）。</li></ul><hr><h3 id=命令参考手册-command-reference>命令参考手册 (Command Reference)<a hidden class=anchor aria-hidden=true href=#命令参考手册-command-reference>#</a></h3><pre tabindex=0><code>openspec list               # 查看当前活跃的变更文件夹（看看有哪些活儿还没干完）
openspec view               # 启动一个交互式的仪表盘，可视化查看规格和变更（不用对着黑乎乎的终端看）
openspec show &lt;change&gt;      # 显示某个变更的详情（包括提案、任务列表、规格更新内容）
openspec validate &lt;change&gt;  # 检查规格说明的格式和结构是否标准（语法检查）
openspec archive &lt;change&gt; [--yes|-y]   # 将已完成的变更移动到 archive/ 目录（加上 --yes 表示不需要我再确认，直接移）
</code></pre><hr><h3 id=示例ai-是如何创建-openspec-文件的>示例：AI 是如何创建 OpenSpec 文件的<a hidden class=anchor aria-hidden=true href=#示例ai-是如何创建-openspec-文件的>#</a></h3><p>当你要求你的 AI 助手“添加双因素认证（2FA）”时，它会创建如下结构：</p><pre tabindex=0><code>openspec/
├── specs/
│   └── auth/
│       └── spec.md           # 当前已有的认证规格说明 (如果项目里本来就有的话)
└── changes/
    └── add-2fa/              # AI 自动创建的整个结构，这就是&#34;提案文件夹&#34;
        ├── proposal.md       # 原因和变更内容 (Why &amp; What)
        ├── tasks.md          # 实施清单 (How - 一步步怎么做)
        ├── design.md         # 技术决策 (可选文件，比如为什么选这个算法)
        └── specs/
            └── auth/
                └── spec.md   # 增量文件，展示了这次要在原基础上“加”什么
</code></pre><h4 id=ai-生成的规格说明-位于-openspecspecsauthspecmd>AI 生成的规格说明 (位于 openspec/specs/auth/spec.md)：<a hidden class=anchor aria-hidden=true href=#ai-生成的规格说明-位于-openspecspecsauthspecmd>#</a></h4><p><em>这是项目里原本就有的“真理”文件</em></p><pre tabindex=0><code># 认证规格说明 (Auth Specification)

## 目的 (Purpose)
负责认证和会话管理。

## 需求 (Requirements)
### 需求：用户登录
系统必须 (SHALL) 在登录成功后签发一个 JWT 令牌。

#### 场景：凭证有效
- 当 (WHEN) 用户提交有效的凭证
- 那么 (THEN) 返回一个 JWT 令牌
</code></pre><h4 id=ai-生成的变更增量-位于-openspecchangesadd-2fatasksmd-等>AI 生成的变更增量 (位于 openspec/changes/add-2fa/tasks.md 等)：<a hidden class=anchor aria-hidden=true href=#ai-生成的变更增量-位于-openspecchangesadd-2fatasksmd-等>#</a></h4><p><em>这是 AI 打算怎么干活的任务清单</em></p><pre tabindex=0><code>## 1. 数据库设置 (Database Setup)
- [ ] 1.1 在 users 表中添加 OTP 密钥列
- [ ] 1.2 创建 OTP 验证日志表

## 2. 后端实现 (Backend Implementation)
- [ ] 2.1 添加 OTP 生成接口 (Endpoint)
- [ ] 2.2 修改登录流程以要求 OTP
- [ ] 2.3 添加 OTP 验证接口

## 3. 前端更新 (Frontend Updates)
- [ ] 3.1 创建 OTP 输入组件
- [ ] 3.2 更新登录界面的 UI
</code></pre><p><strong>重要提示：</strong> 你不需要手动创建这些文件。你的 AI 助手会根据你的要求和现有的代码库自动生成它们。</p><hr><h3 id=理解-openspec-文件-understanding-openspec-files>理解 OpenSpec 文件 (Understanding OpenSpec Files)<a hidden class=anchor aria-hidden=true href=#理解-openspec-文件-understanding-openspec-files>#</a></h3><h4 id=增量格式-delta-format>增量格式 (Delta Format)<a hidden class=anchor aria-hidden=true href=#增量格式-delta-format>#</a></h4><p>“增量 (Deltas)” 就像是补丁，用来展示规格说明是如何变化的：</p><ul><li><strong>## ADDED Requirements</strong> - 新增的能力（这一块是新加的）</li><li><strong>## MODIFIED Requirements</strong> - 变更的行为（这一块改了，要包含修改后的完整文本）</li><li><strong>## REMOVED Requirements</strong> - 废弃的功能（这一块不要了）</li></ul><p><strong>格式要求：</strong></p><ul><li>使用 ### Requirement: &lt;名称> 作为标题</li><li>每个需求至少需要包含一个 #### Scenario:（场景）块</li><li>在需求文本中必须使用 <strong>SHALL</strong>（必须）/ <strong>MUST</strong>（一定）等关键词（这是 RFC 标准术语，表示强制性）</li></ul><h4 id=-总结>🧑‍🏫 总结<a hidden class=anchor aria-hidden=true href=#-总结>#</a></h4><p>这最后一部分是在教 AI <strong>“怎么写文档”</strong>。
OpenSpec 规定了一种很严谨的格式（类似法律条文）。为什么？
因为<strong>只有格式严谨了，AI 执行起来才不会产生歧义。</strong></p><p>你看，它要求用 SHALL（必须），要求写 Scenario（场景：当&mldr;时，发生&mldr;）。这其实就是把我们平时说的“大白话”翻译成了“机器能听懂的逻辑语言”。</p><p><strong>全课总结：</strong>
这一整套流程，看着步骤多，其实就是为了解决一个核心问题：<strong>消除歧义</strong>。
通过 提案 -> 审核 -> 清单 -> 执行 -> 归档 这五步，你和 AI 之间就建立了一种极其高效、极其精准的合作关系。</p><h2 id=其他补充>其他补充<a hidden class=anchor aria-hidden=true href=#其他补充>#</a></h2><h3 id=需不要把agentsmd复制给ai>需不要把AGENTS.md复制给AI<a hidden class=anchor aria-hidden=true href=#需不要把agentsmd复制给ai>#</a></h3><p><strong>1. 为什么会有“复制”这个动作？</strong></p><p>官方教程里提到的“复制 AGENTS.md”其实是一个<strong>兜底方案（Fallback）</strong>。
它是为了兼容那些不支持自动读取配置的“傻瓜式”聊天界面（比如网页版的 ChatGPT 或 Claude 网页版），因为那些界面不知道你本地有个文件叫 AGENTS.md。</p><p>但在 CLI（命令行）环境下，Claude Code 是有能力直接读取本地文件的。</p><p><strong>2. 如何验证你是否需要复制？（一招辨别）</strong></p><p>打开你的终端，进入项目目录，运行 claude 进入交互模式，然后直接输入斜杠 /：</p><ul><li><strong>测试动作：</strong> 输入 /openspec 然后按 Tab 键（或者看提示）。</li><li><strong>判断标准：</strong><ul><li>✅ <strong>如果你看到了类似 /openspec:proposal、/openspec:apply 这样的命令提示：</strong>
恭喜你！OpenSpec 已经成功“注入”了 Claude Code。<strong>你不需要复制任何东西</strong>。直接下命令，Claude 会自动去后台读取 AGENTS.md 的规则。</li><li>❌ <strong>如果你输入 /openspec 没有任何反应，或者 Claude 说“不认识这个命令”：</strong>
说明自动配置没生效，这时候才需要手动干预（但也不用每次都复制，看下面）。</li></ul></li></ul><p><strong>3. 如果没生效，怎么做“一次性配置”？</strong></p><p>如果上面的测试失败了，不要每次都复制粘贴。我们可以利用 Claude Code 的 CLAUDE.md 机制来做个“永久软链接”。</p><p><strong>“聪明人”的做法：</strong></p><p>在你的项目根目录下，创建一个名为 CLAUDE.md 的文件（如果已有，就编辑它），在里面写上一句话：</p><pre tabindex=0><code># Project Instructions

Please strictly follow the guidelines and workflows defined in ./openspec/AGENTS.md
</code></pre><p><strong>原理：</strong>
Claude Code CLI 启动时，<strong>默认会自动寻找并读取项目根目录下的 CLAUDE.md</strong>。
通过这行字，你相当于告诉 Claude：“兄弟，在这个项目里怎么干活，你去读那个文件，我就不啰嗦了。”</p><h3 id=什么时候需要spec>什么时候需要spec<a hidden class=anchor aria-hidden=true href=#什么时候需要spec>#</a></h3><p>![](Spec vs Vibe Coding-2025-12-14-075511.svg)</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/openspec/>Openspec</a></li><li><a href=http://ljj1992.fun/tags/spec/>Spec</a></li><li><a href=http://ljj1992.fun/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%BC%96%E7%A8%8B/>大模型编程</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>