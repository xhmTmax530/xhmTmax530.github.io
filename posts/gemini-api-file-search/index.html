<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Gemini API File Search | star徐的博客</title><meta name=keywords content="Google,检索增强生成,RAG,人工智能,Gemini API File Search"><meta name=description content="Gemini API File Search
一. 概述

核心功能：它是一个全托管的RAG（检索增强生成）服务。开发者不需要自己搭建向量数据库、不需要自己写代码切分文档、不需要计算Embedding（向量化），直接把文件扔给Google，它就能自动处理好索引和检索。
最大卖点：

极简开发：从原来的“搭建复杂的RAG系统”变成了“几行API代码调用”。
成本极低：视频强调了目前的高性价比，甚至存储和检索在一定额度内免费（具体看下文分析）。
自带引用：回答问题时会自动标注参考了文档的哪一部分，解决了AI胡编乱造的问题。




二、深度问答与分析
Q1: API 托管 RAG 是最新的技术吗？
结论：不是行业首创，但在“性价比”和“生态整合”上是强有力的竞争者。

竞品对比：

OpenAI：早在2023年推出的 Assistants API 中就包含了 file_search（以前叫Retrieval）功能。原理几乎一模一样：上传文件 -> 自动切片 -> 自动检索。
Anthropic (Claude)：目前主要依赖长上下文（Context Window）硬吃文件，或者需要配合第三方库，还没有原生的类似Assistants API这种全托管RAG接口。


Gemini的后发优势：

上下文窗口更大：Gemini 1.5 Pro/Flash 支持百万级token，结合File Search可以处理更复杂的混合场景。
价格策略：OpenAI的向量存储是按GB收费的，而Gemini API目前的策略非常激进（在很多层面上提供了免费的存储额度或极低的索引费），这对开发者吸引力巨大。



Q2: 它和传统RAG、增强性RAG的区别？

  
      
          维度
          传统 RAG (DIY)
          API 托管 RAG (Gemini File Search)
      
  
  
      
          搭建难度
          高。需要自己选向量数据库(Pinecone/Milvus)、自己写切片算法(Chunking)、选Embedding模型。
          极低。黑盒服务，上传文件即可。
      
      
          可控性
          高。你可以精确控制怎么切分段落、用什么检索算法（混合检索/重排序）。
          低。Google帮你决定怎么切、怎么搜，你只能调少量参数。
      
      
          维护成本
          高。需要运维数据库，关注数据更新和一致性。
          零。Google维护。
      
      
          技术归类
          基础架构。
          SaaS化服务 (RAG as a Service)。
      
  


关于增强性RAG (Advanced RAG)：增强性RAG通常指在检索前后加了“预处理（查询重写）”和“后处理（重排序 Rerank）”。Gemini File Search 内部其实已经集成了增强性技术（例如它会自动对检索结果进行相关性排序），只是没暴露给你看。所以它在效果上优于最简陋的传统RAG，但弱于顶级专家精心调优的定制化RAG。

Q3: 能解决什么痛点？

门槛过高：以前想做个“知识库问答”，即使是Demo也要配环境、装库、买数据库服务。现在只要会调API就行。
效果调优难：新手很难搞定“文档切分”和“向量检索”的参数，Google用通用的最佳实践帮你解决了。
幻觉问题：通过强制的**Citation（引用归属）**功能，大大增加了回答的可信度，解决了老板和客户最担心的“AI瞎说”问题。

Q4: 未来方向
是的，绝对是方向。"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/gemini-api-file-search/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/gemini-api-file-search/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/gemini-api-file-search/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="Gemini API File Search"><meta property="og:description" content="Gemini API File Search 一. 概述 核心功能：它是一个全托管的RAG（检索增强生成）服务。开发者不需要自己搭建向量数据库、不需要自己写代码切分文档、不需要计算Embedding（向量化），直接把文件扔给Google，它就能自动处理好索引和检索。 最大卖点： 极简开发：从原来的“搭建复杂的RAG系统”变成了“几行API代码调用”。 成本极低：视频强调了目前的高性价比，甚至存储和检索在一定额度内免费（具体看下文分析）。 自带引用：回答问题时会自动标注参考了文档的哪一部分，解决了AI胡编乱造的问题。 二、深度问答与分析 Q1: API 托管 RAG 是最新的技术吗？ 结论：不是行业首创，但在“性价比”和“生态整合”上是强有力的竞争者。
竞品对比： OpenAI：早在2023年推出的 Assistants API 中就包含了 file_search（以前叫Retrieval）功能。原理几乎一模一样：上传文件 -> 自动切片 -> 自动检索。 Anthropic (Claude)：目前主要依赖长上下文（Context Window）硬吃文件，或者需要配合第三方库，还没有原生的类似Assistants API这种全托管RAG接口。 Gemini的后发优势： 上下文窗口更大：Gemini 1.5 Pro/Flash 支持百万级token，结合File Search可以处理更复杂的混合场景。 价格策略：OpenAI的向量存储是按GB收费的，而Gemini API目前的策略非常激进（在很多层面上提供了免费的存储额度或极低的索引费），这对开发者吸引力巨大。 Q2: 它和传统RAG、增强性RAG的区别？ 维度 传统 RAG (DIY) API 托管 RAG (Gemini File Search) 搭建难度 高。需要自己选向量数据库(Pinecone/Milvus)、自己写切片算法(Chunking)、选Embedding模型。 极低。黑盒服务，上传文件即可。 可控性 高。你可以精确控制怎么切分段落、用什么检索算法（混合检索/重排序）。 低。Google帮你决定怎么切、怎么搜，你只能调少量参数。 维护成本 高。需要运维数据库，关注数据更新和一致性。 零。Google维护。 技术归类 基础架构。 SaaS化服务 (RAG as a Service)。 关于增强性RAG (Advanced RAG)：增强性RAG通常指在检索前后加了“预处理（查询重写）”和“后处理（重排序 Rerank）”。Gemini File Search 内部其实已经集成了增强性技术（例如它会自动对检索结果进行相关性排序），只是没暴露给你看。所以它在效果上优于最简陋的传统RAG，但弱于顶级专家精心调优的定制化RAG。 Q3: 能解决什么痛点？ 门槛过高：以前想做个“知识库问答”，即使是Demo也要配环境、装库、买数据库服务。现在只要会调API就行。 效果调优难：新手很难搞定“文档切分”和“向量检索”的参数，Google用通用的最佳实践帮你解决了。 幻觉问题：通过强制的**Citation（引用归属）**功能，大大增加了回答的可信度，解决了老板和客户最担心的“AI瞎说”问题。 Q4: 未来方向 是的，绝对是方向。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-26T18:00:00+08:00"><meta property="article:modified_time" content="2025-11-26T18:00:00+08:00"><meta property="article:tag" content="Google"><meta property="article:tag" content="检索增强生成"><meta property="article:tag" content="RAG"><meta property="article:tag" content="人工智能"><meta property="article:tag" content="Gemini API File Search"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gemini API File Search"><meta name=twitter:description content="Gemini API File Search
一. 概述

核心功能：它是一个全托管的RAG（检索增强生成）服务。开发者不需要自己搭建向量数据库、不需要自己写代码切分文档、不需要计算Embedding（向量化），直接把文件扔给Google，它就能自动处理好索引和检索。
最大卖点：

极简开发：从原来的“搭建复杂的RAG系统”变成了“几行API代码调用”。
成本极低：视频强调了目前的高性价比，甚至存储和检索在一定额度内免费（具体看下文分析）。
自带引用：回答问题时会自动标注参考了文档的哪一部分，解决了AI胡编乱造的问题。




二、深度问答与分析
Q1: API 托管 RAG 是最新的技术吗？
结论：不是行业首创，但在“性价比”和“生态整合”上是强有力的竞争者。

竞品对比：

OpenAI：早在2023年推出的 Assistants API 中就包含了 file_search（以前叫Retrieval）功能。原理几乎一模一样：上传文件 -> 自动切片 -> 自动检索。
Anthropic (Claude)：目前主要依赖长上下文（Context Window）硬吃文件，或者需要配合第三方库，还没有原生的类似Assistants API这种全托管RAG接口。


Gemini的后发优势：

上下文窗口更大：Gemini 1.5 Pro/Flash 支持百万级token，结合File Search可以处理更复杂的混合场景。
价格策略：OpenAI的向量存储是按GB收费的，而Gemini API目前的策略非常激进（在很多层面上提供了免费的存储额度或极低的索引费），这对开发者吸引力巨大。



Q2: 它和传统RAG、增强性RAG的区别？

  
      
          维度
          传统 RAG (DIY)
          API 托管 RAG (Gemini File Search)
      
  
  
      
          搭建难度
          高。需要自己选向量数据库(Pinecone/Milvus)、自己写切片算法(Chunking)、选Embedding模型。
          极低。黑盒服务，上传文件即可。
      
      
          可控性
          高。你可以精确控制怎么切分段落、用什么检索算法（混合检索/重排序）。
          低。Google帮你决定怎么切、怎么搜，你只能调少量参数。
      
      
          维护成本
          高。需要运维数据库，关注数据更新和一致性。
          零。Google维护。
      
      
          技术归类
          基础架构。
          SaaS化服务 (RAG as a Service)。
      
  


关于增强性RAG (Advanced RAG)：增强性RAG通常指在检索前后加了“预处理（查询重写）”和“后处理（重排序 Rerank）”。Gemini File Search 内部其实已经集成了增强性技术（例如它会自动对检索结果进行相关性排序），只是没暴露给你看。所以它在效果上优于最简陋的传统RAG，但弱于顶级专家精心调优的定制化RAG。

Q3: 能解决什么痛点？

门槛过高：以前想做个“知识库问答”，即使是Demo也要配环境、装库、买数据库服务。现在只要会调API就行。
效果调优难：新手很难搞定“文档切分”和“向量检索”的参数，Google用通用的最佳实践帮你解决了。
幻觉问题：通过强制的**Citation（引用归属）**功能，大大增加了回答的可信度，解决了老板和客户最担心的“AI瞎说”问题。

Q4: 未来方向
是的，绝对是方向。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"Gemini API File Search","item":"http://ljj1992.fun/posts/gemini-api-file-search/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Gemini API File Search","name":"Gemini API File Search","description":"Gemini API File Search 一. 概述 核心功能：它是一个全托管的RAG（检索增强生成）服务。开发者不需要自己搭建向量数据库、不需要自己写代码切分文档、不需要计算Embedding（向量化），直接把文件扔给Google，它就能自动处理好索引和检索。 最大卖点： 极简开发：从原来的“搭建复杂的RAG系统”变成了“几行API代码调用”。 成本极低：视频强调了目前的高性价比，甚至存储和检索在一定额度内免费（具体看下文分析）。 自带引用：回答问题时会自动标注参考了文档的哪一部分，解决了AI胡编乱造的问题。 二、深度问答与分析 Q1: API 托管 RAG 是最新的技术吗？ 结论：不是行业首创，但在“性价比”和“生态整合”上是强有力的竞争者。\n竞品对比： OpenAI：早在2023年推出的 Assistants API 中就包含了 file_search（以前叫Retrieval）功能。原理几乎一模一样：上传文件 -\u0026gt; 自动切片 -\u0026gt; 自动检索。 Anthropic (Claude)：目前主要依赖长上下文（Context Window）硬吃文件，或者需要配合第三方库，还没有原生的类似Assistants API这种全托管RAG接口。 Gemini的后发优势： 上下文窗口更大：Gemini 1.5 Pro/Flash 支持百万级token，结合File Search可以处理更复杂的混合场景。 价格策略：OpenAI的向量存储是按GB收费的，而Gemini API目前的策略非常激进（在很多层面上提供了免费的存储额度或极低的索引费），这对开发者吸引力巨大。 Q2: 它和传统RAG、增强性RAG的区别？ 维度 传统 RAG (DIY) API 托管 RAG (Gemini File Search) 搭建难度 高。需要自己选向量数据库(Pinecone/Milvus)、自己写切片算法(Chunking)、选Embedding模型。 极低。黑盒服务，上传文件即可。 可控性 高。你可以精确控制怎么切分段落、用什么检索算法（混合检索/重排序）。 低。Google帮你决定怎么切、怎么搜，你只能调少量参数。 维护成本 高。需要运维数据库，关注数据更新和一致性。 零。Google维护。 技术归类 基础架构。 SaaS化服务 (RAG as a Service)。 关于增强性RAG (Advanced RAG)：增强性RAG通常指在检索前后加了“预处理（查询重写）”和“后处理（重排序 Rerank）”。Gemini File Search 内部其实已经集成了增强性技术（例如它会自动对检索结果进行相关性排序），只是没暴露给你看。所以它在效果上优于最简陋的传统RAG，但弱于顶级专家精心调优的定制化RAG。 Q3: 能解决什么痛点？ 门槛过高：以前想做个“知识库问答”，即使是Demo也要配环境、装库、买数据库服务。现在只要会调API就行。 效果调优难：新手很难搞定“文档切分”和“向量检索”的参数，Google用通用的最佳实践帮你解决了。 幻觉问题：通过强制的**Citation（引用归属）**功能，大大增加了回答的可信度，解决了老板和客户最担心的“AI瞎说”问题。 Q4: 未来方向 是的，绝对是方向。\n","keywords":["Google","检索增强生成","RAG","人工智能","Gemini API File Search"],"articleBody":"Gemini API File Search 一. 概述 核心功能：它是一个全托管的RAG（检索增强生成）服务。开发者不需要自己搭建向量数据库、不需要自己写代码切分文档、不需要计算Embedding（向量化），直接把文件扔给Google，它就能自动处理好索引和检索。 最大卖点： 极简开发：从原来的“搭建复杂的RAG系统”变成了“几行API代码调用”。 成本极低：视频强调了目前的高性价比，甚至存储和检索在一定额度内免费（具体看下文分析）。 自带引用：回答问题时会自动标注参考了文档的哪一部分，解决了AI胡编乱造的问题。 二、深度问答与分析 Q1: API 托管 RAG 是最新的技术吗？ 结论：不是行业首创，但在“性价比”和“生态整合”上是强有力的竞争者。\n竞品对比： OpenAI：早在2023年推出的 Assistants API 中就包含了 file_search（以前叫Retrieval）功能。原理几乎一模一样：上传文件 -\u003e 自动切片 -\u003e 自动检索。 Anthropic (Claude)：目前主要依赖长上下文（Context Window）硬吃文件，或者需要配合第三方库，还没有原生的类似Assistants API这种全托管RAG接口。 Gemini的后发优势： 上下文窗口更大：Gemini 1.5 Pro/Flash 支持百万级token，结合File Search可以处理更复杂的混合场景。 价格策略：OpenAI的向量存储是按GB收费的，而Gemini API目前的策略非常激进（在很多层面上提供了免费的存储额度或极低的索引费），这对开发者吸引力巨大。 Q2: 它和传统RAG、增强性RAG的区别？ 维度 传统 RAG (DIY) API 托管 RAG (Gemini File Search) 搭建难度 高。需要自己选向量数据库(Pinecone/Milvus)、自己写切片算法(Chunking)、选Embedding模型。 极低。黑盒服务，上传文件即可。 可控性 高。你可以精确控制怎么切分段落、用什么检索算法（混合检索/重排序）。 低。Google帮你决定怎么切、怎么搜，你只能调少量参数。 维护成本 高。需要运维数据库，关注数据更新和一致性。 零。Google维护。 技术归类 基础架构。 SaaS化服务 (RAG as a Service)。 关于增强性RAG (Advanced RAG)：增强性RAG通常指在检索前后加了“预处理（查询重写）”和“后处理（重排序 Rerank）”。Gemini File Search 内部其实已经集成了增强性技术（例如它会自动对检索结果进行相关性排序），只是没暴露给你看。所以它在效果上优于最简陋的传统RAG，但弱于顶级专家精心调优的定制化RAG。 Q3: 能解决什么痛点？ 门槛过高：以前想做个“知识库问答”，即使是Demo也要配环境、装库、买数据库服务。现在只要会调API就行。 效果调优难：新手很难搞定“文档切分”和“向量检索”的参数，Google用通用的最佳实践帮你解决了。 幻觉问题：通过强制的**Citation（引用归属）**功能，大大增加了回答的可信度，解决了老板和客户最担心的“AI瞎说”问题。 Q4: 未来方向 是的，绝对是方向。\n对于90%的中小开发者和非核心业务场景，“RAG as a Service” (RaaS) 是必然趋势。就像现在没人会为了建个个人博客去自建物理机房一样，未来大部分常规的文档问答需求，都会直接用大模型厂商提供的托管RAG，只有极少数对数据隐私、检索精度有变态要求的企业才会自建复杂RAG链路。\nQ5: 什么样的使用场景适合？ ✅ 适合： 企业内部知识库：员工手册、IT支持文档问答。 垂直领域客服：如视频中的大疆说明书，电商产品售后。 个人开发者/初创公司：快速验证想法（MVP），没有精力搞基建。 ❌ 不适合： 极度敏感数据：虽然Google承诺隐私，但金融/军工等行业通常要求数据完全本地化（On-premise）。 超大规模动态数据：如果是亿级数据且每秒都在变，API托管的延迟和更新机制可能跟不上，还是需要专业的向量数据库。 Q6: Web端（ChatGPT网页版）也有RAG，它是平替吗？ 不是平替，是“后台”与“前台”的关系。[4]\nChatGPT/Gemini 网页版：是给最终用户用的产品。你上传文件，它回答，这是To C的产品。 Gemini API File Search：是给开发者用的工具。你是要开发一个“大疆无人机小助手”App给你的用户用，你需要用这个API来作为你的App的后端技术支撑。 三、 技术原理与使用全流程总结 技术原理（黑盒内部发生了什么？） 虽然视频展示很简单，但其背后的流程和传统RAG一致，只是全自动化了：\nIngestion (摄入)：上传PDF/TXT等文件。 Parsing \u0026 Chunking (解析与切分)：Google自动识别文档结构，将其切分成小块（Chunks）。 Embedding (向量化)：使用 gemini-embedding-001 等模型将文本块转化为向量。 Indexing (索引)：存入Google维护的高效向量库（可能是基于ScaNN算法）。 Retrieval \u0026 Ranking (检索与排序)：用户提问 -\u003e 转化为向量 -\u003e 在库中通过语义匹配找到最相关的K个片段 -\u003e 重排序（关键步骤，确保最相关的排在前面）。 Generation (生成)：将找到的片段作为Context（上下文）喂给Gemini大模型，生成最终答案并标注引用。 使用全流程总结（开发者视角） 根据视频和文档，我为你总结了操作四部曲：\n准备工作：\n申请 Google Gemini API Key（目前在 Google AI Studio 中申请）。 安装 Python 库：pip install -U google-genai。 创建资料库 (Vector Store)：\n调用 client.file_search_stores.create() 创建一个“仓库”，这就像你在云端建了一个文件夹。 上传文件 (Ingestion)：\n调用 upload_file 接口，把本地的 PDF/Docs 传上去。 关键点：需要等待文件状态变为 ACTIVE（处理完成），视频代码里有个 while 循环就是在等这一步。 提问 (Inference)：\n调用 generate_content (聊天接口)。 关键配置：在 tools 参数里，把刚才创建的 store ID 填进去。 Gemini 就会自动去这个 store 里找答案，返回结果。 四、项目源码 目前 Google 官方在 GitHub 上维护了相关的示例代码库，你可以通过以下三个途径获取源码：\n1. 最推荐：直接从 Google AI Studio 获取（官方原版）\n这是视频中UP主演示的方法，能保证你拿到的是最新、最匹配该演示的代码。\n步骤： 访问访问 [Google AI Studio] 点击左侧导航栏的 “Build” (或 Start)。[1] 点击 “Gallery” (画廊) 或 “Starter Apps”。 找到 “Ask the Manual” (可能也叫 “Chat with your Document” 或类似名称) 并点击打开。 在界面上方点击 “Get Code” 或 “Export” 按钮，选择下载到本地或导出到 GitHub。 2.官方 GitHub 仓库（核心逻辑与类似应用）\nGoogle AI Studio Starter Applets 这是 Google AI Studio 官方“Starter Apps”的源码仓库。虽然仓库名可能不叫 ask-the-manual，但其中包含的 File Search 相关示例就是其核心实现。 仓库地址: https://github.com/google-gemini/starter-applets 注：在该仓库中查找与 “File Search” 或 “Document” 相关的目录。 Gemini API Cookbook (核心后端逻辑) 如果你想学习视频中 RAG（文件搜索）背后的 Python/Node.js 核心后端代码（即不包含 React 前端的纯逻辑部分），请看这里： 仓库地址: https://github.com/google-gemini/cookbook 路径: 搜索 File Search 或 RAG 相关的文件夹（通常在 quickstarts/file-search 下）。 社区复刻版本（开箱即用） 仓库地址: https://github.com/tinytechnicaltutorials/google-ai-studio-app 这是国外博主为了演示相同的教程而上传的完整代码（包含 React 前端 + Node.js 后端），结构与视频中基本一致。 总结\n想复现视频效果，建议方法 1；想深入学习代码原理，建议方法 2。下载后记得先运行 npm install 安装依赖，并配置好你的 API Key 才能运行。\n五、小白如何落地使用（保姆级方案） 这就好比你请了一个**过目不忘的超级学霸（Gemini AI）**来帮你考试。\n搭建环境（代理设置）：因为学霸住在国外（Google 服务器），你首先得修一条通往国外的“专用隧道”（Proxy），保证你能把书递给他，他能把话传回来。 建立知识库（File Search Store）：你给学霸准备了一个专属的“书架”。 上传文档（Upload \u0026 Indexing）：你把一本叫《CTF.pdf》的书放到这个书架上。学霸不仅是把书放上去，他还会疯狂阅读并做笔记（这就是“向量化”或“索引”的过程）。他会把书里的每一句话都理解并记在脑子里，准备随时调用。 提问与回答（Generation）：你问：“这就书里有哪些工具？”学霸不会瞎编，他会先在他刚才做的“笔记”里快速搜索相关的段落（检索），然后结合他的语言能力，把搜到的零散信息整理成一段通顺、逻辑清晰的答案告诉你。 官方文档链接解读：你提供的链接里提到的“File Search”，就是指上述的“书架+做笔记+检索”的全套服务。Google 帮你托管了文件处理和搜索算法，你只需要传文件和问问题。\n# -*- coding: utf-8 -*- # 👆 这一行是告诉电脑：这个文件用 UTF-8 编码，防止中文出现乱码 import os # 导入系统模块（管文件、环境变量的） import sys # 导入解释器模块（管程序退出的） import time # 导入时间模块（管暂停、延时的） # ==================== 第一部分：给程序“修路”（代理设置） ==================== # 原理：因为 Google 的服务器在国外，直接连会被墙，所以要强制程序走本地的代理通道。 # 1. 设置 HTTP 和 HTTPS 代理，告诉程序：所有网页请求都走 127.0.0.1:7890 这个端口 os.environ[\"HTTP_PROXY\"] = os.environ[\"http_proxy\"] = \"http://127.0.0.1:7890\" os.environ[\"HTTPS_PROXY\"] = os.environ[\"https_proxy\"] = \"http://127.0.0.1:7890\" # 2. [关键！] 设置 gRPC 代理。 # Google 的新版 SDK 底层用的是 gRPC 协议（一种高性能通讯协议），它不走上面的 HTTP 代理。 # 很多新手连不上就是漏了这一行。 os.environ[\"GRPC_PROXY\"] = \"http://127.0.0.1:7890\" # 3. 关闭 mTLS 证书验证，避免因为证书问题导致连接被拒绝 os.environ[\"GOOGLE_API_USE_CLIENT_CERTIFICATE\"] = \"false\" # 4. 清理“路障” # 检查环境变量里有没有 \"no_proxy\"（禁止代理）的设置，如果有，把它删掉，确保畅通无阻。 for key in list(os.environ.keys()): if key.lower() in [\"no_proxy\", \"all_proxy\"]: os.environ.pop(key, None) print(\"✅ 代理已强制配置为 http://127.0.0.1:7890（含 gRPC）\") # ============================================================================== # 导入 Google 的 AI 库 from google import genai # 核心客户端 from google.genai import types # 存放各种数据类型的工具箱 # ==================== 1. 亮出身份证（配置 API Key） ==================== # 初始化客户端，建立连接。 # ⚠️⚠️⚠️ 为了安全，我把你的 Key 删掉了，请在这里填入你的真实 Key client = genai.Client(api_key=\"在此处填入你的API_KEY\") # ==================== 2. 检查课本在不在（文件检查） ==================== pdf_path = \"CTF.pdf\" # 你要喂给 AI 的文件名 # 如果当前目录下找不到这个文件 if not os.path.exists(pdf_path): print(f\"❌ 文件不存在：{pdf_path}\") sys.exit(1) # 直接报错退出程序，不往下跑了 # ==================== 3. 买个新书架（创建知识库） ==================== print(\"\\n1. 创建 File Search Store（知识库）...\") try: # 在 Google 云端创建一个“文件搜索存储库”(Store) # 就像在图书馆申请了一个专属书架，用来放你的 PDF file_search_store = client.file_search_stores.create( config={'display_name': 'CTF隐写术知识库'} ) print(f\" ✅ 创建成功！存储名称：{file_search_store.name}\") except Exception as e: # 如果创建失败（比如断网了），打印错误原因并退出 print(f\"\\n❌ 创建存储失败：{e}\") sys.exit(1) # ==================== 4. 把书放上去并让 AI 读（上传与索引） ==================== print(f\"\\n2. 上传并导入文件：{pdf_path} ...\") try: # 把本地的 PDF 上传到刚才创建的那个“书架”里 # 注意：这个函数返回的是一个 operation（正在进行中的任务），因为读文件需要时间 operation = client.file_search_stores.upload_to_file_search_store( file=pdf_path, file_search_store_name=file_search_store.name, # 指定放到哪个书架 config={ 'display_name': 'CTF隐写术.pdf', # 云端显示的文件名 } ) print(\" 上传操作已启动...\") except Exception as e: print(f\"\\n❌ 上传失败：{e}\") print(\"提示：检查 API Key quota 或 PDF 格式（确保 \u003c20MB）。\") sys.exit(1) # [核心逻辑] 轮询等待（Polling） # 就像你每隔 5 秒问一次学霸：“书你看完了没？” print(\" 等待处理完成\", end=\"\") while not operation.done: # 只要任务还没变成“完成”状态 print(\".\", end=\"\", flush=True) # 打印一个小点点表示正在加载 time.sleep(5) # 暂停 5 秒 operation = client.operations.get(operation) # 去服务器刷新一下任务的最新状态 print(\" 导入完成！\") # 循环结束，说明书读完了 # ==================== 5. 正式考试（提问） ==================== print(\"\\n3. 启动 Gemini 2.5 Flash + 文件搜索进行提问...\") model = \"gemini-2.5-flash\" # 指定用的模型（Flash 版速度最快） # 你的考题 question = \"这篇文章里提到的隐写术工具有哪些？请详细列举，包括工具名称、支持的载体类型和主要用途。\" print(f\"\\n问题：{question}\\n\") try: # 调用 AI 生成回答 response = client.models.generate_content( model=model, contents=question, # 传入问题 config=types.GenerateContentConfig( # ⬇️ 这一步最关键！给 AI 挂载“文件搜索工具” tools=[ types.Tool( file_search=types.FileSearch( # 告诉 AI：去这个名字的书架里找答案！ file_search_store_names=[file_search_store.name] ) ) ] ) ) # 打印华丽的分隔线 print(\"\\n\" + \"=\" * 50) print(\"AI 回答：\") print(\"=\" * 50) # 打印 AI 返回的文本内容 print(response.text) print(\"=\" * 50) # [高级功能] 检查引用 # 如果 AI 的回答里引用了文件原文，把它打印出来（证明它不是瞎编的） if response.candidates and response.candidates[0].content.parts: for part in response.candidates[0].content.parts: # 检查这部分内容是否包含文件数据引用 if hasattr(part, 'file_data') and part.file_data: print(f\"\\n引用文件：{part.file_data.file.uri}\") except Exception as e: # 错误处理：如果生成过程中出错了（比如 Quota 没了，或者网络断了） print(f\"\\n❌ 生成回答失败：{e}\") print(\"提示：检查 quota（免费 tier 每天 15 RPM），或试换模型为 'gemini-1.5-pro'。\") sys.exit(1) 逐行深度解读（大白话 + 语法双解）\n1、代理与环境配置\nimport os import sys import time 语法解读：导入 Python 的标准库。os 管操作系统交互，sys 管程序退出，time 管时间延迟。 大白话：把工具箱拿过来，待会儿要用到里面的扳手（系统设置）、红灯（退出程序）和闹钟（等待时间）。 # ==================== 2025 年最新终极代理设置 ==================== os.environ[\"HTTP_PROXY\"] = os.environ[\"http_proxy\"] = \"http://127.0.0.1:7890\" os.environ[\"HTTPS_PROXY\"] = os.environ[\"https_proxy\"] = \"http://127.0.0.1:7890\" os.environ[\"GRPC_PROXY\"] = \"http://127.0.0.1:7890\" os.environ[\"GOOGLE_API_USE_CLIENT_CERTIFICATE\"] = \"false\" 语法解读：修改 os.environ 环境变量字典。设置 HTTP、HTTPS 和 gRPC 协议都走本地 7890 端口的代理。关闭 mTLS 客户端证书验证。 大白话：告诉电脑：“不管是看网页还是传数据，统统不要走大路（会被墙），全部走我挖好的这条 7890 号地道！” 那个 gRPC 是 Google 喜欢用的一种特殊快递通道，也得强制它走地道。 for key in list(os.environ.keys()): if key.lower() in [\"no_proxy\", \"all_proxy\"]: os.environ.pop(key, None) 语法解读：遍历环境变量，删除可能冲突的 no_proxy 或 all_proxy 设置。 大白话：检查一下有没有贴着“禁止走地道”的旧标签，如果有，统统撕掉，确保畅通无阻。 2. 初始化客户端\nfrom google import genai from google.genai import types client = genai.Client(api_key=\"AIzaSy...\") 语法解读：从 google 包导入 genai 模块。实例化一个 Client 对象，传入 API 密钥进行身份验证。 大白话：拿起电话拨通 Google 总部，报上你的身份证号（API Key），对方确认你是 VIP 用户，连接建立成功。 3. 文件检查与准备\npdf_path = \"CTF.pdf\" if not os.path.exists(pdf_path): print(f\"❌ 文件不存在：{pdf_path}\") sys.exit(1) 语法解读：检查当前目录下是否有该文件。如果没有，打印错误并以状态码 1（非正常退出）终止程序。 大白话：看看桌子上有没有《CTF.pdf》这本书。要是没有，这就没法玩了，直接挂电话报错，不干了。 4. 创建知识库（关键步骤）\nfile_search_store = client.file_search_stores.create( config={'display_name': 'CTF隐写术知识库'} ) 语法解读：调用 file_search_stores.create 方法在云端创建一个新的存储空间，命名为“CTF隐写术知识库”。 大白话：你在 Google 的云盘里买了个新书架，贴个条叫“CTF隐写术知识库”，准备专门放这类书。 5. 上传与索引\noperation = client.file_search_stores.upload_to_file_search_store( file=pdf_path, file_search_store_name=file_search_store.name, config={'display_name': 'CTF隐写术.pdf'} ) 语法解读：调用上传接口。注意这里返回的是一个 operation（异步操作对象），而不是结果本身，因为处理 PDF 需要时间。 大白话：你把本地的 PDF 扔给 Google。因为书太厚，Google 说：“我收到了，正在处理，你拿个排队号码牌（Operation）先等着。” while not operation.done: print(\".\", end=\"\", flush=True) time.sleep(5) operation = client.operations.get(operation) 语法解读：这是一个轮询循环（Polling）。只要 operation.done 是 False，就每隔 5 秒去服务器问一次“好了没？”，并更新 operation 的状态。 大白话：你每隔 5 秒就问一次学霸：“书读完了吗？”学霸说：“没呢。”你等 5 秒再问：“读完了吗？”……直到学霸说：“读完了！”循环结束。 6. 提问（RAG 核心）\nmodel = \"gemini-2.5-flash\" question = \"这篇文章里提到的隐写术工具有哪些？...\" response = client.models.generate_content( model=model, contents=question, config=types.GenerateContentConfig( tools=[ types.Tool( file_search=types.FileSearch( file_search_store_names=[file_search_store.name] ) ) ] ) ) 语法解读：调用生成接口。 model: 指定使用的模型版本（Flash 版速度快成本低）。 contents: 用户的提示词。 tools: 关键点！在这里挂载了 file_search 工具，并指定了刚才那个 store（书架）。这告诉模型：你可以（且应该）去查阅这个书架里的内容来回答。 大白话：你正式向学霸提问。同时你把刚才那个书架的钥匙交给他，叮嘱道：“回答这个问题时，必须去那个书架上翻翻那本书，别光靠脑补。” print(response.text) 语法解读：打印模型返回的文本内容。 大白话：学霸把总结好的答案写在纸上递给你，你把它念了出来。 发微博总结（复制即可）\n想做一个私有知识库 AI 助手其实只需 50 行代码！🐍✨\n利用 Google 最新的 Gemini 2.5 Flash 模型 + File Search API，这段 Python 脚本实现了： 1️⃣ 自动翻墙：内置硬核代理配置，专治各种连接超时。 2️⃣ 云端大脑：自动上传 PDF 到 Google 向量库，让 AI 像读过书一样理解文档。 3️⃣ 精准问答：不是瞎聊，而是基于文档内容的 RAG（检索增强生成），准确列出书里的工具、数据和细节！\n六、其他(补充) 1、什么是嵌入模型**（Embedding Model）** 1. 直观理解：它是什么？ 想象你现在面对着那本77页的大疆无人机说明书。\n生成式 AI 模型（如 Gemini Pro, GPT-4）：它像一个**“博学的教授”**。它能读懂文字，能思考，能组织语言，能回答你的问题。但是，如果你把77页的书直接甩给它，它读起来很慢，而且很贵（按字数收费）。 嵌入式模型（Embedding Model）：它像一个**“图书管理员”。它不会说话**，也不会写文章。它的工作只有一个：把文字变成坐标（数字）。 2. 它和“AI大模型”有什么区别？ 这是最关键的部分，它们的输入可能一样（都是文字），但输出和任务完全不同：\n特性 嵌入模型 (Embedding Model) 生成式 AI 模型 (LLM) 形象比喻 图书管理员 / 翻译官 作家 / 教授 输出结果 一串数字（比如 [0.1, -0.5, 0.9…]） 一段人类语言（“你好，今天是晴天…”） 核心能力 理解“含义”的相似度 逻辑推理、语言组织、创作 计算速度 极快 较慢 费用 很便宜（甚至是LLM的千分之一） 较贵 3. 它具体做了哪些事情？（技术原理） 嵌入模型的作用是**“将人类的语言，翻译成计算机能计算的数学坐标”**。\n在计算机眼里，“苹果\"这两个字只是二进制编码。如果不通过嵌入模型，计算机不知道\"苹果”（水果）和\"梨\"是相似的，也不知道\"苹果\"（手机）和\"华为\"是相似的。\n嵌入模型做了这三步：\n语义压缩：它读入一段话（比如“无人机红灯闪烁”）。 特征提取：它分析这句话的深层含义。它知道“红灯”代表“警告”，“闪烁”代表“状态”。 向量化（坐标化）：它把这句话变成一个高维空间里的坐标点（向量）。 举个神奇的例子： 在这个数学空间里，嵌入模型能做到：\n国王 - 男人 + 女人 = 女王 （它通过数字计算，理解了词语之间的逻辑关系！） 4. 为什么 RAG（知识库）非要用它？ 回到视频里的场景，为什么不直接让Gemini大模型去搜那77页文档？\n没有嵌入模型时的笨办法（全文搜索）： 你搜“红灯闪烁”，传统的搜索（关键词匹配）只能去文档里找哪里出现了“红灯”和“闪烁”这两个词。如果文档里写的是“指示灯红色频闪”，传统搜索可能就找不到了，因为字不一样。\n有了嵌入模型后的聪明办法（语义检索）：\n存入时：嵌入模型把文档里的“指示灯红色频闪”这句话，变成了一个数学坐标 A。 提问时：你问“红灯为啥亮了？”，嵌入模型把你的问题变成了数学坐标 B。 找答案：计算机发现，坐标 A 和 坐标 B 在空间里靠得非常近（哪怕字面上没有一个字是一样的，意思却很近）。 结果：系统迅速把这句话提取出来，扔给Gemini大模型去组织语言回答你。 5. 总结：它的存在意义 嵌入式模型存在的最大意义是：它让计算机懂得了“语义的远近”。\n没有它：计算机只能做“找同字”的机械匹配。 有了它：计算机能做“找同义”的智能检索。 所以，在 RAG 流程里：\n嵌入模型负责**“找”**（快速、便宜、懂语义）。 AI大模型负责**“看”和“写”**（读懂找到的内容，并写出人话）。 2、嵌入模型返回给大模型处理的内容 简单来说，嵌入模型（图书管理员） 找到书以后，并不是直接把书扔给用户，而是把书里最关键的那几页撕下来，和用户的问题打包在一起，组成一个**“超级提示词大礼包”**，最后发给 AI 大模型（教授）。\n具体来说，回给 AI 大模型处理的“这一包东西”，通常包含 三个部分（就像一个三明治）：\n第一部分：系统指令（System Prompt）——“你是谁，你要干什么”\n这是给 AI 立规矩的。在代码里，开发者会偷偷塞给 AI 一段话，用户通常看不见。\n内容示例：\n“你是一个大疆无人机的智能客服助手。请你根据下面提供的参考资料来回答用户的问题。如果参考资料里没有答案，就说不知道，严禁自己瞎编。”\n第二部分：检索到的“上下文片段”（Context/Chunks）——“参考资料”\n这是最核心的部分！ 嵌入模型刚才辛苦工作，从77页的文档里，找出了和“红灯闪烁”最相关的3-5段话（也许是第12页的第2段，和第15页的第1段）。 系统会把这几段原文直接复制粘贴到这里。\n内容示例：\n参考资料片段1：…当飞行器电池电量严重不足时，状态指示灯会快速闪烁红灯… 参考资料片段2：…如果指南针受到干扰，指示灯可能会红黄交替闪烁…\n第三部分：用户的原始提问（User Query）——“考试题目”\n最后才是用户真正输入的那句话。\n内容示例：\n用户问：“我的无人机红灯一直闪是怎么回事？”\n总结：AI 大模型实际看到的“完整考卷” 所以，当你问了一句“红灯闪是怎么回事？”时，AI 大模型实际收到的输入（Input） 是下面这一长串东西：\ncodeText\n【系统指令】：你是一个助手，请根据以下资料回答问题。 【参考资料】： 1. 当飞行器电池电量严重不足时，状态指示灯会快速闪烁红灯... 2. 严重低电量报警触发时，飞机将强制降落... 【用户问题】：我的无人机红灯一直闪是怎么回事？ 【回答要求】：请用通俗易懂的语言回答。 3、“元数据过滤”（Metadata Filtering） “元数据过滤”（Metadata Filtering）\n我之前没强调的：我之前只说了它能“搜内容”。 文档新发现：Gemini File Search 支持元数据过滤。 这是什么？：以前RAG是“在大海里捞针”。现在你可以告诉它“只在2023年之后的文件里捞”或者“只在财务部的文件里捞”。 作用：这能极大地提高准确率，防止搜到过期的旧文档（比如搜到了2020年的旧版大疆手册）。 技术流程修正：是“Vector Store”而不是简单的“数据存储”\n流程修正：在代码实现上，Google 引入了一个明确的概念叫 Vector Store（向量仓库）。 你不能直接把文件扔给模型。 正确流程是：上传文件 -\u003e 创建一个 Vector Store -\u003e 把文件扔进这个 Store -\u003e 把 Store 绑定给模型。 这个 Vector Store 是可以复用的。你不用每次聊天都重新传文件，建好一次，以后一直用ID调用即可。 4、api rag功能和web端的gemini的区别，存在的意义 Web端（Gemini 网页版）： 当你上传 PDF 到网页版时，Google 后台 其实也在做类似的事情：解析文件 -\u003e 提取内容 -\u003e 放入临时的上下文窗口或临时索引。 它自动就有了搜索文档的能力。你不需要设置什么“File Search Tool”，因为那是给普通用户用的，Google 把这些技术细节都隐藏起来了。 但是：网页版的“记忆”通常是临时的。你关掉网页，或者过几天，它可能就忘了那个文件，或者你需要重新传。而且网页版不能让你把这个功能塞到你自己的 App 里去卖钱。 API端（我们刚才写的代码）： 这是手动挡。你需要显式地告诉它“创建一个Store”、“把文件放进去”。 区别： 持久化：用代码创建的 Vector Store 是永久存在的（除非你删了）。你今天传上去，下个月写代码直接调这个 Store 的 ID，它还能回答，不用重新传。 规模化：网页版你传 100 个文件可能就卡死了。API 版你可以传 10,000 个文件进知识库。 可集成：你可以把这个功能做成一个微信小程序、一个公司内部软件，这就是 API 的意义。 总结： 你在网页版上传文件，确实是在使用类似的“文档理解能力”，体验上就是“自动有了”。 但我们学这个 API，是为了把这种能力变成你自己的软件功能，而不仅仅是当一个用户去聊天。\n","wordCount":"1164","inLanguage":"en","datePublished":"2025-11-26T18:00:00+08:00","dateModified":"2025-11-26T18:00:00+08:00","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/gemini-api-file-search/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Gemini API File Search</h1><div class=post-meta><span title='2025-11-26 18:00:00 +0800 +0800'>November 26, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h1 id=gemini-api-file-search><strong>Gemini API File Search</strong><a hidden class=anchor aria-hidden=true href=#gemini-api-file-search>#</a></h1><h2 id=一-概述>一. 概述<a hidden class=anchor aria-hidden=true href=#一-概述>#</a></h2><ul><li><strong>核心功能</strong>：它是一个<strong>全托管的RAG（检索增强生成）服务</strong>。开发者不需要自己搭建向量数据库、不需要自己写代码切分文档、不需要计算Embedding（向量化），直接把文件扔给Google，它就能自动处理好索引和检索。</li><li><strong>最大卖点</strong>：<ul><li><strong>极简开发</strong>：从原来的“搭建复杂的RAG系统”变成了“几行API代码调用”。</li><li><strong>成本极低</strong>：视频强调了目前的高性价比，甚至存储和检索在一定额度内免费（具体看下文分析）。</li><li><strong>自带引用</strong>：回答问题时会自动标注参考了文档的哪一部分，解决了AI胡编乱造的问题。</li></ul></li></ul><hr><h2 id=二深度问答与分析>二、深度问答与分析<a hidden class=anchor aria-hidden=true href=#二深度问答与分析>#</a></h2><h3 id=q1-api-托管-rag-是最新的技术吗>Q1: API 托管 RAG 是最新的技术吗？<a hidden class=anchor aria-hidden=true href=#q1-api-托管-rag-是最新的技术吗>#</a></h3><p><strong>结论：不是行业首创，但在“性价比”和“生态整合”上是强有力的竞争者。</strong></p><ul><li><strong>竞品对比</strong>：<ul><li><strong>OpenAI</strong>：早在2023年推出的 <strong>Assistants API</strong> 中就包含了 file_search（以前叫Retrieval）功能。原理几乎一模一样：上传文件 -> 自动切片 -> 自动检索。</li><li><strong>Anthropic (Claude)</strong>：目前主要依赖长上下文（Context Window）硬吃文件，或者需要配合第三方库，还没有原生的类似Assistants API这种全托管RAG接口。</li></ul></li><li><strong>Gemini的后发优势</strong>：<ul><li><strong>上下文窗口更大</strong>：Gemini 1.5 Pro/Flash 支持百万级token，结合File Search可以处理更复杂的混合场景。</li><li><strong>价格策略</strong>：OpenAI的向量存储是按GB收费的，而Gemini API目前的策略非常激进（在很多层面上提供了免费的存储额度或极低的索引费），这对开发者吸引力巨大。</li></ul></li></ul><h3 id=q2-它和传统rag增强性rag的区别>Q2: 它和传统RAG、增强性RAG的区别？<a hidden class=anchor aria-hidden=true href=#q2-它和传统rag增强性rag的区别>#</a></h3><table><thead><tr><th>维度</th><th>传统 RAG (DIY)</th><th>API 托管 RAG (Gemini File Search)</th></tr></thead><tbody><tr><td><strong>搭建难度</strong></td><td><strong>高</strong>。需要自己选向量数据库(Pinecone/Milvus)、自己写切片算法(Chunking)、选Embedding模型。</td><td><strong>极低</strong>。黑盒服务，上传文件即可。</td></tr><tr><td><strong>可控性</strong></td><td><strong>高</strong>。你可以精确控制怎么切分段落、用什么检索算法（混合检索/重排序）。</td><td><strong>低</strong>。Google帮你决定怎么切、怎么搜，你只能调少量参数。</td></tr><tr><td><strong>维护成本</strong></td><td><strong>高</strong>。需要运维数据库，关注数据更新和一致性。</td><td><strong>零</strong>。Google维护。</td></tr><tr><td><strong>技术归类</strong></td><td>基础架构。</td><td><strong>SaaS化服务 (RAG as a Service)</strong>。</td></tr></tbody></table><ul><li><strong>关于增强性RAG (Advanced RAG)</strong>：增强性RAG通常指在检索前后加了“预处理（查询重写）”和“后处理（重排序 Rerank）”。<strong>Gemini File Search 内部其实已经集成了增强性技术</strong>（例如它会自动对检索结果进行相关性排序），只是没暴露给你看。所以它在效果上优于最简陋的传统RAG，但弱于顶级专家精心调优的定制化RAG。</li></ul><h3 id=q3-能解决什么痛点>Q3: 能解决什么痛点？<a hidden class=anchor aria-hidden=true href=#q3-能解决什么痛点>#</a></h3><ol><li><strong>门槛过高</strong>：以前想做个“知识库问答”，即使是Demo也要配环境、装库、买数据库服务。现在只要会调API就行。</li><li><strong>效果调优难</strong>：新手很难搞定“文档切分”和“向量检索”的参数，Google用通用的最佳实践帮你解决了。</li><li><strong>幻觉问题</strong>：通过强制的**Citation（引用归属）**功能，大大增加了回答的可信度，解决了老板和客户最担心的“AI瞎说”问题。</li></ol><h3 id=q4-未来方向>Q4: 未来方向<a hidden class=anchor aria-hidden=true href=#q4-未来方向>#</a></h3><p><strong>是的，绝对是方向。</strong></p><p>对于90%的中小开发者和非核心业务场景，<strong>“RAG as a Service” (RaaS)</strong> 是必然趋势。就像现在没人会为了建个个人博客去自建物理机房一样，未来大部分常规的文档问答需求，都会直接用大模型厂商提供的托管RAG，只有极少数对数据隐私、检索精度有变态要求的企业才会自建复杂RAG链路。</p><h3 id=q5-什么样的使用场景适合>Q5: 什么样的使用场景适合？<a hidden class=anchor aria-hidden=true href=#q5-什么样的使用场景适合>#</a></h3><ul><li>✅ <strong>适合</strong>：<ul><li><strong>企业内部知识库</strong>：员工手册、IT支持文档问答。</li><li><strong>垂直领域客服</strong>：如视频中的大疆说明书，电商产品售后。</li><li><strong>个人开发者/初创公司</strong>：快速验证想法（MVP），没有精力搞基建。</li></ul></li><li>❌ <strong>不适合</strong>：<ul><li><strong>极度敏感数据</strong>：虽然Google承诺隐私，但金融/军工等行业通常要求数据完全本地化（On-premise）。</li><li><strong>超大规模动态数据</strong>：如果是亿级数据且每秒都在变，API托管的延迟和更新机制可能跟不上，还是需要专业的向量数据库。</li></ul></li></ul><h3 id=q6-web端chatgpt网页版也有rag它是平替吗>Q6: Web端（ChatGPT网页版）也有RAG，它是平替吗？<a hidden class=anchor aria-hidden=true href=#q6-web端chatgpt网页版也有rag它是平替吗>#</a></h3><p><strong>不是平替，是“后台”与“前台”的关系。</strong>[<a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHPm16_OIYATcNoX6vg9LnBJUZQjJ2loZjES7guFfIFgSCNfWYIkj6S1APz12Wa4oeeqyeVJBDZCcXLncPWLGATHSZ3-G8pMJutGrGfFJpDLdWp3B88w7gj-cc9-kNw0mLM6dTnD6qoyQA0TS3nhCDGEn97M17PEpnyDyRu">4</a>]</p><ul><li><strong>ChatGPT/Gemini 网页版</strong>：是给<strong>最终用户</strong>用的产品。你上传文件，它回答，这是To C的产品。</li><li><strong>Gemini API File Search</strong>：是给<strong>开发者</strong>用的工具。你是要开发一个“大疆无人机小助手”App给你的用户用，你需要用这个API来作为你的App的后端技术支撑。</li></ul><hr><h2 id=三-技术原理与使用全流程总结>三、 技术原理与使用全流程总结<a hidden class=anchor aria-hidden=true href=#三-技术原理与使用全流程总结>#</a></h2><h3 id=技术原理黑盒内部发生了什么>技术原理（黑盒内部发生了什么？）<a hidden class=anchor aria-hidden=true href=#技术原理黑盒内部发生了什么>#</a></h3><p>虽然视频展示很简单，但其背后的流程和传统RAG一致，只是全自动化了：</p><ol><li><strong>Ingestion (摄入)</strong>：上传PDF/TXT等文件。</li><li><strong>Parsing & Chunking (解析与切分)</strong>：Google自动识别文档结构，将其切分成小块（Chunks）。</li><li><strong>Embedding (向量化)</strong>：使用 gemini-embedding-001 等模型将文本块转化为向量。</li><li><strong>Indexing (索引)</strong>：存入Google维护的高效向量库（可能是基于ScaNN算法）。</li><li><strong>Retrieval & Ranking (检索与排序)</strong>：用户提问 -> 转化为向量 -> 在库中通过语义匹配找到最相关的K个片段 -> <strong>重排序</strong>（关键步骤，确保最相关的排在前面）。</li><li><strong>Generation (生成)</strong>：将找到的片段作为Context（上下文）喂给Gemini大模型，生成最终答案并标注引用。</li></ol><h3 id=使用全流程总结开发者视角>使用全流程总结（开发者视角）<a hidden class=anchor aria-hidden=true href=#使用全流程总结开发者视角>#</a></h3><p>根据视频和文档，我为你总结了操作四部曲：</p><ol><li><p><strong>准备工作</strong>：</p><ul><li>申请 Google Gemini API Key（目前在 Google AI Studio 中申请）。</li><li>安装 Python 库：pip install -U google-genai。</li></ul></li><li><p><strong>创建资料库 (Vector Store)</strong>：</p><ul><li>调用 client.file_search_stores.create() 创建一个“仓库”，这就像你在云端建了一个文件夹。</li></ul></li><li><p><strong>上传文件 (Ingestion)</strong>：</p><ul><li>调用 upload_file 接口，把本地的 PDF/Docs 传上去。</li><li><strong>关键点</strong>：需要等待文件状态变为 ACTIVE（处理完成），视频代码里有个 while 循环就是在等这一步。</li></ul></li><li><p><strong>提问 (Inference)</strong>：</p><ul><li>调用 generate_content (聊天接口)。</li><li><strong>关键配置</strong>：在 tools 参数里，把刚才创建的 store ID 填进去。</li><li>Gemini 就会自动去这个 store 里找答案，返回结果。</li></ul></li></ol><hr><h2 id=四项目源码>四、项目源码<a hidden class=anchor aria-hidden=true href=#四项目源码>#</a></h2><p>目前 Google 官方在 GitHub 上维护了相关的示例代码库，你可以通过以下三个途径获取源码：</p><p><strong>1. 最推荐：直接从 Google AI Studio 获取（官方原版）</strong></p><p>这是视频中UP主演示的方法，能保证你拿到的是最新、最匹配该演示的代码。</p><ul><li><strong>步骤</strong>：<ol><li>访问访问 [Google AI Studio]</li><li>点击左侧导航栏的 <strong>&ldquo;Build&rdquo;</strong> (或 Start)。[<a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFUXfutuin37KgaaAv8NozbhyIVnAg9ovx86bajpMcl_O3r5d6mGFRSADkspXYt-JQVHvKYBUFaaQtjh31LMLAQ2UaNrRlp98xZCzV7U_2SeWzSQ46aZayP4kUzDjFwROeAvU07pw%3D%3D">1</a>]</li><li>点击 <strong>&ldquo;Gallery&rdquo;</strong> (画廊) 或 <strong>&ldquo;Starter Apps&rdquo;</strong>。</li><li>找到 <strong>&ldquo;Ask the Manual&rdquo;</strong> (可能也叫 &ldquo;Chat with your Document&rdquo; 或类似名称) 并点击打开。</li><li>在界面上方点击 <strong>&ldquo;Get Code&rdquo;</strong> 或 <strong>&ldquo;Export&rdquo;</strong> 按钮，选择下载到本地或导出到 GitHub。</li></ol></li></ul><p><strong>2.官方 GitHub 仓库（核心逻辑与类似应用）</strong></p><ul><li><strong>Google AI Studio Starter Applets</strong>
这是 Google AI Studio 官方“Starter Apps”的源码仓库。虽然仓库名可能不叫 ask-the-manual，但其中包含的 File Search 相关示例就是其核心实现。<ul><li><strong>仓库地址</strong>: <a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fgithub.com%2Fgoogle-gemini%2Fstarter-applets">https://github.com/google-gemini/starter-applets</a></li><li><em>注：在该仓库中查找与 &ldquo;File Search&rdquo; 或 &ldquo;Document&rdquo; 相关的目录。</em></li></ul></li><li><strong>Gemini API Cookbook (核心后端逻辑)</strong>
如果你想学习视频中 RAG（文件搜索）背后的 Python/Node.js <strong>核心后端代码</strong>（即不包含 React 前端的纯逻辑部分），请看这里：<ul><li><strong>仓库地址</strong>: <a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fgithub.com%2Fgoogle-gemini%2Fcookbook">https://github.com/google-gemini/cookbook</a></li><li><strong>路径</strong>: 搜索 File Search 或 RAG 相关的文件夹（通常在 quickstarts/file-search 下）。</li></ul></li></ul><ol start=3><li><strong>社区复刻版本（开箱即用）</strong></li></ol><ul><li><strong>仓库地址</strong>: <a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fgithub.com%2Ftinytechnicaltutorials%2Fgoogle-ai-studio-app">https://github.com/tinytechnicaltutorials/google-ai-studio-app</a><ul><li>这是国外博主为了演示相同的教程而上传的完整代码（包含 React 前端 + Node.js 后端），结构与视频中基本一致。</li></ul></li></ul><p><strong>总结</strong></p><p>想复现视频效果，建议<strong>方法 1</strong>；想深入学习代码原理，建议<strong>方法 2</strong>。下载后记得先运行 npm install 安装依赖，并配置好你的 API Key 才能运行。</p><h2 id=五小白如何落地使用保姆级方案>五、小白如何落地使用（保姆级方案）<a hidden class=anchor aria-hidden=true href=#五小白如何落地使用保姆级方案>#</a></h2><p>这就好比你请了一个**过目不忘的超级学霸（Gemini AI）**来帮你考试。</p><ol><li><strong>搭建环境（代理设置）</strong>：因为学霸住在国外（Google 服务器），你首先得修一条通往国外的“专用隧道”（Proxy），保证你能把书递给他，他能把话传回来。</li><li><strong>建立知识库（File Search Store）</strong>：你给学霸准备了一个专属的“书架”。</li><li><strong>上传文档（Upload & Indexing）</strong>：你把一本叫《CTF.pdf》的书放到这个书架上。学霸不仅是把书放上去，他还会<strong>疯狂阅读并做笔记</strong>（这就是“向量化”或“索引”的过程）。他会把书里的每一句话都理解并记在脑子里，准备随时调用。</li><li><strong>提问与回答（Generation）</strong>：你问：“这就书里有哪些工具？”学霸不会瞎编，他会先在他刚才做的“笔记”里快速搜索相关的段落（检索），然后结合他的语言能力，把搜到的零散信息整理成一段通顺、逻辑清晰的答案告诉你。</li></ol><p><strong>官方文档链接解读</strong>：你提供的链接里提到的“File Search”，就是指上述的“书架+做笔记+检索”的全套服务。Google 帮你托管了文件处理和搜索算法，你只需要传文件和问问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># -*- coding: utf-8 -*-</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 👆 这一行是告诉电脑：这个文件用 UTF-8 编码，防止中文出现乱码</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os    <span style=color:#75715e># 导入系统模块（管文件、环境变量的）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys   <span style=color:#75715e># 导入解释器模块（管程序退出的）</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time  <span style=color:#75715e># 导入时间模块（管暂停、延时的）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ==================== 第一部分：给程序“修路”（代理设置） ====================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 原理：因为 Google 的服务器在国外，直接连会被墙，所以要强制程序走本地的代理通道。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. 设置 HTTP 和 HTTPS 代理，告诉程序：所有网页请求都走 127.0.0.1:7890 这个端口</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;HTTP_PROXY&#34;</span>] <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;http_proxy&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://127.0.0.1:7890&#34;</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;HTTPS_PROXY&#34;</span>] <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;https_proxy&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://127.0.0.1:7890&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. [关键！] 设置 gRPC 代理。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Google 的新版 SDK 底层用的是 gRPC 协议（一种高性能通讯协议），它不走上面的 HTTP 代理。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 很多新手连不上就是漏了这一行。</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;GRPC_PROXY&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://127.0.0.1:7890&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 关闭 mTLS 证书验证，避免因为证书问题导致连接被拒绝</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;GOOGLE_API_USE_CLIENT_CERTIFICATE&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;false&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 清理“路障”</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 检查环境变量里有没有 &#34;no_proxy&#34;（禁止代理）的设置，如果有，把它删掉，确保畅通无阻。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> key <span style=color:#f92672>in</span> list(os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>keys()):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> key<span style=color:#f92672>.</span>lower() <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#34;no_proxy&#34;</span>, <span style=color:#e6db74>&#34;all_proxy&#34;</span>]:
</span></span><span style=display:flex><span>        os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>pop(key, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;✅ 代理已强制配置为 http://127.0.0.1:7890（含 gRPC）&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># ==============================================================================</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 导入 Google 的 AI 库</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> google <span style=color:#f92672>import</span> genai                     <span style=color:#75715e># 核心客户端</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> google.genai <span style=color:#f92672>import</span> types               <span style=color:#75715e># 存放各种数据类型的工具箱</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ==================== 1. 亮出身份证（配置 API Key） ====================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 初始化客户端，建立连接。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ⚠️⚠️⚠️ 为了安全，我把你的 Key 删掉了，请在这里填入你的真实 Key</span>
</span></span><span style=display:flex><span>client <span style=color:#f92672>=</span> genai<span style=color:#f92672>.</span>Client(api_key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;在此处填入你的API_KEY&#34;</span>) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ==================== 2. 检查课本在不在（文件检查） ====================</span>
</span></span><span style=display:flex><span>pdf_path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;CTF.pdf&#34;</span>  <span style=color:#75715e># 你要喂给 AI 的文件名</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 如果当前目录下找不到这个文件</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(pdf_path):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;❌ 文件不存在：</span><span style=color:#e6db74>{</span>pdf_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>1</span>) <span style=color:#75715e># 直接报错退出程序，不往下跑了</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ==================== 3. 买个新书架（创建知识库） ====================</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>1. 创建 File Search Store（知识库）...&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 在 Google 云端创建一个“文件搜索存储库”(Store)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 就像在图书馆申请了一个专属书架，用来放你的 PDF</span>
</span></span><span style=display:flex><span>    file_search_store <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>file_search_stores<span style=color:#f92672>.</span>create(
</span></span><span style=display:flex><span>        config<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#39;display_name&#39;</span>: <span style=color:#e6db74>&#39;CTF隐写术知识库&#39;</span>}
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;   ✅ 创建成功！存储名称：</span><span style=color:#e6db74>{</span>file_search_store<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 如果创建失败（比如断网了），打印错误原因并退出</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>❌ 创建存储失败：</span><span style=color:#e6db74>{</span>e<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ==================== 4. 把书放上去并让 AI 读（上传与索引） ====================</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>2. 上传并导入文件：</span><span style=color:#e6db74>{</span>pdf_path<span style=color:#e6db74>}</span><span style=color:#e6db74> ...&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 把本地的 PDF 上传到刚才创建的那个“书架”里</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 注意：这个函数返回的是一个 operation（正在进行中的任务），因为读文件需要时间</span>
</span></span><span style=display:flex><span>    operation <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>file_search_stores<span style=color:#f92672>.</span>upload_to_file_search_store(
</span></span><span style=display:flex><span>        file<span style=color:#f92672>=</span>pdf_path,
</span></span><span style=display:flex><span>        file_search_store_name<span style=color:#f92672>=</span>file_search_store<span style=color:#f92672>.</span>name, <span style=color:#75715e># 指定放到哪个书架</span>
</span></span><span style=display:flex><span>        config<span style=color:#f92672>=</span>{
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;display_name&#39;</span>: <span style=color:#e6db74>&#39;CTF隐写术.pdf&#39;</span>, <span style=color:#75715e># 云端显示的文件名</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;   上传操作已启动...&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>❌ 上传失败：</span><span style=color:#e6db74>{</span>e<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;提示：检查 API Key quota 或 PDF 格式（确保 &lt;20MB）。&#34;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># [核心逻辑] 轮询等待（Polling）</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 就像你每隔 5 秒问一次学霸：“书你看完了没？”</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;   等待处理完成&#34;</span>, end<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> operation<span style=color:#f92672>.</span>done: <span style=color:#75715e># 只要任务还没变成“完成”状态</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;.&#34;</span>, end<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>, flush<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>) <span style=color:#75715e># 打印一个小点点表示正在加载</span>
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>5</span>)                  <span style=color:#75715e># 暂停 5 秒</span>
</span></span><span style=display:flex><span>    operation <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>operations<span style=color:#f92672>.</span>get(operation)  <span style=color:#75715e># 去服务器刷新一下任务的最新状态</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34; 导入完成！&#34;</span>) <span style=color:#75715e># 循环结束，说明书读完了</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># ==================== 5. 正式考试（提问） ====================</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>3. 启动 Gemini 2.5 Flash + 文件搜索进行提问...&#34;</span>)
</span></span><span style=display:flex><span>model <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;gemini-2.5-flash&#34;</span>  <span style=color:#75715e># 指定用的模型（Flash 版速度最快）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 你的考题</span>
</span></span><span style=display:flex><span>question <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;这篇文章里提到的隐写术工具有哪些？请详细列举，包括工具名称、支持的载体类型和主要用途。&#34;</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>问题：</span><span style=color:#e6db74>{</span>question<span style=color:#e6db74>}</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 调用 AI 生成回答</span>
</span></span><span style=display:flex><span>    response <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>models<span style=color:#f92672>.</span>generate_content(
</span></span><span style=display:flex><span>        model<span style=color:#f92672>=</span>model,
</span></span><span style=display:flex><span>        contents<span style=color:#f92672>=</span>question,  <span style=color:#75715e># 传入问题</span>
</span></span><span style=display:flex><span>        config<span style=color:#f92672>=</span>types<span style=color:#f92672>.</span>GenerateContentConfig(
</span></span><span style=display:flex><span>            <span style=color:#75715e># ⬇️ 这一步最关键！给 AI 挂载“文件搜索工具”</span>
</span></span><span style=display:flex><span>            tools<span style=color:#f92672>=</span>[
</span></span><span style=display:flex><span>                types<span style=color:#f92672>.</span>Tool(
</span></span><span style=display:flex><span>                    file_search<span style=color:#f92672>=</span>types<span style=color:#f92672>.</span>FileSearch(
</span></span><span style=display:flex><span>                        <span style=color:#75715e># 告诉 AI：去这个名字的书架里找答案！</span>
</span></span><span style=display:flex><span>                        file_search_store_names<span style=color:#f92672>=</span>[file_search_store<span style=color:#f92672>.</span>name]
</span></span><span style=display:flex><span>                    )
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 打印华丽的分隔线</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;AI 回答：&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># 打印 AI 返回的文本内容</span>
</span></span><span style=display:flex><span>    print(response<span style=color:#f92672>.</span>text)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>50</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># [高级功能] 检查引用</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 如果 AI 的回答里引用了文件原文，把它打印出来（证明它不是瞎编的）</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> response<span style=color:#f92672>.</span>candidates <span style=color:#f92672>and</span> response<span style=color:#f92672>.</span>candidates[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>content<span style=color:#f92672>.</span>parts:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> part <span style=color:#f92672>in</span> response<span style=color:#f92672>.</span>candidates[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>content<span style=color:#f92672>.</span>parts:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 检查这部分内容是否包含文件数据引用</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> hasattr(part, <span style=color:#e6db74>&#39;file_data&#39;</span>) <span style=color:#f92672>and</span> part<span style=color:#f92672>.</span>file_data:
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>引用文件：</span><span style=color:#e6db74>{</span>part<span style=color:#f92672>.</span>file_data<span style=color:#f92672>.</span>file<span style=color:#f92672>.</span>uri<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 错误处理：如果生成过程中出错了（比如 Quota 没了，或者网络断了）</span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>❌ 生成回答失败：</span><span style=color:#e6db74>{</span>e<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;提示：检查 quota（免费 tier 每天 15 RPM），或试换模型为 &#39;gemini-1.5-pro&#39;。&#34;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p><strong>逐行深度解读（大白话 + 语法双解）</strong></p><p><strong>1、代理与环境配置</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：导入 Python 的标准库。os 管操作系统交互，sys 管程序退出，time 管时间延迟。</li><li><strong>大白话</strong>：把工具箱拿过来，待会儿要用到里面的扳手（系统设置）、红灯（退出程序）和闹钟（等待时间）。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># ==================== 2025 年最新终极代理设置 ====================</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;HTTP_PROXY&#34;</span>] <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;http_proxy&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://127.0.0.1:7890&#34;</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;HTTPS_PROXY&#34;</span>] <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;https_proxy&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://127.0.0.1:7890&#34;</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;GRPC_PROXY&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://127.0.0.1:7890&#34;</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>environ[<span style=color:#e6db74>&#34;GOOGLE_API_USE_CLIENT_CERTIFICATE&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;false&#34;</span>
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：修改 os.environ 环境变量字典。设置 HTTP、HTTPS 和 gRPC 协议都走本地 7890 端口的代理。关闭 mTLS 客户端证书验证。</li><li><strong>大白话</strong>：告诉电脑：“不管是看网页还是传数据，统统不要走大路（会被墙），全部走我挖好的这条 7890 号地道！” 那个 gRPC 是 Google 喜欢用的一种特殊快递通道，也得强制它走地道。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> key <span style=color:#f92672>in</span> list(os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>keys()):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> key<span style=color:#f92672>.</span>lower() <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#34;no_proxy&#34;</span>, <span style=color:#e6db74>&#34;all_proxy&#34;</span>]:
</span></span><span style=display:flex><span>        os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>pop(key, <span style=color:#66d9ef>None</span>)
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：遍历环境变量，删除可能冲突的 no_proxy 或 all_proxy 设置。</li><li><strong>大白话</strong>：检查一下有没有贴着“禁止走地道”的旧标签，如果有，统统撕掉，确保畅通无阻。</li></ul><p><strong>2. 初始化客户端</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> google <span style=color:#f92672>import</span> genai
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> google.genai <span style=color:#f92672>import</span> types
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>client <span style=color:#f92672>=</span> genai<span style=color:#f92672>.</span>Client(api_key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;AIzaSy...&#34;</span>)
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：从 google 包导入 genai 模块。实例化一个 Client 对象，传入 API 密钥进行身份验证。</li><li><strong>大白话</strong>：拿起电话拨通 Google 总部，报上你的身份证号（API Key），对方确认你是 VIP 用户，连接建立成功。</li></ul><p><strong>3. 文件检查与准备</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>pdf_path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;CTF.pdf&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(pdf_path):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;❌ 文件不存在：</span><span style=color:#e6db74>{</span>pdf_path<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：检查当前目录下是否有该文件。如果没有，打印错误并以状态码 1（非正常退出）终止程序。</li><li><strong>大白话</strong>：看看桌子上有没有《CTF.pdf》这本书。要是没有，这就没法玩了，直接挂电话报错，不干了。</li></ul><p><strong>4. 创建知识库（关键步骤）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>file_search_store <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>file_search_stores<span style=color:#f92672>.</span>create(
</span></span><span style=display:flex><span>    config<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#39;display_name&#39;</span>: <span style=color:#e6db74>&#39;CTF隐写术知识库&#39;</span>}
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：调用 file_search_stores.create 方法在云端创建一个新的存储空间，命名为“CTF隐写术知识库”。</li><li><strong>大白话</strong>：你在 Google 的云盘里买了个新书架，贴个条叫“CTF隐写术知识库”，准备专门放这类书。</li></ul><p><strong>5. 上传与索引</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>operation <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>file_search_stores<span style=color:#f92672>.</span>upload_to_file_search_store(
</span></span><span style=display:flex><span>    file<span style=color:#f92672>=</span>pdf_path,
</span></span><span style=display:flex><span>    file_search_store_name<span style=color:#f92672>=</span>file_search_store<span style=color:#f92672>.</span>name,
</span></span><span style=display:flex><span>    config<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#39;display_name&#39;</span>: <span style=color:#e6db74>&#39;CTF隐写术.pdf&#39;</span>}
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：调用上传接口。注意这里返回的是一个 operation（异步操作对象），而不是结果本身，因为处理 PDF 需要时间。</li><li><strong>大白话</strong>：你把本地的 PDF 扔给 Google。因为书太厚，Google 说：“我收到了，正在处理，你拿个排队号码牌（Operation）先等着。”</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> operation<span style=color:#f92672>.</span>done:
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;.&#34;</span>, end<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>, flush<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>    operation <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>operations<span style=color:#f92672>.</span>get(operation)
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：这是一个轮询循环（Polling）。只要 operation.done 是 False，就每隔 5 秒去服务器问一次“好了没？”，并更新 operation 的状态。</li><li><strong>大白话</strong>：你每隔 5 秒就问一次学霸：“书读完了吗？”学霸说：“没呢。”你等 5 秒再问：“读完了吗？”……直到学霸说：“读完了！”循环结束。</li></ul><p><strong>6. 提问（RAG 核心）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>model <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;gemini-2.5-flash&#34;</span>
</span></span><span style=display:flex><span>question <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;这篇文章里提到的隐写术工具有哪些？...&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>response <span style=color:#f92672>=</span> client<span style=color:#f92672>.</span>models<span style=color:#f92672>.</span>generate_content(
</span></span><span style=display:flex><span>    model<span style=color:#f92672>=</span>model,
</span></span><span style=display:flex><span>    contents<span style=color:#f92672>=</span>question,
</span></span><span style=display:flex><span>    config<span style=color:#f92672>=</span>types<span style=color:#f92672>.</span>GenerateContentConfig(
</span></span><span style=display:flex><span>        tools<span style=color:#f92672>=</span>[
</span></span><span style=display:flex><span>            types<span style=color:#f92672>.</span>Tool(
</span></span><span style=display:flex><span>                file_search<span style=color:#f92672>=</span>types<span style=color:#f92672>.</span>FileSearch(
</span></span><span style=display:flex><span>                    file_search_store_names<span style=color:#f92672>=</span>[file_search_store<span style=color:#f92672>.</span>name]
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：调用生成接口。<ul><li>model: 指定使用的模型版本（Flash 版速度快成本低）。</li><li>contents: 用户的提示词。</li><li>tools: 关键点！在这里挂载了 file_search 工具，并指定了刚才那个 store（书架）。这告诉模型：你可以（且应该）去查阅这个书架里的内容来回答。</li></ul></li><li><strong>大白话</strong>：你正式向学霸提问。同时你把刚才那个书架的钥匙交给他，叮嘱道：“回答这个问题时，必须去那个书架上翻翻那本书，别光靠脑补。”</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>print(response<span style=color:#f92672>.</span>text)
</span></span></code></pre></div><ul><li><strong>语法解读</strong>：打印模型返回的文本内容。</li><li><strong>大白话</strong>：学霸把总结好的答案写在纸上递给你，你把它念了出来。</li></ul><p><strong>发微博总结（复制即可）</strong></p><p>想做一个<strong>私有知识库 AI 助手</strong>其实只需 50 行代码！🐍✨</p><p>利用 Google 最新的 Gemini 2.5 Flash 模型 + File Search API，这段 Python 脚本实现了：
1️⃣ <strong>自动翻墙</strong>：内置硬核代理配置，专治各种连接超时。
2️⃣ <strong>云端大脑</strong>：自动上传 PDF 到 Google 向量库，让 AI 像读过书一样理解文档。
3️⃣ <strong>精准问答</strong>：不是瞎聊，而是基于文档内容的 RAG（检索增强生成），准确列出书里的工具、数据和细节！</p><h2 id=六其他补充>六、其他(补充)<a hidden class=anchor aria-hidden=true href=#六其他补充>#</a></h2><h3 id=1什么是嵌入模型embedding-model>1、什么是嵌入模型**（Embedding Model）**<a hidden class=anchor aria-hidden=true href=#1什么是嵌入模型embedding-model>#</a></h3><h4 id=1-直观理解它是什么>1. 直观理解：它是什么？<a hidden class=anchor aria-hidden=true href=#1-直观理解它是什么>#</a></h4><p>想象你现在面对着那本77页的大疆无人机说明书。</p><ul><li><strong>生成式 AI 模型（如 Gemini Pro, GPT-4）</strong>：它像一个**“博学的教授”**。它能读懂文字，能思考，能组织语言，能回答你的问题。但是，如果你把77页的书直接甩给它，它读起来很慢，而且很贵（按字数收费）。</li><li><strong>嵌入式模型（Embedding Model）</strong>：它像一个**“图书管理员”<strong>。它</strong>不会说话**，也不会写文章。它的工作只有一个：<strong>把文字变成坐标（数字）</strong>。</li></ul><h4 id=2-它和ai大模型有什么区别>2. 它和“AI大模型”有什么区别？<a hidden class=anchor aria-hidden=true href=#2-它和ai大模型有什么区别>#</a></h4><p>这是最关键的部分，它们的<strong>输入</strong>可能一样（都是文字），但<strong>输出</strong>和<strong>任务</strong>完全不同：</p><table><thead><tr><th>特性</th><th><strong>嵌入模型 (Embedding Model)</strong></th><th><strong>生成式 AI 模型 (LLM)</strong></th></tr></thead><tbody><tr><td><strong>形象比喻</strong></td><td><strong>图书管理员 / 翻译官</strong></td><td><strong>作家 / 教授</strong></td></tr><tr><td><strong>输出结果</strong></td><td><strong>一串数字</strong>（比如 [0.1, -0.5, 0.9&mldr;]）</td><td><strong>一段人类语言</strong>（“你好，今天是晴天&mldr;”）</td></tr><tr><td><strong>核心能力</strong></td><td><strong>理解“含义”的相似度</strong></td><td><strong>逻辑推理、语言组织、创作</strong></td></tr><tr><td><strong>计算速度</strong></td><td>极快</td><td>较慢</td></tr><tr><td><strong>费用</strong></td><td>很便宜（甚至是LLM的千分之一）</td><td>较贵</td></tr></tbody></table><h4 id=3-它具体做了哪些事情技术原理>3. 它具体做了哪些事情？（技术原理）<a hidden class=anchor aria-hidden=true href=#3-它具体做了哪些事情技术原理>#</a></h4><p>嵌入模型的作用是**“将人类的语言，翻译成计算机能计算的数学坐标”**。</p><p>在计算机眼里，&ldquo;苹果"这两个字只是二进制编码。如果不通过嵌入模型，计算机不知道"苹果&rdquo;（水果）和"梨"是相似的，也不知道"苹果"（手机）和"华为"是相似的。</p><p><strong>嵌入模型做了这三步：</strong></p><ol><li><strong>语义压缩</strong>：它读入一段话（比如“无人机红灯闪烁”）。</li><li><strong>特征提取</strong>：它分析这句话的深层含义。它知道“红灯”代表“警告”，“闪烁”代表“状态”。</li><li><strong>向量化（坐标化）</strong>：它把这句话变成一个高维空间里的坐标点（向量）。</li></ol><p><strong>举个神奇的例子：</strong>
在这个数学空间里，嵌入模型能做到：</p><ul><li><strong>国王 - 男人 + 女人 = 女王</strong>
（它通过数字计算，理解了词语之间的逻辑关系！）</li></ul><h4 id=4-为什么-rag知识库非要用它>4. 为什么 RAG（知识库）非要用它？<a hidden class=anchor aria-hidden=true href=#4-为什么-rag知识库非要用它>#</a></h4><p>回到视频里的场景，为什么不直接让Gemini大模型去搜那77页文档？</p><p><strong>没有嵌入模型时的笨办法（全文搜索）：</strong>
你搜“红灯闪烁”，传统的搜索（关键词匹配）只能去文档里找哪里出现了“红灯”和“闪烁”这两个词。如果文档里写的是“指示灯红色频闪”，传统搜索可能就<strong>找不到</strong>了，因为字不一样。</p><p><strong>有了嵌入模型后的聪明办法（语义检索）：</strong></p><ol><li><strong>存入时</strong>：嵌入模型把文档里的“指示灯红色频闪”这句话，变成了一个<strong>数学坐标 A</strong>。</li><li><strong>提问时</strong>：你问“红灯为啥亮了？”，嵌入模型把你的问题变成了<strong>数学坐标 B</strong>。</li><li><strong>找答案</strong>：计算机发现，<strong>坐标 A</strong> 和 <strong>坐标 B</strong> 在空间里靠得非常近（哪怕字面上没有一个字是一样的，意思却很近）。</li><li><strong>结果</strong>：系统迅速把这句话提取出来，扔给Gemini大模型去组织语言回答你。</li></ol><h4 id=5-总结它的存在意义>5. 总结：它的存在意义<a hidden class=anchor aria-hidden=true href=#5-总结它的存在意义>#</a></h4><p>嵌入式模型存在的最大意义是：<strong>它让计算机懂得了“语义的远近”</strong>。</p><ul><li><strong>没有它</strong>：计算机只能做“找同字”的机械匹配。</li><li><strong>有了它</strong>：计算机能做“找同义”的智能检索。</li></ul><p>所以，在 RAG 流程里：</p><ol><li><strong>嵌入模型</strong>负责**“找”**（快速、便宜、懂语义）。</li><li><strong>AI大模型</strong>负责**“看”和“写”**（读懂找到的内容，并写出人话）。</li></ol><h3 id=2嵌入模型返回给大模型处理的内容>2、嵌入模型返回给大模型处理的内容<a hidden class=anchor aria-hidden=true href=#2嵌入模型返回给大模型处理的内容>#</a></h3><p>简单来说，<strong>嵌入模型（图书管理员）</strong> 找到书以后，并不是直接把书扔给用户，而是把书里<strong>最关键的那几页撕下来</strong>，和<strong>用户的问题</strong>打包在一起，组成一个**“超级提示词大礼包”**，最后发给 <strong>AI 大模型（教授）</strong>。</p><p>具体来说，回给 AI 大模型处理的“这一包东西”，通常包含 <strong>三个部分</strong>（就像一个三明治）：</p><p><strong>第一部分：系统指令（System Prompt）——“你是谁，你要干什么”</strong></p><p>这是给 AI 立规矩的。在代码里，开发者会偷偷塞给 AI 一段话，用户通常看不见。</p><ul><li><p><strong>内容示例</strong>：</p><blockquote><p>“你是一个大疆无人机的智能客服助手。请你根据<strong>下面提供的参考资料</strong>来回答用户的问题。如果参考资料里没有答案，就说不知道，严禁自己瞎编。”</p></blockquote></li></ul><p><strong>第二部分：检索到的“上下文片段”（Context/Chunks）——“参考资料”</strong></p><p>这是<strong>最核心</strong>的部分！
嵌入模型刚才辛苦工作，从77页的文档里，找出了和“红灯闪烁”最相关的<strong>3-5段话</strong>（也许是第12页的第2段，和第15页的第1段）。
系统会把这几段<strong>原文</strong>直接复制粘贴到这里。</p><ul><li><p><strong>内容示例</strong>：</p><blockquote><p><strong>参考资料片段1</strong>：&mldr;当飞行器电池电量严重不足时，状态指示灯会快速闪烁红灯&mldr;
<strong>参考资料片段2</strong>：&mldr;如果指南针受到干扰，指示灯可能会红黄交替闪烁&mldr;</p></blockquote></li></ul><p><strong>第三部分：用户的原始提问（User Query）——“考试题目”</strong></p><p>最后才是用户真正输入的那句话。</p><ul><li><p><strong>内容示例</strong>：</p><blockquote><p><strong>用户问</strong>：“我的无人机红灯一直闪是怎么回事？”</p></blockquote></li></ul><hr><h4 id=总结ai-大模型实际看到的完整考卷>总结：AI 大模型实际看到的“完整考卷”<a hidden class=anchor aria-hidden=true href=#总结ai-大模型实际看到的完整考卷>#</a></h4><p>所以，当你问了一句“红灯闪是怎么回事？”时，<strong>AI 大模型实际收到的输入（Input）</strong> 是下面这一长串东西：</p><p>codeText</p><pre tabindex=0><code>【系统指令】：你是一个助手，请根据以下资料回答问题。

【参考资料】：
1. 当飞行器电池电量严重不足时，状态指示灯会快速闪烁红灯...
2. 严重低电量报警触发时，飞机将强制降落...

【用户问题】：我的无人机红灯一直闪是怎么回事？

【回答要求】：请用通俗易懂的语言回答。
</code></pre><h3 id=3元数据过滤metadata-filtering>3、“元数据过滤”（Metadata Filtering）<a hidden class=anchor aria-hidden=true href=#3元数据过滤metadata-filtering>#</a></h3><p><strong>“元数据过滤”（Metadata Filtering）</strong></p><ul><li><strong>我之前没强调的</strong>：我之前只说了它能“搜内容”。</li><li><strong>文档新发现</strong>：Gemini File Search 支持<strong>元数据过滤</strong>。</li><li><strong>这是什么？</strong>：以前RAG是“在大海里捞针”。现在你可以告诉它“只在<strong>2023年之后</strong>的文件里捞”或者“只在<strong>财务部</strong>的文件里捞”。</li><li><strong>作用</strong>：这能极大地提高准确率，防止搜到过期的旧文档（比如搜到了2020年的旧版大疆手册）。</li></ul><p><strong>技术流程修正：是“Vector Store”而不是简单的“数据存储”</strong></p><ul><li><strong>流程修正</strong>：在代码实现上，Google 引入了一个明确的概念叫 <strong>Vector Store（向量仓库）</strong>。<ul><li>你不能直接把文件扔给模型。</li><li><strong>正确流程是</strong>：上传文件 -> 创建一个 Vector Store -> 把文件扔进这个 Store -> 把 Store 绑定给模型。</li><li>这个 Vector Store 是可以<strong>复用</strong>的。你不用每次聊天都重新传文件，建好一次，以后一直用ID调用即可。</li></ul></li></ul><h3 id=4api-rag功能和web端的gemini的区别存在的意义>4、api rag功能和web端的gemini的区别，存在的意义<a hidden class=anchor aria-hidden=true href=#4api-rag功能和web端的gemini的区别存在的意义>#</a></h3><ol><li><strong>Web端（Gemini 网页版）</strong>：<ul><li>当你上传 PDF 到网页版时，Google <strong>后台</strong> 其实也在做类似的事情：解析文件 -> 提取内容 -> 放入临时的上下文窗口或临时索引。</li><li>它<strong>自动</strong>就有了搜索文档的能力。你不需要设置什么“File Search Tool”，因为那是给普通用户用的，Google 把这些技术细节都<strong>隐藏</strong>起来了。</li><li><strong>但是</strong>：网页版的“记忆”通常是<strong>临时</strong>的。你关掉网页，或者过几天，它可能就忘了那个文件，或者你需要重新传。而且网页版不能让你把这个功能塞到你自己的 App 里去卖钱。</li></ul></li><li><strong>API端（我们刚才写的代码）</strong>：<ul><li>这是<strong>手动挡</strong>。你需要显式地告诉它“创建一个Store”、“把文件放进去”。</li><li><strong>区别</strong>：<ul><li><strong>持久化</strong>：用代码创建的 Vector Store 是<strong>永久</strong>存在的（除非你删了）。你今天传上去，下个月写代码直接调这个 Store 的 ID，它还能回答，不用重新传。</li><li><strong>规模化</strong>：网页版你传 100 个文件可能就卡死了。API 版你可以传 10,000 个文件进知识库。</li><li><strong>可集成</strong>：你可以把这个功能做成一个微信小程序、一个公司内部软件，这就是 API 的意义。</li></ul></li></ul></li></ol><p><strong>总结</strong>：
你在网页版上传文件，确实是在使用类似的“文档理解能力”，体验上就是“自动有了”。
但我们学这个 API，是为了<strong>把这种能力变成你自己的软件功能</strong>，而不仅仅是当一个用户去聊天。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/google/>Google</a></li><li><a href=http://ljj1992.fun/tags/%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90/>检索增强生成</a></li><li><a href=http://ljj1992.fun/tags/rag/>RAG</a></li><li><a href=http://ljj1992.fun/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/>人工智能</a></li><li><a href=http://ljj1992.fun/tags/gemini-api-file-search/>Gemini API File Search</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>