<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>观察者模式(YouTuber订阅) | star徐的博客</title><meta name=keywords content="Java,观察者模式,Web开发,编程"><meta name=description content='观察者模式(YouTuber订阅)
一、观察者模式到底是干嘛的？为什么会有人发明它？
想象一下现实生活中的场景：
你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。
这里的关键问题就是：
“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”
如果没有观察者模式，我们会怎么做？最笨的办法：

老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知；
或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。

这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。
观察者模式解决的核心痛点：

解耦：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。
一对多依赖：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。
动态订阅/退订：粉丝可以随时订阅、随时取关，主题完全不关心。
松耦合：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。

一句话总结： 当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。
二、经典使用场景（你以后一定会遇到）

聊天软件：有人发消息，所有在线好友收到通知
股票软件：股价变动，所有关注这只股票的人收到推送
GUI界面：点击按钮，所有注册了点击事件的监听器执行
消息队列、事件总线（EventBus）
Vue/React 中的数据响应式（本质也是观察者）
Python 中的信号槽（PyQt/PySide）、Java 中的 Listener

三、用大白话理解观察者模式的四个核心角色

  
      
          角色
          现实中对应
          代码中对应
          职责
      
  
  
      
          Subject（主题）
          YouTuber
          Youtuber 类
          维护订阅者列表，提供 attach/detach/notify 方法
      
      
          Observer（观察者接口）
          “订阅后必须能收到通知”这个约定
          Observer 抽象类
          定义 update 方法
      
      
          ConcreteObserver（具体观察者）
          具体的粉丝小明、小红
          Fan 类
          实现 update，真正干活的地方
      
      
          Client（客户代码）
          我们写的主程序
          最后的运行逻辑
          创建对象、订阅、触发通知
      
  

四、代码分析
# -------------------------------------------------
# 步骤1：定义“主题”（Youtuber）
# -------------------------------------------------
class Youtuber:                                           # 定义一个类，名叫 Youtuber，代表“被订阅的对象”
    def __init__(self, name):                             # 构造函数，创建对象时自动执行
        self.name = name                                  # 给这个YouTuber起个名字，比如“老王”
        self._observers = []  # 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问
                                                          # [] 表示创建一个空列表，用来装所有粉丝对象

    def attach(self, observer):                           # “订阅”方法，参数 observer 就是一个粉丝对象
        """添加一个观察者（订阅）"""
        if observer not in self._observers:               # 判断这个粉丝是否已经订阅过，防止重复
            self._observers.append(observer)              # append 是列表的内置方法，把粉丝对象加到列表末尾
            print(f"[{observer.name}] 订阅了 [{self.name}]")  # 打印一条提示信息

    def detach(self, observer):                           # “取消订阅”方法
        """移除一个观察者（取消订阅）"""
        try:
            self._observers.remove(observer)              # remove 是列表的内置方法，直接删除这个对象
            print(f"[{observer.name}] 取消订阅了 [{self.name}]")
        except ValueError:                                # 如果列表里根本没有这个对象，remove 会报错
            pass                                          # 我们选择忽略这个错误，什么都不做

    def notify(self, video_title):                        # 最最重要的“发布视频”方法，也就是状态发生变化
        """通知所有观察者"""
        print(f"\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...")
        for observer in self._observers:                  # 遍历当前所有的粉丝对象
            observer.update(self.name, video_title)       # **核心中的核心！**
                                                          # 调用每个粉丝的 update 方法，把视频信息告诉他
# -------------------------------------------------
# 步骤2：定义“观察者”模板和具体观察者（粉丝）
# -------------------------------------------------
from abc import ABC, abstractmethod                     # 从 abc 模块导入工具，用来创建抽象类

class Observer(ABC):                                    # 定义一个抽象基类（模板），所有观察者都必须遵守
    @abstractmethod                                     # 装饰器：表示下面的方法是“抽象方法”，子类必须实现
    def update(self, youtuber_name, video_title):       # 抽象方法，只定义签名，不写具体内容
        pass                                            # pass 表示“占个位置，啥也不干”

class Fan(Observer):                                    # Fan 类继承 Observer，代表具体的粉丝
    def __init__(self, name):
        self.name = name                                # 每个粉丝也有自己的名字

    def update(self, youtuber_name, video_title):       # 必须实现父类的抽象方法，否则会报错
        """当收到通知时，粉丝的反应"""
        print(f"  -> 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]")
        # 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等
# -------------------------------------------------
# 步骤3：运行逻辑（真正看到效果的地方）
# -------------------------------------------------
# 1. 创建主题和观察者
youtuber_A = Youtuber("老王")                           # 创建一个YouTuber，名字叫“老王”
fan_1 = Fan("小明")                                     # 创建三个粉丝对象
fan_2 = Fan("小红")
fan_3 = Fan("小刚")

# 2. 观察者“订阅”主题
youtuber_A.attach(fan_1)                                # 小明和小红先订阅
youtuber_A.attach(fan_2)

# 3. 主题发布新内容（状态变更）
youtuber_A.notify("观察者模式入门")                     # 老王发第一条视频，只有小明和小红收到

# 4. 另一个粉丝也订阅了
youtuber_A.attach(fan_3)                                # 小刚中途订阅

# 5. 小红取消订阅
youtuber_A.detach(fan_2)                                # 小红取关

# 6. 主题再次发布新内容
youtuber_A.notify("工厂模式yyds")                       # 老王再发一条视频，只有小明和小刚收到
运行后你会看到输出：'><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="观察者模式(YouTuber订阅)"><meta property="og:description" content='观察者模式(YouTuber订阅) 一、观察者模式到底是干嘛的？为什么会有人发明它？ 想象一下现实生活中的场景：
你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。
这里的关键问题就是：
“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”
如果没有观察者模式，我们会怎么做？最笨的办法：
老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知； 或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。 这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。
观察者模式解决的核心痛点： 解耦：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。 一对多依赖：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。 动态订阅/退订：粉丝可以随时订阅、随时取关，主题完全不关心。 松耦合：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。 一句话总结： 当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。
二、经典使用场景（你以后一定会遇到） 聊天软件：有人发消息，所有在线好友收到通知 股票软件：股价变动，所有关注这只股票的人收到推送 GUI界面：点击按钮，所有注册了点击事件的监听器执行 消息队列、事件总线（EventBus） Vue/React 中的数据响应式（本质也是观察者） Python 中的信号槽（PyQt/PySide）、Java 中的 Listener 三、用大白话理解观察者模式的四个核心角色 角色 现实中对应 代码中对应 职责 Subject（主题） YouTuber Youtuber 类 维护订阅者列表，提供 attach/detach/notify 方法 Observer（观察者接口） “订阅后必须能收到通知”这个约定 Observer 抽象类 定义 update 方法 ConcreteObserver（具体观察者） 具体的粉丝小明、小红 Fan 类 实现 update，真正干活的地方 Client（客户代码） 我们写的主程序 最后的运行逻辑 创建对象、订阅、触发通知 四、代码分析 # ------------------------------------------------- # 步骤1：定义“主题”（Youtuber） # ------------------------------------------------- class Youtuber: # 定义一个类，名叫 Youtuber，代表“被订阅的对象” def __init__(self, name): # 构造函数，创建对象时自动执行 self.name = name # 给这个YouTuber起个名字，比如“老王” self._observers = [] # 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问 # [] 表示创建一个空列表，用来装所有粉丝对象 def attach(self, observer): # “订阅”方法，参数 observer 就是一个粉丝对象 """添加一个观察者（订阅）""" if observer not in self._observers: # 判断这个粉丝是否已经订阅过，防止重复 self._observers.append(observer) # append 是列表的内置方法，把粉丝对象加到列表末尾 print(f"[{observer.name}] 订阅了 [{self.name}]") # 打印一条提示信息 def detach(self, observer): # “取消订阅”方法 """移除一个观察者（取消订阅）""" try: self._observers.remove(observer) # remove 是列表的内置方法，直接删除这个对象 print(f"[{observer.name}] 取消订阅了 [{self.name}]") except ValueError: # 如果列表里根本没有这个对象，remove 会报错 pass # 我们选择忽略这个错误，什么都不做 def notify(self, video_title): # 最最重要的“发布视频”方法，也就是状态发生变化 """通知所有观察者""" print(f"\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...") for observer in self._observers: # 遍历当前所有的粉丝对象 observer.update(self.name, video_title) # **核心中的核心！** # 调用每个粉丝的 update 方法，把视频信息告诉他 # ------------------------------------------------- # 步骤2：定义“观察者”模板和具体观察者（粉丝） # ------------------------------------------------- from abc import ABC, abstractmethod # 从 abc 模块导入工具，用来创建抽象类 class Observer(ABC): # 定义一个抽象基类（模板），所有观察者都必须遵守 @abstractmethod # 装饰器：表示下面的方法是“抽象方法”，子类必须实现 def update(self, youtuber_name, video_title): # 抽象方法，只定义签名，不写具体内容 pass # pass 表示“占个位置，啥也不干” class Fan(Observer): # Fan 类继承 Observer，代表具体的粉丝 def __init__(self, name): self.name = name # 每个粉丝也有自己的名字 def update(self, youtuber_name, video_title): # 必须实现父类的抽象方法，否则会报错 """当收到通知时，粉丝的反应""" print(f" -> 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]") # 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等 # ------------------------------------------------- # 步骤3：运行逻辑（真正看到效果的地方） # ------------------------------------------------- # 1. 创建主题和观察者 youtuber_A = Youtuber("老王") # 创建一个YouTuber，名字叫“老王” fan_1 = Fan("小明") # 创建三个粉丝对象 fan_2 = Fan("小红") fan_3 = Fan("小刚") # 2. 观察者“订阅”主题 youtuber_A.attach(fan_1) # 小明和小红先订阅 youtuber_A.attach(fan_2) # 3. 主题发布新内容（状态变更） youtuber_A.notify("观察者模式入门") # 老王发第一条视频，只有小明和小红收到 # 4. 另一个粉丝也订阅了 youtuber_A.attach(fan_3) # 小刚中途订阅 # 5. 小红取消订阅 youtuber_A.detach(fan_2) # 小红取关 # 6. 主题再次发布新内容 youtuber_A.notify("工厂模式yyds") # 老王再发一条视频，只有小明和小刚收到 运行后你会看到输出：'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-20T12:00:00+08:00"><meta property="article:modified_time" content="2025-11-20T12:00:00+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="观察者模式"><meta property="article:tag" content="Web开发"><meta property="article:tag" content="编程"><meta name=twitter:card content="summary"><meta name=twitter:title content="观察者模式(YouTuber订阅)"><meta name=twitter:description content='观察者模式(YouTuber订阅)
一、观察者模式到底是干嘛的？为什么会有人发明它？
想象一下现实生活中的场景：
你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。
这里的关键问题就是：
“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”
如果没有观察者模式，我们会怎么做？最笨的办法：

老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知；
或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。

这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。
观察者模式解决的核心痛点：

解耦：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。
一对多依赖：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。
动态订阅/退订：粉丝可以随时订阅、随时取关，主题完全不关心。
松耦合：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。

一句话总结： 当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。
二、经典使用场景（你以后一定会遇到）

聊天软件：有人发消息，所有在线好友收到通知
股票软件：股价变动，所有关注这只股票的人收到推送
GUI界面：点击按钮，所有注册了点击事件的监听器执行
消息队列、事件总线（EventBus）
Vue/React 中的数据响应式（本质也是观察者）
Python 中的信号槽（PyQt/PySide）、Java 中的 Listener

三、用大白话理解观察者模式的四个核心角色

  
      
          角色
          现实中对应
          代码中对应
          职责
      
  
  
      
          Subject（主题）
          YouTuber
          Youtuber 类
          维护订阅者列表，提供 attach/detach/notify 方法
      
      
          Observer（观察者接口）
          “订阅后必须能收到通知”这个约定
          Observer 抽象类
          定义 update 方法
      
      
          ConcreteObserver（具体观察者）
          具体的粉丝小明、小红
          Fan 类
          实现 update，真正干活的地方
      
      
          Client（客户代码）
          我们写的主程序
          最后的运行逻辑
          创建对象、订阅、触发通知
      
  

四、代码分析
# -------------------------------------------------
# 步骤1：定义“主题”（Youtuber）
# -------------------------------------------------
class Youtuber:                                           # 定义一个类，名叫 Youtuber，代表“被订阅的对象”
    def __init__(self, name):                             # 构造函数，创建对象时自动执行
        self.name = name                                  # 给这个YouTuber起个名字，比如“老王”
        self._observers = []  # 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问
                                                          # [] 表示创建一个空列表，用来装所有粉丝对象

    def attach(self, observer):                           # “订阅”方法，参数 observer 就是一个粉丝对象
        """添加一个观察者（订阅）"""
        if observer not in self._observers:               # 判断这个粉丝是否已经订阅过，防止重复
            self._observers.append(observer)              # append 是列表的内置方法，把粉丝对象加到列表末尾
            print(f"[{observer.name}] 订阅了 [{self.name}]")  # 打印一条提示信息

    def detach(self, observer):                           # “取消订阅”方法
        """移除一个观察者（取消订阅）"""
        try:
            self._observers.remove(observer)              # remove 是列表的内置方法，直接删除这个对象
            print(f"[{observer.name}] 取消订阅了 [{self.name}]")
        except ValueError:                                # 如果列表里根本没有这个对象，remove 会报错
            pass                                          # 我们选择忽略这个错误，什么都不做

    def notify(self, video_title):                        # 最最重要的“发布视频”方法，也就是状态发生变化
        """通知所有观察者"""
        print(f"\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...")
        for observer in self._observers:                  # 遍历当前所有的粉丝对象
            observer.update(self.name, video_title)       # **核心中的核心！**
                                                          # 调用每个粉丝的 update 方法，把视频信息告诉他
# -------------------------------------------------
# 步骤2：定义“观察者”模板和具体观察者（粉丝）
# -------------------------------------------------
from abc import ABC, abstractmethod                     # 从 abc 模块导入工具，用来创建抽象类

class Observer(ABC):                                    # 定义一个抽象基类（模板），所有观察者都必须遵守
    @abstractmethod                                     # 装饰器：表示下面的方法是“抽象方法”，子类必须实现
    def update(self, youtuber_name, video_title):       # 抽象方法，只定义签名，不写具体内容
        pass                                            # pass 表示“占个位置，啥也不干”

class Fan(Observer):                                    # Fan 类继承 Observer，代表具体的粉丝
    def __init__(self, name):
        self.name = name                                # 每个粉丝也有自己的名字

    def update(self, youtuber_name, video_title):       # 必须实现父类的抽象方法，否则会报错
        """当收到通知时，粉丝的反应"""
        print(f"  -> 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]")
        # 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等
# -------------------------------------------------
# 步骤3：运行逻辑（真正看到效果的地方）
# -------------------------------------------------
# 1. 创建主题和观察者
youtuber_A = Youtuber("老王")                           # 创建一个YouTuber，名字叫“老王”
fan_1 = Fan("小明")                                     # 创建三个粉丝对象
fan_2 = Fan("小红")
fan_3 = Fan("小刚")

# 2. 观察者“订阅”主题
youtuber_A.attach(fan_1)                                # 小明和小红先订阅
youtuber_A.attach(fan_2)

# 3. 主题发布新内容（状态变更）
youtuber_A.notify("观察者模式入门")                     # 老王发第一条视频，只有小明和小红收到

# 4. 另一个粉丝也订阅了
youtuber_A.attach(fan_3)                                # 小刚中途订阅

# 5. 小红取消订阅
youtuber_A.detach(fan_2)                                # 小红取关

# 6. 主题再次发布新内容
youtuber_A.notify("工厂模式yyds")                       # 老王再发一条视频，只有小明和小刚收到
运行后你会看到输出：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"观察者模式(YouTuber订阅)","item":"http://ljj1992.fun/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"观察者模式(YouTuber订阅)","name":"观察者模式(YouTuber订阅)","description":"观察者模式(YouTuber订阅) 一、观察者模式到底是干嘛的？为什么会有人发明它？ 想象一下现实生活中的场景：\n你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。\n这里的关键问题就是：\n“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”\n如果没有观察者模式，我们会怎么做？最笨的办法：\n老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知； 或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。 这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。\n观察者模式解决的核心痛点： 解耦：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。 一对多依赖：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。 动态订阅/退订：粉丝可以随时订阅、随时取关，主题完全不关心。 松耦合：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。 一句话总结： 当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。\n二、经典使用场景（你以后一定会遇到） 聊天软件：有人发消息，所有在线好友收到通知 股票软件：股价变动，所有关注这只股票的人收到推送 GUI界面：点击按钮，所有注册了点击事件的监听器执行 消息队列、事件总线（EventBus） Vue/React 中的数据响应式（本质也是观察者） Python 中的信号槽（PyQt/PySide）、Java 中的 Listener 三、用大白话理解观察者模式的四个核心角色 角色 现实中对应 代码中对应 职责 Subject（主题） YouTuber Youtuber 类 维护订阅者列表，提供 attach/detach/notify 方法 Observer（观察者接口） “订阅后必须能收到通知”这个约定 Observer 抽象类 定义 update 方法 ConcreteObserver（具体观察者） 具体的粉丝小明、小红 Fan 类 实现 update，真正干活的地方 Client（客户代码） 我们写的主程序 最后的运行逻辑 创建对象、订阅、触发通知 四、代码分析 # ------------------------------------------------- # 步骤1：定义“主题”（Youtuber） # ------------------------------------------------- class Youtuber: # 定义一个类，名叫 Youtuber，代表“被订阅的对象” def __init__(self, name): # 构造函数，创建对象时自动执行 self.name = name # 给这个YouTuber起个名字，比如“老王” self._observers = [] # 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问 # [] 表示创建一个空列表，用来装所有粉丝对象 def attach(self, observer): # “订阅”方法，参数 observer 就是一个粉丝对象 \u0026#34;\u0026#34;\u0026#34;添加一个观察者（订阅）\u0026#34;\u0026#34;\u0026#34; if observer not in self._observers: # 判断这个粉丝是否已经订阅过，防止重复 self._observers.append(observer) # append 是列表的内置方法，把粉丝对象加到列表末尾 print(f\u0026#34;[{observer.name}] 订阅了 [{self.name}]\u0026#34;) # 打印一条提示信息 def detach(self, observer): # “取消订阅”方法 \u0026#34;\u0026#34;\u0026#34;移除一个观察者（取消订阅）\u0026#34;\u0026#34;\u0026#34; try: self._observers.remove(observer) # remove 是列表的内置方法，直接删除这个对象 print(f\u0026#34;[{observer.name}] 取消订阅了 [{self.name}]\u0026#34;) except ValueError: # 如果列表里根本没有这个对象，remove 会报错 pass # 我们选择忽略这个错误，什么都不做 def notify(self, video_title): # 最最重要的“发布视频”方法，也就是状态发生变化 \u0026#34;\u0026#34;\u0026#34;通知所有观察者\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;\\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...\u0026#34;) for observer in self._observers: # 遍历当前所有的粉丝对象 observer.update(self.name, video_title) # **核心中的核心！** # 调用每个粉丝的 update 方法，把视频信息告诉他 # ------------------------------------------------- # 步骤2：定义“观察者”模板和具体观察者（粉丝） # ------------------------------------------------- from abc import ABC, abstractmethod # 从 abc 模块导入工具，用来创建抽象类 class Observer(ABC): # 定义一个抽象基类（模板），所有观察者都必须遵守 @abstractmethod # 装饰器：表示下面的方法是“抽象方法”，子类必须实现 def update(self, youtuber_name, video_title): # 抽象方法，只定义签名，不写具体内容 pass # pass 表示“占个位置，啥也不干” class Fan(Observer): # Fan 类继承 Observer，代表具体的粉丝 def __init__(self, name): self.name = name # 每个粉丝也有自己的名字 def update(self, youtuber_name, video_title): # 必须实现父类的抽象方法，否则会报错 \u0026#34;\u0026#34;\u0026#34;当收到通知时，粉丝的反应\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34; -\u0026gt; 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]\u0026#34;) # 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等 # ------------------------------------------------- # 步骤3：运行逻辑（真正看到效果的地方） # ------------------------------------------------- # 1. 创建主题和观察者 youtuber_A = Youtuber(\u0026#34;老王\u0026#34;) # 创建一个YouTuber，名字叫“老王” fan_1 = Fan(\u0026#34;小明\u0026#34;) # 创建三个粉丝对象 fan_2 = Fan(\u0026#34;小红\u0026#34;) fan_3 = Fan(\u0026#34;小刚\u0026#34;) # 2. 观察者“订阅”主题 youtuber_A.attach(fan_1) # 小明和小红先订阅 youtuber_A.attach(fan_2) # 3. 主题发布新内容（状态变更） youtuber_A.notify(\u0026#34;观察者模式入门\u0026#34;) # 老王发第一条视频，只有小明和小红收到 # 4. 另一个粉丝也订阅了 youtuber_A.attach(fan_3) # 小刚中途订阅 # 5. 小红取消订阅 youtuber_A.detach(fan_2) # 小红取关 # 6. 主题再次发布新内容 youtuber_A.notify(\u0026#34;工厂模式yyds\u0026#34;) # 老王再发一条视频，只有小明和小刚收到 运行后你会看到输出：\n","keywords":["Java","观察者模式","Web开发","编程"],"articleBody":"观察者模式(YouTuber订阅) 一、观察者模式到底是干嘛的？为什么会有人发明它？ 想象一下现实生活中的场景：\n你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。\n这里的关键问题就是：\n“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”\n如果没有观察者模式，我们会怎么做？最笨的办法：\n老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知； 或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。 这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。\n观察者模式解决的核心痛点： 解耦：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。 一对多依赖：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。 动态订阅/退订：粉丝可以随时订阅、随时取关，主题完全不关心。 松耦合：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。 一句话总结： 当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。\n二、经典使用场景（你以后一定会遇到） 聊天软件：有人发消息，所有在线好友收到通知 股票软件：股价变动，所有关注这只股票的人收到推送 GUI界面：点击按钮，所有注册了点击事件的监听器执行 消息队列、事件总线（EventBus） Vue/React 中的数据响应式（本质也是观察者） Python 中的信号槽（PyQt/PySide）、Java 中的 Listener 三、用大白话理解观察者模式的四个核心角色 角色 现实中对应 代码中对应 职责 Subject（主题） YouTuber Youtuber 类 维护订阅者列表，提供 attach/detach/notify 方法 Observer（观察者接口） “订阅后必须能收到通知”这个约定 Observer 抽象类 定义 update 方法 ConcreteObserver（具体观察者） 具体的粉丝小明、小红 Fan 类 实现 update，真正干活的地方 Client（客户代码） 我们写的主程序 最后的运行逻辑 创建对象、订阅、触发通知 四、代码分析 # ------------------------------------------------- # 步骤1：定义“主题”（Youtuber） # ------------------------------------------------- class Youtuber: # 定义一个类，名叫 Youtuber，代表“被订阅的对象” def __init__(self, name): # 构造函数，创建对象时自动执行 self.name = name # 给这个YouTuber起个名字，比如“老王” self._observers = [] # 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问 # [] 表示创建一个空列表，用来装所有粉丝对象 def attach(self, observer): # “订阅”方法，参数 observer 就是一个粉丝对象 \"\"\"添加一个观察者（订阅）\"\"\" if observer not in self._observers: # 判断这个粉丝是否已经订阅过，防止重复 self._observers.append(observer) # append 是列表的内置方法，把粉丝对象加到列表末尾 print(f\"[{observer.name}] 订阅了 [{self.name}]\") # 打印一条提示信息 def detach(self, observer): # “取消订阅”方法 \"\"\"移除一个观察者（取消订阅）\"\"\" try: self._observers.remove(observer) # remove 是列表的内置方法，直接删除这个对象 print(f\"[{observer.name}] 取消订阅了 [{self.name}]\") except ValueError: # 如果列表里根本没有这个对象，remove 会报错 pass # 我们选择忽略这个错误，什么都不做 def notify(self, video_title): # 最最重要的“发布视频”方法，也就是状态发生变化 \"\"\"通知所有观察者\"\"\" print(f\"\\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...\") for observer in self._observers: # 遍历当前所有的粉丝对象 observer.update(self.name, video_title) # **核心中的核心！** # 调用每个粉丝的 update 方法，把视频信息告诉他 # ------------------------------------------------- # 步骤2：定义“观察者”模板和具体观察者（粉丝） # ------------------------------------------------- from abc import ABC, abstractmethod # 从 abc 模块导入工具，用来创建抽象类 class Observer(ABC): # 定义一个抽象基类（模板），所有观察者都必须遵守 @abstractmethod # 装饰器：表示下面的方法是“抽象方法”，子类必须实现 def update(self, youtuber_name, video_title): # 抽象方法，只定义签名，不写具体内容 pass # pass 表示“占个位置，啥也不干” class Fan(Observer): # Fan 类继承 Observer，代表具体的粉丝 def __init__(self, name): self.name = name # 每个粉丝也有自己的名字 def update(self, youtuber_name, video_title): # 必须实现父类的抽象方法，否则会报错 \"\"\"当收到通知时，粉丝的反应\"\"\" print(f\" -\u003e 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]\") # 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等 # ------------------------------------------------- # 步骤3：运行逻辑（真正看到效果的地方） # ------------------------------------------------- # 1. 创建主题和观察者 youtuber_A = Youtuber(\"老王\") # 创建一个YouTuber，名字叫“老王” fan_1 = Fan(\"小明\") # 创建三个粉丝对象 fan_2 = Fan(\"小红\") fan_3 = Fan(\"小刚\") # 2. 观察者“订阅”主题 youtuber_A.attach(fan_1) # 小明和小红先订阅 youtuber_A.attach(fan_2) # 3. 主题发布新内容（状态变更） youtuber_A.notify(\"观察者模式入门\") # 老王发第一条视频，只有小明和小红收到 # 4. 另一个粉丝也订阅了 youtuber_A.attach(fan_3) # 小刚中途订阅 # 5. 小红取消订阅 youtuber_A.detach(fan_2) # 小红取关 # 6. 主题再次发布新内容 youtuber_A.notify(\"工厂模式yyds\") # 老王再发一条视频，只有小明和小刚收到 运行后你会看到输出：\n[小明] 订阅了 [老王] [小红] 订阅了 [老王] [老王] 发布了新视频: 观察者模式入门！正在通知所有订阅者... -\u003e 粉丝 [小明] 收到了！正在打开 App 查看 [老王] 的 [观察者模式入门] -\u003e 粉丝 [小红] 收到了！正在打开 App 查看 [老王] 的 [观察者模式入门] [小刚] 订阅了 [老王] [小红] 取消订阅了 [老王] [老王] 发布了新视频: 工厂模式yyds！正在通知所有订阅者... -\u003e 粉丝 [小明] 收到了！正在打开 App 查看 [老王] 的 [工厂模式yyds] -\u003e 粉丝 [小刚] 收到了！正在打开 App 查看 [老王] 的 [工厂模式yyds] 看到了吗？老王完全不知道粉丝是谁、怎么通知，他只负责喊一声“notify”，所有当前订阅的人自动收到消息。\n五、代码逐行精讲（老师教学模式） 1. 定义“主题”（Youtuber） codePython\nclass Youtuber: def __init__(self, name): self.name = name self._observers = [] # 核心：一个“订阅者列表”，_ 开头通常表示内部使用 老师解读： class Youtuber:：我们要造一种叫“Youtuber”的事物。 def init(self, name):：这是初始化方法。当你创建一个新的 Youtuber 时，Python 会自动运行这段代码。self 代表“这个对象自己”。 self.name = name：给这个 Youtuber 起个名。 self._observers = []：这是全场最关键的一行！ [] 是一个空列表（就像一个空记事本）。 我们用它来存谁订阅了我。以后要发通知，就照着这个本子念。 变量名前面加 _ (下划线) 是 Python 程序员的约定，意思是“这是我有隐私的本子，外面的人最好不要直接乱改，要通过我提供的方法来改”。 codePython\ndef attach(self, observer): \"\"\"添加一个观察者（订阅）\"\"\" if observer not in self._observers: # 避免重复添加 self._observers.append(observer) # append 是 list 的添加方法 print(f\"[{observer.name}] 订阅了 [{self.name}]\") 老师解读： def attach：定义一个叫“关联/订阅”的动作。参数 observer 就是传进来的那个粉丝对象。 if observer not in self._observers:：先检查一下，这个粉丝是不是已经在名单里了？防止手抖点两次订阅。 self._observers.append(observer)：append 是 Python 列表的操作，意思是把这个粉丝追加到名单的末尾。 print(…)：在屏幕上打印一条消息，f\"…\" 是格式化字符串，能把变量里的值塞进句子里显示出来。 codePython\ndef detach(self, observer): \"\"\"移除一个观察者（取消订阅）\"\"\" try: self._observers.remove(observer) # remove 是 list 的移除方法 print(f\"[{observer.name}] 取消订阅了 [{self.name}]\") except ValueError: pass # 如果列表里没有，就什么都不做 老师解读： def detach：定义“取消订阅”的动作。 self._observers.remove(observer)：remove 是让 Python 在列表里找到这个粉丝，并把他擦掉。 try…except ValueError：这是异常处理。为什么要用它？因为如果你尝试删除一个根本不在名单里的人，Python 列表会报错（报错叫 ValueError）。这里意思是：“试着删一下，如果报错了（说明没这个人），就 pass（什么都不做，假装无事发生）”。 codePython\ndef notify(self, video_title): \"\"\"通知所有观察者\"\"\" print(f\"\\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...\") for observer in self._observers: # 循环“订阅者列表” observer.update(self.name, video_title) # **核心：调用观察者的 update 方法** 老师解读： def notify：这是博主的大招——发布通知。 for observer in self._observers:：这是一个循环。意思是：“把名单拿出来，从第一个人开始，一个接一个地过一遍”。每一次循环，observer 这个变量就代表当前的那个粉丝。 observer.update(…)：这是观察者模式的灵魂！ 博主不需要知道粉丝具体是谁，博主只知道：“凡是粉丝，一定有一个叫 update 的方法（接口）”。 所以博主就闭着眼睛调用每个粉丝的 update，告诉他们：“是我（self.name），我发了（video_title）”。 2. 定义“观察者”（粉丝） codePython\nclass Observer(ABC): # 观察者模板 @abstractmethod def update(self, youtuber_name, video_title): # 必须有一个 update 方法 pass 老师解读： class Observer(ABC)：定义一个抽象基类（模板）。ABC 意思是 Abstract Base Class。 @abstractmethod：这是一个“装饰器”，它像一个印章，盖在 update 方法上。 含义：这段代码在制定规则。它在说：“所有想当观察者的人，必须如果你想当粉丝，你必须学会‘接收更新’（update）这个技能。如果你不写 update 方法，我就不让你当粉丝。” pass：这里不需要写具体代码，因为这只是个规则/模板。 codePython\nclass Fan(Observer): # 具体的观察者：粉丝 def __init__(self, name): self.name = name # 粉丝有自己的名字 def update(self, youtuber_name, video_title): # 实现 update 方法 \"\"\"当收到通知时，粉丝的反应\"\"\" print(f\" -\u003e 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]\") 老师解读： class Fan(Observer)：Fan 继承自 Observer。意思是：粉丝是一种观察者，粉丝遵守观察者的规则。 def update(…)：关键点。粉丝必须具体实现（写出代码）收到通知后该干什么。 这里的逻辑是：收到通知后，打印一句话，表示我去看了。 思考：如果有另一种观察者叫 Police（网警），他的 update 方法可能就是“审查视频内容”。博主不需要改代码，只需要添加新的观察者类即可。 六、总结与应用场景 1. 观察者模式的核心原理（一句话总结） “别在一棵树上吊死，留个电话给我，有事你打给我。” （这就是好莱坞原则：Don’t call us, we’ll call you）。\n2. 适合什么场景？（什么时候用） 当出现**“一对多”**的依赖关系时，即：一个对象的状态发生了改变，所有的相关对象都必须得到通知并自动更新。\nExcel 表格：当你修改了一个单元格的数字（主题），生成的柱状图、饼图、汇总数据（观察者）都会自动变样。 股票交易软件：股票价格（主题）一跳动，K线图、账户总资产、预警系统（观察者）都要跟着变。 红绿灯：红绿灯变色（主题），路口的汽车、行人（观察者）做出停车或行走的反应。 GUI 编程（按钮点击）：你点击了一个“提交”按钮（主题），可能是表单提交数据，也可能是弹窗关闭，这些响应逻辑就是观察者。 3. 优缺点（新手须知） 优点： 解耦：博主不需要知道粉丝的任何具体细节，只管发通知。 扩展性强：想增加一种新的观察者（比如“广告商”），直接写个新类就行，不用改博主的代码。 缺点： 如果粉丝太多（几万个），通知一遍需要花很多时间（Python里是一个个循环调用的）。 如果粉丝和博主之间互相循环依赖（粉丝订阅博主，博主又订阅粉丝），可能会导致无限循环死机。 希望这个讲解能让你彻底明白观察者模式！对于编程小白来说，理解“列表存储”和“循环通知”这个机制是最重要的。加油！\n七、程序员视角的“观察者模式”架构 如何彻底理解这个模式？ 新手理解观察者模式，最大的突破口在于理解两个词：“注册” 和 “回调”。\n1. 突破口一：列表即连接（注册机制） 以前你写程序，A 要调用 B，你是直接写的。 现在 A 和 B 不认识，怎么联系？ 突破口：self._observers.append(observer)。 这行代码看似简单，其实它是建立连接的瞬间。并没有什么神奇的魔法线连着它们，仅仅是把一个对象（内存地址）**存进了一个**列表里。\n理解：所谓的“订阅”，在代码里仅仅是“把你放进我的列表里”。 2. 突破口二：循环即广播（回调机制） 为什么博主一喊，大家都动了？ 突破口：\nfor observer in self._observers: observer.update(...) 这不是广播电台那种无线电波，它本质上就是一个挨着一个的打电话。\n理解：所谓的“通知”，在代码里仅仅是“遍历列表，挨个调用每个对象的 update 函数”。 重要：这就是为什么所有粉丝类必须叫 Fan 或者别的名字没关系，但必须都有一个叫 update 的方法。如果一个叫 update，一个叫 receive，博主在循环的时候就会报错（因为博主只会调 update）。 新手程序员如何写好观察者模式？ 明白了原理，怎么写才像个“老手”？要注意以下几点：\n1. 统一接口（Interface） 这是最重要的一点！\n错误写法：粉丝类有一个 update 方法，广告商类有一个 notify_me 方法。 正确写法：不管你是粉丝、广告商还是警察，只要你想订阅我，你必须都实现一个同名的方法（通常叫 update）。 为什么：这样事件源（Youtuber）在循环调用时，不需要判断你是谁，直接无脑调 update() 即可。这就是代码中 class Observer(ABC) 存在的意义——制定标准。 2. 防止“内存泄漏”（一定要能退订） 新手容易只管 attach（订阅），不管 detach（退订）。\n场景：如果小红不再喜欢这个博主了，但你没有把她从 _observers 列表里移除。 后果：博主每次发视频，程序还得浪费计算资源去通知小红，而且小红对象永远被列表引用，无法被内存回收机制回收。随着时间推移，列表越来越大，程序越来越慢。 教训：写 attach 的时候，脑子里立刻要想好 detach 怎么写。 3. 异常处理（不要一颗老鼠屎坏了一锅粥） 你的代码里 notify 是一个循环。\n风险：如果列表里有100个人，第2个人的 update 方法里写错了代码，报错崩溃了。\n结果：程序直接停止，后面98个人都收不到通知了。\n进阶写法：\ndef notify(self): for observer in self._observers: try: observer.update() except Exception as e: print(f\"通知 {observer.name} 失败，跳过，继续通知下一个\") 我的疑问 Observer.update() 中的self.name为什么会是粉丝，而不是老王： 核心原理：self 永远代表方法的调用者，在 Python 中，当你在一个实例方法内部使用 self 时，它始终指代当前正在执行这个方法的那个对象实例\nFan 类中 update 方法的定义：\nclass Fan(Observer): def __init__(self, name): self.name = name # 这里的 self.name 是粉丝的名字 (小明/小红) def update(self, youtuber_name, video_title): \"\"\"当收到通知时，粉丝的反应\"\"\" # 这里的 self 指的是调用 update() 的那个 Fan 实例 (小明或小红) print(f\" -\u003e 粉丝 [{self.name}] 收到了！...\") 结论 在 Fan.update() 方法中：\nself.name 访问的是调用该方法的对象的 name 属性，即粉丝自己的名字（\"小明\"）。 youtuber_name 访问的是老王作为参数传递进来的名字（\"老王\"）。 ","wordCount":"739","inLanguage":"en","datePublished":"2025-11-20T12:00:00+08:00","dateModified":"2025-11-20T12:00:00+08:00","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">观察者模式(YouTuber订阅)</h1><div class=post-meta><span title='2025-11-20 12:00:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h1 id=观察者模式youtuber订阅>观察者模式(YouTuber订阅)<a hidden class=anchor aria-hidden=true href=#观察者模式youtuber订阅>#</a></h1><h2 id=一观察者模式到底是干嘛的为什么会有人发明它>一、观察者模式到底是干嘛的？为什么会有人发明它？<a hidden class=anchor aria-hidden=true href=#一观察者模式到底是干嘛的为什么会有人发明它>#</a></h2><p>想象一下现实生活中的场景：</p><p>你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。</p><p>这里的关键问题就是：</p><p><strong>“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”</strong></p><p>如果没有观察者模式，我们会怎么做？最笨的办法：</p><ul><li>老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知；</li><li>或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。</li></ul><p>这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。</p><h3 id=观察者模式解决的核心痛点>观察者模式解决的核心痛点：<a hidden class=anchor aria-hidden=true href=#观察者模式解决的核心痛点>#</a></h3><ol><li><strong>解耦</strong>：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。</li><li><strong>一对多依赖</strong>：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。</li><li><strong>动态订阅/退订</strong>：粉丝可以随时订阅、随时取关，主题完全不关心。</li><li><strong>松耦合</strong>：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。</li></ol><p>一句话总结： <strong>当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。</strong></p><h2 id=二经典使用场景你以后一定会遇到>二、经典使用场景（你以后一定会遇到）<a hidden class=anchor aria-hidden=true href=#二经典使用场景你以后一定会遇到>#</a></h2><ul><li>聊天软件：有人发消息，所有在线好友收到通知</li><li>股票软件：股价变动，所有关注这只股票的人收到推送</li><li>GUI界面：点击按钮，所有注册了点击事件的监听器执行</li><li>消息队列、事件总线（EventBus）</li><li>Vue/React 中的数据响应式（本质也是观察者）</li><li>Python 中的信号槽（PyQt/PySide）、Java 中的 Listener</li></ul><h2 id=三用大白话理解观察者模式的四个核心角色>三、用大白话理解观察者模式的四个核心角色<a hidden class=anchor aria-hidden=true href=#三用大白话理解观察者模式的四个核心角色>#</a></h2><table><thead><tr><th>角色</th><th>现实中对应</th><th>代码中对应</th><th>职责</th></tr></thead><tbody><tr><td>Subject（主题）</td><td>YouTuber</td><td>Youtuber 类</td><td>维护订阅者列表，提供 attach/detach/notify 方法</td></tr><tr><td>Observer（观察者接口）</td><td>“订阅后必须能收到通知”这个约定</td><td>Observer 抽象类</td><td>定义 update 方法</td></tr><tr><td>ConcreteObserver（具体观察者）</td><td>具体的粉丝小明、小红</td><td>Fan 类</td><td>实现 update，真正干活的地方</td></tr><tr><td>Client（客户代码）</td><td>我们写的主程序</td><td>最后的运行逻辑</td><td>创建对象、订阅、触发通知</td></tr></tbody></table><h2 id=四代码分析>四、代码分析<a hidden class=anchor aria-hidden=true href=#四代码分析>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># -------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 步骤1：定义“主题”（Youtuber）</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Youtuber</span>:                                           <span style=color:#75715e># 定义一个类，名叫 Youtuber，代表“被订阅的对象”</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name):                             <span style=color:#75715e># 构造函数，创建对象时自动执行</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name                                  <span style=color:#75715e># 给这个YouTuber起个名字，比如“老王”</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_observers <span style=color:#f92672>=</span> []  <span style=color:#75715e># 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问</span>
</span></span><span style=display:flex><span>                                                          <span style=color:#75715e># [] 表示创建一个空列表，用来装所有粉丝对象</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>attach</span>(self, observer):                           <span style=color:#75715e># “订阅”方法，参数 observer 就是一个粉丝对象</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;添加一个观察者（订阅）&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> observer <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>_observers:               <span style=color:#75715e># 判断这个粉丝是否已经订阅过，防止重复</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>_observers<span style=color:#f92672>.</span>append(observer)              <span style=color:#75715e># append 是列表的内置方法，把粉丝对象加到列表末尾</span>
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[</span><span style=color:#e6db74>{</span>observer<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>] 订阅了 [</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>]&#34;</span>)  <span style=color:#75715e># 打印一条提示信息</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>detach</span>(self, observer):                           <span style=color:#75715e># “取消订阅”方法</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;移除一个观察者（取消订阅）&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>_observers<span style=color:#f92672>.</span>remove(observer)              <span style=color:#75715e># remove 是列表的内置方法，直接删除这个对象</span>
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[</span><span style=color:#e6db74>{</span>observer<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>] 取消订阅了 [</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>]&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span>:                                <span style=color:#75715e># 如果列表里根本没有这个对象，remove 会报错</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pass</span>                                          <span style=color:#75715e># 我们选择忽略这个错误，什么都不做</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>notify</span>(self, video_title):                        <span style=color:#75715e># 最最重要的“发布视频”方法，也就是状态发生变化</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;通知所有观察者&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>[</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>] 发布了新视频: </span><span style=color:#e6db74>{</span>video_title<span style=color:#e6db74>}</span><span style=color:#e6db74>！正在通知所有订阅者...&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> observer <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>_observers:                  <span style=color:#75715e># 遍历当前所有的粉丝对象</span>
</span></span><span style=display:flex><span>            observer<span style=color:#f92672>.</span>update(self<span style=color:#f92672>.</span>name, video_title)       <span style=color:#75715e># **核心中的核心！**</span>
</span></span><span style=display:flex><span>                                                          <span style=color:#75715e># 调用每个粉丝的 update 方法，把视频信息告诉他</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># -------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 步骤2：定义“观察者”模板和具体观察者（粉丝）</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> abc <span style=color:#f92672>import</span> ABC, abstractmethod                     <span style=color:#75715e># 从 abc 模块导入工具，用来创建抽象类</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Observer</span>(ABC):                                    <span style=color:#75715e># 定义一个抽象基类（模板），所有观察者都必须遵守</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@abstractmethod</span>                                     <span style=color:#75715e># 装饰器：表示下面的方法是“抽象方法”，子类必须实现</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update</span>(self, youtuber_name, video_title):       <span style=color:#75715e># 抽象方法，只定义签名，不写具体内容</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>                                            <span style=color:#75715e># pass 表示“占个位置，啥也不干”</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fan</span>(Observer):                                    <span style=color:#75715e># Fan 类继承 Observer，代表具体的粉丝</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name                                <span style=color:#75715e># 每个粉丝也有自己的名字</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update</span>(self, youtuber_name, video_title):       <span style=color:#75715e># 必须实现父类的抽象方法，否则会报错</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;当收到通知时，粉丝的反应&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;  -&gt; 粉丝 [</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>] 收到了！正在打开 App 查看 [</span><span style=color:#e6db74>{</span>youtuber_name<span style=color:#e6db74>}</span><span style=color:#e6db74>] 的 [</span><span style=color:#e6db74>{</span>video_title<span style=color:#e6db74>}</span><span style=color:#e6db74>]&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e># 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># -------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 步骤3：运行逻辑（真正看到效果的地方）</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -------------------------------------------------</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. 创建主题和观察者</span>
</span></span><span style=display:flex><span>youtuber_A <span style=color:#f92672>=</span> Youtuber(<span style=color:#e6db74>&#34;老王&#34;</span>)                           <span style=color:#75715e># 创建一个YouTuber，名字叫“老王”</span>
</span></span><span style=display:flex><span>fan_1 <span style=color:#f92672>=</span> Fan(<span style=color:#e6db74>&#34;小明&#34;</span>)                                     <span style=color:#75715e># 创建三个粉丝对象</span>
</span></span><span style=display:flex><span>fan_2 <span style=color:#f92672>=</span> Fan(<span style=color:#e6db74>&#34;小红&#34;</span>)
</span></span><span style=display:flex><span>fan_3 <span style=color:#f92672>=</span> Fan(<span style=color:#e6db74>&#34;小刚&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 观察者“订阅”主题</span>
</span></span><span style=display:flex><span>youtuber_A<span style=color:#f92672>.</span>attach(fan_1)                                <span style=color:#75715e># 小明和小红先订阅</span>
</span></span><span style=display:flex><span>youtuber_A<span style=color:#f92672>.</span>attach(fan_2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 主题发布新内容（状态变更）</span>
</span></span><span style=display:flex><span>youtuber_A<span style=color:#f92672>.</span>notify(<span style=color:#e6db74>&#34;观察者模式入门&#34;</span>)                     <span style=color:#75715e># 老王发第一条视频，只有小明和小红收到</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 另一个粉丝也订阅了</span>
</span></span><span style=display:flex><span>youtuber_A<span style=color:#f92672>.</span>attach(fan_3)                                <span style=color:#75715e># 小刚中途订阅</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 5. 小红取消订阅</span>
</span></span><span style=display:flex><span>youtuber_A<span style=color:#f92672>.</span>detach(fan_2)                                <span style=color:#75715e># 小红取关</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 6. 主题再次发布新内容</span>
</span></span><span style=display:flex><span>youtuber_A<span style=color:#f92672>.</span>notify(<span style=color:#e6db74>&#34;工厂模式yyds&#34;</span>)                       <span style=color:#75715e># 老王再发一条视频，只有小明和小刚收到</span>
</span></span></code></pre></div><p>运行后你会看到输出：</p><pre tabindex=0><code>[小明] 订阅了 [老王]
[小红] 订阅了 [老王]

[老王] 发布了新视频: 观察者模式入门！正在通知所有订阅者...
  -&gt; 粉丝 [小明] 收到了！正在打开 App 查看 [老王] 的 [观察者模式入门]
  -&gt; 粉丝 [小红] 收到了！正在打开 App 查看 [老王] 的 [观察者模式入门]
[小刚] 订阅了 [老王]
[小红] 取消订阅了 [老王]

[老王] 发布了新视频: 工厂模式yyds！正在通知所有订阅者...
  -&gt; 粉丝 [小明] 收到了！正在打开 App 查看 [老王] 的 [工厂模式yyds]
  -&gt; 粉丝 [小刚] 收到了！正在打开 App 查看 [老王] 的 [工厂模式yyds]
</code></pre><p>看到了吗？老王完全不知道粉丝是谁、怎么通知，他只负责喊一声“notify”，所有当前订阅的人自动收到消息。</p><h2 id=五代码逐行精讲老师教学模式>五、代码逐行精讲（老师教学模式）<a hidden class=anchor aria-hidden=true href=#五代码逐行精讲老师教学模式>#</a></h2><h3 id=1-定义主题youtuber>1. 定义“主题”（Youtuber）<a hidden class=anchor aria-hidden=true href=#1-定义主题youtuber>#</a></h3><p>codePython</p><pre tabindex=0><code>class Youtuber:
    def __init__(self, name):
        self.name = name
        self._observers = [] # 核心：一个“订阅者列表”，_ 开头通常表示内部使用
</code></pre><ul><li><strong>老师解读</strong>：<ul><li>class Youtuber:：我们要造一种叫“Youtuber”的事物。</li><li>def <strong>init</strong>(self, name):：这是<strong>初始化方法</strong>。当你创建一个新的 Youtuber 时，Python 会自动运行这段代码。self 代表“这个对象自己”。</li><li>self.name = name：给这个 Youtuber 起个名。</li><li>self._observers = []：<strong>这是全场最关键的一行！</strong><ul><li>[] 是一个<strong>空列表</strong>（就像一个空记事本）。</li><li>我们用它来存谁订阅了我。以后要发通知，就照着这个本子念。</li><li>变量名前面加 _ (下划线) 是 Python 程序员的约定，意思是“这是我有隐私的本子，外面的人最好不要直接乱改，要通过我提供的方法来改”。</li></ul></li></ul></li></ul><p>codePython</p><pre tabindex=0><code>def attach(self, observer):
        &#34;&#34;&#34;添加一个观察者（订阅）&#34;&#34;&#34;
        if observer not in self._observers: # 避免重复添加
            self._observers.append(observer) # append 是 list 的添加方法
            print(f&#34;[{observer.name}] 订阅了 [{self.name}]&#34;)
</code></pre><ul><li><strong>老师解读</strong>：<ul><li>def attach：定义一个叫“关联/订阅”的动作。参数 observer 就是传进来的那个粉丝对象。</li><li>if observer not in self._observers:：先检查一下，这个粉丝是不是已经在名单里了？防止手抖点两次订阅。</li><li>self._observers.append(observer)：append 是 Python 列表的操作，意思是<strong>把这个粉丝追加到名单的末尾</strong>。</li><li>print(&mldr;)：在屏幕上打印一条消息，f"&mldr;" 是格式化字符串，能把变量里的值塞进句子里显示出来。</li></ul></li></ul><p>codePython</p><pre tabindex=0><code>def detach(self, observer):
        &#34;&#34;&#34;移除一个观察者（取消订阅）&#34;&#34;&#34;
        try:
            self._observers.remove(observer) # remove 是 list 的移除方法
            print(f&#34;[{observer.name}] 取消订阅了 [{self.name}]&#34;)
        except ValueError:
            pass # 如果列表里没有，就什么都不做
</code></pre><ul><li><strong>老师解读</strong>：<ul><li>def detach：定义“取消订阅”的动作。</li><li>self._observers.remove(observer)：remove 是让 Python 在列表里找到这个粉丝，并把他擦掉。</li><li>try&mldr;except ValueError：这是<strong>异常处理</strong>。为什么要用它？因为如果你尝试删除一个根本不在名单里的人，Python 列表会报错（报错叫 ValueError）。这里意思是：“试着删一下，如果报错了（说明没这个人），就 pass（什么都不做，假装无事发生）”。</li></ul></li></ul><p>codePython</p><pre tabindex=0><code>def notify(self, video_title):
        &#34;&#34;&#34;通知所有观察者&#34;&#34;&#34;
        print(f&#34;\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...&#34;)
        for observer in self._observers: # 循环“订阅者列表”
            observer.update(self.name, video_title) # **核心：调用观察者的 update 方法**
</code></pre><ul><li><strong>老师解读</strong>：<ul><li>def notify：这是<strong>博主的大招</strong>——发布通知。</li><li>for observer in self._observers:：这是一个<strong>循环</strong>。意思是：“把名单拿出来，从第一个人开始，一个接一个地过一遍”。每一次循环，observer 这个变量就代表当前的那个粉丝。</li><li>observer.update(&mldr;)：<strong>这是观察者模式的灵魂！</strong><ul><li>博主不需要知道粉丝具体是谁，博主只知道：<strong>“凡是粉丝，一定有一个叫 update 的方法（接口）”</strong>。</li><li>所以博主就闭着眼睛调用每个粉丝的 update，告诉他们：“是我（self.name），我发了（video_title）”。</li></ul></li></ul></li></ul><hr><h3 id=2-定义观察者粉丝>2. 定义“观察者”（粉丝）<a hidden class=anchor aria-hidden=true href=#2-定义观察者粉丝>#</a></h3><p>codePython</p><pre tabindex=0><code>class Observer(ABC): # 观察者模板
    @abstractmethod
    def update(self, youtuber_name, video_title): # 必须有一个 update 方法
        pass
</code></pre><ul><li><strong>老师解读</strong>：<ul><li>class Observer(ABC)：定义一个<strong>抽象基类</strong>（模板）。ABC 意思是 Abstract Base Class。</li><li>@abstractmethod：这是一个“装饰器”，它像一个印章，盖在 update 方法上。</li><li><strong>含义</strong>：这段代码在制定规则。它在说：“所有想当观察者的人，<strong>必须</strong>如果你想当粉丝，你必须学会‘接收更新’（update）这个技能。如果你不写 update 方法，我就不让你当粉丝。”</li><li>pass：这里不需要写具体代码，因为这只是个规则/模板。</li></ul></li></ul><p>codePython</p><pre tabindex=0><code>class Fan(Observer): # 具体的观察者：粉丝
    def __init__(self, name):
        self.name = name # 粉丝有自己的名字

    def update(self, youtuber_name, video_title): # 实现 update 方法
        &#34;&#34;&#34;当收到通知时，粉丝的反应&#34;&#34;&#34;
        print(f&#34;  -&gt; 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]&#34;)
</code></pre><ul><li><strong>老师解读</strong>：<ul><li>class Fan(Observer)：Fan 继承自 Observer。意思是：粉丝是一种观察者，粉丝遵守观察者的规则。</li><li>def update(&mldr;)：<strong>关键点</strong>。粉丝必须具体实现（写出代码）收到通知后该干什么。</li><li>这里的逻辑是：收到通知后，打印一句话，表示我去看了。</li><li><strong>思考</strong>：如果有另一种观察者叫 Police（网警），他的 update 方法可能就是“审查视频内容”。博主不需要改代码，只需要添加新的观察者类即可。</li></ul></li></ul><h2 id=六总结与应用场景>六、总结与应用场景<a hidden class=anchor aria-hidden=true href=#六总结与应用场景>#</a></h2><h3 id=1-观察者模式的核心原理一句话总结>1. 观察者模式的核心原理（一句话总结）<a hidden class=anchor aria-hidden=true href=#1-观察者模式的核心原理一句话总结>#</a></h3><p><strong>“别在一棵树上吊死，留个电话给我，有事你打给我。”</strong>
（这就是好莱坞原则：Don&rsquo;t call us, we&rsquo;ll call you）。</p><h3 id=2-适合什么场景什么时候用>2. 适合什么场景？（什么时候用）<a hidden class=anchor aria-hidden=true href=#2-适合什么场景什么时候用>#</a></h3><p>当出现**“一对多”**的依赖关系时，即：<strong>一个对象的状态发生了改变，所有的相关对象都必须得到通知并自动更新</strong>。</p><ul><li><strong>Excel 表格</strong>：当你修改了一个单元格的数字（主题），生成的柱状图、饼图、汇总数据（观察者）都会自动变样。</li><li><strong>股票交易软件</strong>：股票价格（主题）一跳动，K线图、账户总资产、预警系统（观察者）都要跟着变。</li><li><strong>红绿灯</strong>：红绿灯变色（主题），路口的汽车、行人（观察者）做出停车或行走的反应。</li><li><strong>GUI 编程（按钮点击）</strong>：你点击了一个“提交”按钮（主题），可能是表单提交数据，也可能是弹窗关闭，这些响应逻辑就是观察者。</li></ul><h3 id=3-优缺点新手须知>3. 优缺点（新手须知）<a hidden class=anchor aria-hidden=true href=#3-优缺点新手须知>#</a></h3><ul><li><strong>优点</strong>：<ul><li><strong>解耦</strong>：博主不需要知道粉丝的任何具体细节，只管发通知。</li><li><strong>扩展性强</strong>：想增加一种新的观察者（比如“广告商”），直接写个新类就行，不用改博主的代码。</li></ul></li><li><strong>缺点</strong>：<ul><li>如果粉丝太多（几万个），通知一遍需要花很多时间（Python里是一个个循环调用的）。</li><li>如果粉丝和博主之间互相循环依赖（粉丝订阅博主，博主又订阅粉丝），可能会导致无限循环死机。</li></ul></li></ul><p>希望这个讲解能让你彻底明白观察者模式！对于编程小白来说，<strong>理解“列表存储”和“循环通知”这个机制</strong>是最重要的。加油！</p><h2 id=七程序员视角的观察者模式架构>七、程序员视角的“观察者模式”架构<a hidden class=anchor aria-hidden=true href=#七程序员视角的观察者模式架构>#</a></h2><h3 id=如何彻底理解这个模式>如何彻底理解这个模式？<a hidden class=anchor aria-hidden=true href=#如何彻底理解这个模式>#</a></h3><p>新手理解观察者模式，最大的<strong>突破口</strong>在于理解两个词：<strong>“注册”</strong> 和 <strong>“回调”</strong>。</p><h4 id=1-突破口一列表即连接注册机制>1. 突破口一：列表即连接（注册机制）<a hidden class=anchor aria-hidden=true href=#1-突破口一列表即连接注册机制>#</a></h4><p>以前你写程序，A 要调用 B，你是直接写的。
现在 A 和 B 不认识，怎么联系？
<strong>突破口</strong>：self._observers.append(observer)。
这行代码看似简单，其实它是<strong>建立连接的瞬间</strong>。并没有什么神奇的魔法线连着它们，仅仅是把一个<strong>对象（内存地址）**存进了一个**列表</strong>里。</p><ul><li><strong>理解</strong>：所谓的“订阅”，在代码里仅仅是“<strong>把你放进我的列表里</strong>”。</li></ul><h4 id=2-突破口二循环即广播回调机制>2. 突破口二：循环即广播（回调机制）<a hidden class=anchor aria-hidden=true href=#2-突破口二循环即广播回调机制>#</a></h4><p>为什么博主一喊，大家都动了？
<strong>突破口</strong>：</p><pre tabindex=0><code>for observer in self._observers:
    observer.update(...)
</code></pre><p>这不是广播电台那种无线电波，它本质上就是<strong>一个挨着一个的打电话</strong>。</p><ul><li><strong>理解</strong>：所谓的“通知”，在代码里仅仅是“<strong>遍历列表，挨个调用每个对象的 update 函数</strong>”。</li><li><strong>重要</strong>：这就是为什么所有粉丝类必须叫 Fan 或者别的名字没关系，但<strong>必须都有一个叫 update 的方法</strong>。如果一个叫 update，一个叫 receive，博主在循环的时候就会报错（因为博主只会调 update）。</li></ul><h3 id=新手程序员如何写好观察者模式>新手程序员如何写好观察者模式？<a hidden class=anchor aria-hidden=true href=#新手程序员如何写好观察者模式>#</a></h3><p>明白了原理，怎么写才像个“老手”？要注意以下几点：</p><h4 id=1-统一接口interface>1. 统一接口（Interface）<a hidden class=anchor aria-hidden=true href=#1-统一接口interface>#</a></h4><p>这是最重要的一点！</p><ul><li><strong>错误写法</strong>：粉丝类有一个 update 方法，广告商类有一个 notify_me 方法。</li><li><strong>正确写法</strong>：不管你是粉丝、广告商还是警察，只要你想订阅我，你<strong>必须</strong>都实现一个同名的方法（通常叫 update）。</li><li><strong>为什么</strong>：这样事件源（Youtuber）在循环调用时，不需要判断你是谁，直接无脑调 update() 即可。这就是代码中 class Observer(ABC) 存在的意义——<strong>制定标准</strong>。</li></ul><h4 id=2-防止内存泄漏一定要能退订>2. 防止“内存泄漏”（一定要能退订）<a hidden class=anchor aria-hidden=true href=#2-防止内存泄漏一定要能退订>#</a></h4><p>新手容易只管 attach（订阅），不管 detach（退订）。</p><ul><li><strong>场景</strong>：如果小红不再喜欢这个博主了，但你没有把她从 _observers 列表里移除。</li><li><strong>后果</strong>：博主每次发视频，程序还得浪费计算资源去通知小红，而且小红对象永远被列表引用，无法被内存回收机制回收。随着时间推移，列表越来越大，程序越来越慢。</li><li><strong>教训</strong>：写 attach 的时候，脑子里立刻要想好 detach 怎么写。</li></ul><h4 id=3-异常处理不要一颗老鼠屎坏了一锅粥>3. 异常处理（不要一颗老鼠屎坏了一锅粥）<a hidden class=anchor aria-hidden=true href=#3-异常处理不要一颗老鼠屎坏了一锅粥>#</a></h4><p>你的代码里 notify 是一个循环。</p><ul><li><p><strong>风险</strong>：如果列表里有100个人，第2个人的 update 方法里写错了代码，报错崩溃了。</p></li><li><p><strong>结果</strong>：程序直接停止，后面98个人都收不到通知了。</p></li><li><p><strong>进阶写法</strong>：</p><pre tabindex=0><code>def notify(self):
    for observer in self._observers:
        try:
            observer.update()
        except Exception as e:
            print(f&#34;通知 {observer.name} 失败，跳过，继续通知下一个&#34;)
</code></pre></li></ul><h2 id=我的疑问>我的疑问<a hidden class=anchor aria-hidden=true href=#我的疑问>#</a></h2><h3 id=observerupdate-中的selfname为什么会是粉丝而不是老王><strong>Observer.update() 中的self.name为什么会是粉丝，而不是老王</strong>：<a hidden class=anchor aria-hidden=true href=#observerupdate-中的selfname为什么会是粉丝而不是老王>#</a></h3><p>核心原理：<code>self</code> 永远代表方法的调用者，在 Python 中，当你在一个实例方法内部使用 <code>self</code> 时，它始终指代<strong>当前正在执行这个方法的那个对象实例</strong></p><p><code>Fan</code> 类中 <code>update</code> 方法的定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fan</span>(Observer):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name  <span style=color:#75715e># 这里的 self.name 是粉丝的名字 (小明/小红)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update</span>(self, youtuber_name, video_title):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;当收到通知时，粉丝的反应&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 这里的 self 指的是调用 update() 的那个 Fan 实例 (小明或小红)</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;  -&gt; 粉丝 [</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>] 收到了！...&#34;</span>)
</span></span></code></pre></div><h3 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h3><p>在 <code>Fan.update()</code> 方法中：</p><ul><li><code>self.name</code> 访问的是<strong>调用该方法的对象</strong>的 <code>name</code> 属性，即<strong>粉丝</strong>自己的名字（<code>"小明"</code>）。</li><li><code>youtuber_name</code> 访问的是<strong>老王作为参数传递进来</strong>的名字（<code>"老王"</code>）。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/java/>Java</a></li><li><a href=http://ljj1992.fun/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/>观察者模式</a></li><li><a href=http://ljj1992.fun/tags/web%E5%BC%80%E5%8F%91/>Web开发</a></li><li><a href=http://ljj1992.fun/tags/%E7%BC%96%E7%A8%8B/>编程</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>