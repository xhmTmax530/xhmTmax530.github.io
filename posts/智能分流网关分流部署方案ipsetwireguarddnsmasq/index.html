<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>智能分流网关分流部署方案(ipset、wireguard、dnsmasq) | star徐的博客</title>
<meta name="keywords" content="网络, WireGuard, ipset, DNS">
<meta name="description" content="&hellip; (文章的其他内容)
方案概览

核心技术: WireGuard, Dnsmasq, Iptables, IPset, 策略路由
核心策略: 白名单直连，默认代理。
流量路径:

DNS查询:

国内域名 (匹配dnsmasq-china-list): 通过国内DNS (119.29.29.29等) 直接解析，并将结果IP自动加入directlist IP白名单集合。
被墙域名 &amp; 未知域名: 统一通过WireGuard隧道向上游DNS (8.8.8.8) 查询。被墙域名的结果IP会自动加入gfwlist IP集合。


数据传输:

国内IP (匹配directlist IP白名单): 直接连接（走本地出口）。
所有其他IP (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。




核心特性:

DNS查询保护: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。
默认代理: 任何未明确指定为&quot;直连&quot;的流量，都将默认通过隧道，提供更强的隐私保护。
Kill Switch: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。
全自动化: 定时脚本自动更新国内外域名与IP列表，无需人工干预。




第一部分：VPS (服务器端) 配置
VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。
1. 系统准备与软件安装
# 更新系统软件包列表并升级已安装的软件
sudo apt update &amp;&amp; sudo apt upgrade -y

# 安装WireGuard
sudo apt install wireguard -y
2. 启用IP转发
# 编辑sysctl配置文件
sudo nano /etc/sysctl.conf
确保文件中包含以下行（去掉前面的#号）：">
<meta name="author" content="您的姓名">
<link rel="canonical" href="//localhost:1313/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E5%88%86%E6%B5%81%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88ipsetwireguarddnsmasq/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="//localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="//localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="//localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="//localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="//localhost:1313/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E5%88%86%E6%B5%81%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88ipsetwireguarddnsmasq/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="//localhost:1313/" accesskey="h" title="star徐的博客 (Alt + H)">star徐的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="//localhost:1313/" title="首页">
                    <span>首页</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="//localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="//localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      智能分流网关分流部署方案(ipset、wireguard、dnsmasq)
    </h1>
    <div class="post-meta"><span title='2025-11-13 18:00:00 +0800 CST'>November 13, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span>

</div>
  </header> 
  <div class="post-content"><p>&hellip; (文章的其他内容)</p>
<h2 id="方案概览">方案概览<a hidden class="anchor" aria-hidden="true" href="#方案概览">#</a></h2>
<ul>
<li><strong>核心技术</strong>: WireGuard, Dnsmasq, Iptables, IPset, 策略路由</li>
<li><strong>核心策略</strong>: <strong>白名单直连，默认代理</strong>。</li>
<li><strong>流量路径</strong>:
<ol>
<li><strong>DNS查询</strong>:
<ul>
<li><strong>国内域名</strong> (匹配<code>dnsmasq-china-list</code>): 通过国内DNS (<code>119.29.29.29</code>等) 直接解析，并将结果IP自动加入<code>directlist</code> IP白名单集合。</li>
<li><strong>被墙域名 &amp; 未知域名</strong>: 统一通过WireGuard隧道向上游DNS (<code>8.8.8.8</code>) 查询。被墙域名的结果IP会自动加入<code>gfwlist</code> IP集合。</li>
</ul>
</li>
<li><strong>数据传输</strong>:
<ul>
<li><strong>国内IP</strong> (匹配<code>directlist</code> IP白名单): 直接连接（走本地出口）。</li>
<li><strong>所有其他IP</strong> (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。</li>
</ul>
</li>
</ol>
</li>
<li><strong>核心特性</strong>:
<ul>
<li><strong>DNS查询保护</strong>: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。</li>
<li><strong>默认代理</strong>: 任何未明确指定为&quot;直连&quot;的流量，都将默认通过隧道，提供更强的隐私保护。</li>
<li><strong>Kill Switch</strong>: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。</li>
<li><strong>全自动化</strong>: 定时脚本自动更新国内外域名与IP列表，无需人工干预。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第一部分vps-服务器端-配置">第一部分：VPS (服务器端) 配置<a hidden class="anchor" aria-hidden="true" href="#第一部分vps-服务器端-配置">#</a></h2>
<p>VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。</p>
<h3 id="1-系统准备与软件安装">1. 系统准备与软件安装<a hidden class="anchor" aria-hidden="true" href="#1-系统准备与软件安装">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 更新系统软件包列表并升级已安装的软件</span>
</span></span><span style="display:flex;"><span>sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 安装WireGuard</span>
</span></span><span style="display:flex;"><span>sudo apt install wireguard -y
</span></span></code></pre></div><h3 id="2-启用ip转发">2. 启用IP转发<a hidden class="anchor" aria-hidden="true" href="#2-启用ip转发">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 编辑sysctl配置文件</span>
</span></span><span style="display:flex;"><span>sudo nano /etc/sysctl.conf
</span></span></code></pre></div><p>确保文件中包含以下行（去掉前面的<code>#</code>号）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ini" data-lang="ini"><span style="display:flex;"><span><span style="color:#75715e"># 启用IPv4数据包转发</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">net.ipv4.ip_forward</span><span style="color:#f92672">=</span><span style="color:#e6db74">1</span>
</span></span></code></pre></div><p>保存文件后，执行命令使其立即生效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 从/etc/sysctl.conf加载内核参数</span>
</span></span><span style="display:flex;"><span>sudo sysctl -p
</span></span></code></pre></div><h3 id="3-生成wireguard密钥">3. 生成WireGuard密钥<a hidden class="anchor" aria-hidden="true" href="#3-生成wireguard密钥">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 一步完成生成私钥、保存、计算公钥、保存</span>
</span></span><span style="display:flex;"><span>wg genkey | tee vps_privatekey | wg pubkey &gt; vps_publickey
</span></span></code></pre></div><blockquote>
<p><strong>提示</strong>: 请记下 <code>vps_privatekey</code> 和 <code>vps_publickey</code> 文件的内容。</p>
</blockquote>
<h3 id="4-配置wireguard-etcwireguardwg0conf">4. 配置WireGuard (<code>/etc/wireguard/wg0.conf</code>)<a hidden class="anchor" aria-hidden="true" href="#4-配置wireguard-etcwireguardwg0conf">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 创建并编辑配置文件</span>
</span></span><span style="display:flex;"><span>sudo nano /etc/wireguard/wg0.conf
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>填入以下内容：
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>ini
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Interface<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 本服务器在隧道中的IPv4地址</span>
</span></span><span style="display:flex;"><span>Address <span style="color:#f92672">=</span> 10.0.0.1/24
</span></span><span style="display:flex;"><span>SaveConfig <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span><span style="color:#75715e"># WireGuard监听的UDP端口</span>
</span></span><span style="display:flex;"><span>ListenPort <span style="color:#f92672">=</span> <span style="color:#ae81ff">51820</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 填入您上一步生成的VPS私钥</span>
</span></span><span style="display:flex;"><span>PrivateKey <span style="color:#f92672">=</span> &lt;在此粘贴vps_privatekey的内容&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Peer<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 稍后填入国内网关的公钥</span>
</span></span><span style="display:flex;"><span>PublicKey <span style="color:#f92672">=</span> &lt;稍后填入国内网关的公钥&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 分配给国内网关的隧道IP地址</span>
</span></span><span style="display:flex;"><span>AllowedIPs <span style="color:#f92672">=</span> 10.0.0.2/32
</span></span></code></pre></div><h3 id="5-配置防火墙nat规则">5. 配置防火墙NAT规则<a hidden class="anchor" aria-hidden="true" href="#5-配置防火墙nat规则">#</a></h3>
<blockquote>
<p><strong>注意</strong>: 如果你的公网网卡不是 <code>eth0</code>，请用 <code>ip a</code> 命令查看并替换。这一步是必需的，它负责将从隧道过来的、源地址为私网IP（<code>10.0.0.2</code>）的数据包，在发送到公网前，将其源地址&quot;伪装&quot;成VPS自己的公网IP，从而让目标服务器知道将响应数据发回给谁。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 允许所有来自wg0接口的数据包被转发</span>
</span></span><span style="display:flex;"><span>sudo iptables -A FORWARD -i wg0 -j ACCEPT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 将所有从公网网卡出去的包，其源地址伪装成公网地址</span>
</span></span><span style="display:flex;"><span>sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</span></span></code></pre></div><h3 id="6-启动wireguard服务">6. 启动WireGuard服务<a hidden class="anchor" aria-hidden="true" href="#6-启动wireguard服务">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 启动名为wg0的WireGuard接口</span>
</span></span><span style="display:flex;"><span>sudo wg-quick up wg0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 设置WireGuard服务开机自启</span>
</span></span><span style="display:flex;"><span>sudo systemctl enable wg-quick@wg0
</span></span></code></pre></div><hr>
<h2 id="第二部分国内linux网关-客户端-配置">第二部分：国内Linux网关 (客户端) 配置<a hidden class="anchor" aria-hidden="true" href="#第二部分国内linux网关-客户端-配置">#</a></h2>
<p>这是整个系统的核心，所有智能分流逻辑都在此实现。</p>
<h3 id="1-系统准备与软件安装-1">1. 系统准备与软件安装<a hidden class="anchor" aria-hidden="true" href="#1-系统准备与软件安装-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 更新并升级</span>
</span></span><span style="display:flex;"><span>sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 安装所有必需的软件</span>
</span></span><span style="display:flex;"><span>sudo apt install wireguard dnsmasq ipset git curl -y
</span></span></code></pre></div><h3 id="2-生成wireguard密钥">2. 生成WireGuard密钥<a hidden class="anchor" aria-hidden="true" href="#2-生成wireguard密钥">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wg genkey | tee domestic_privatekey | wg pubkey &gt; domestic_publickey<span style="color:#e6db74">```</span>
</span></span><span style="display:flex;"><span>&gt; **重要**: 将 <span style="color:#e6db74">`</span>domestic_publickey<span style="color:#e6db74">`</span> 文件的内容，填入您VPS上 <span style="color:#e6db74">`</span>wg0.conf<span style="color:#e6db74">`</span> 文件里 <span style="color:#e6db74">`</span><span style="color:#f92672">[</span>Peer<span style="color:#f92672">]</span><span style="color:#e6db74">`</span> 部分的 <span style="color:#e6db74">`</span>PublicKey<span style="color:#e6db74">`</span> 字段。然后在VPS上重启WireGuard <span style="color:#f92672">(</span><span style="color:#e6db74">`</span>sudo wg-quick down wg0 <span style="color:#f92672">&amp;&amp;</span> sudo wg-quick up wg0<span style="color:#e6db74">`</span><span style="color:#f92672">)</span>。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 3. 配置Dnsmasq</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>*   **主配置文件 <span style="color:#f92672">(</span><span style="color:#e6db74">`</span>/etc/dnsmasq.conf<span style="color:#e6db74">`</span><span style="color:#f92672">)</span>**:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">```</span>bash
</span></span><span style="display:flex;"><span>    sudo nano /etc/dnsmasq.conf
</span></span></code></pre></div><pre><code>清空并填入以下内容 (将`192.168.1.1`替换为您的网关实际IP):
```ini
resolv-file=/etc/resolv.dnsmasq.conf
strict-order
listen-address=127.0.0.1,192.168.1.1
bind-interfaces
conf-dir=/etc/dnsmasq.d,*.conf
cache-size=10000
no-poll
no-hosts
```
</code></pre>
<ul>
<li><strong>上游DNS服务器文件 (<code>/etc/resolv.dnsmasq.conf</code>)</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/resolv.dnsmasq.conf
</span></span></code></pre></div>填入（这是未匹配到任何规则时，默认使用的DNS）：
<pre tabindex="0"><code>nameserver 8.8.8.8
</code></pre></li>
</ul>
<h3 id="4-创建自动化与路由脚本">4. 创建自动化与路由脚本<a hidden class="anchor" aria-hidden="true" href="#4-创建自动化与路由脚本">#</a></h3>
<p>您需要手动创建以下三个脚本。</p>
<ul>
<li>
<p><strong>脚本1: 更新规则库 (<code>/usr/local/bin/update-lists.sh</code>)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /usr/local/bin/update-lists.sh
</span></span></code></pre></div><p>粘贴以下内容（<strong>已包含详细注释</strong>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e"># 脚本的开头，声明使用bash解释器来执行。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># set -e 是一个安全设置。它告诉脚本，如果任何命令执行后返回非零的退出状态（通常表示错误），</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 整个脚本将立即停止执行。这可以防止在某个步骤失败后，脚本继续执行错误或不完整的操作。</span>
</span></span><span style="display:flex;"><span>set -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 变量定义 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 定义一些常用的路径和文件名，方便后续引用和修改。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># gfwlist2dnsmasq 工具的存放目录</span>
</span></span><span style="display:flex;"><span>GFWLIST2DNSMASQ_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/opt/gfwlist2dnsmasq&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># dnsmasq-china-list 项目的存放目录</span>
</span></span><span style="display:flex;"><span>CHINA_LIST_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/opt/dnsmasq-china-list&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Dnsmasq 加载额外配置文件的目录</span>
</span></span><span style="display:flex;"><span>DNSMASQ_CONF_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/etc/dnsmasq.d&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 由 gfwlist 生成的 Dnsmasq 配置文件路径</span>
</span></span><span style="display:flex;"><span>DNSMASQ_CONF_GFWLIST<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_DIR<span style="color:#e6db74">/gfwlist.conf&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 我们自己处理并合并后的国内域名 Dnsmasq 配置文件路径</span>
</span></span><span style="display:flex;"><span>DNSMASQ_CONF_CHINA_LIST_MERGED<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_DIR<span style="color:#e6db74">/china-list.conf&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 定义需要处理的国内域名列表源文件名数组</span>
</span></span><span style="display:flex;"><span>CHINA_LIST_SOURCE_FILES<span style="color:#f92672">=(</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;accelerated-domains.china.conf&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;apple.china.conf&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;google.china.conf&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 1/4: Updating gfwlist rules...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查 gfwlist2dnsmasq 工具目录是否存在。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -d <span style="color:#e6db74">&#34;</span>$GFWLIST2DNSMASQ_DIR<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># 如果目录不存在 (! -d)，说明是第一次运行，就从 GitHub 克隆 (clone) 整个项目到指定目录。</span>
</span></span><span style="display:flex;"><span>  git clone https://github.com/cokebar/gfwlist2dnsmasq.git <span style="color:#e6db74">&#34;</span>$GFWLIST2DNSMASQ_DIR<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 cd 命令进入该工具的目录，并用 git pull 拉取最新的更新。</span>
</span></span><span style="display:flex;"><span>cd <span style="color:#e6db74">&#34;</span>$GFWLIST2DNSMASQ_DIR<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&amp;&amp;</span> git pull
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 执行 gfwlist2dnsmasq.sh 脚本，生成 Dnsmasq 配置文件。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -d 8.8.8.8: 指定解析这些域名时使用的DNS服务器。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -s gfwlist: 指定解析出的IP要加入名为 &#34;gfwlist&#34; 的 ipset 集合。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -o &#34;...&#34;: 指定输出配置文件的路径。</span>
</span></span><span style="display:flex;"><span>./gfwlist2dnsmasq.sh -d 8.8.8.8 -s gfwlist -o <span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_GFWLIST<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 2/4: Updating and processing domestic domain lists...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查 dnsmasq-china-list 的本地仓库目录是否存在。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -d <span style="color:#e6db74">&#34;</span>$CHINA_LIST_DIR<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># 如果不存在，就从 GitHub 克隆项目。</span>
</span></span><span style="display:flex;"><span>  git clone https://github.com/felixonmars/dnsmasq-china-list.git <span style="color:#e6db74">&#34;</span>$CHINA_LIST_DIR<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 进入该目录并拉取最新更新。</span>
</span></span><span style="display:flex;"><span>cd <span style="color:#e6db74">&#34;</span>$CHINA_LIST_DIR<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&amp;&amp;</span> git pull
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 自动化处理核心 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 &gt; 操作符，清空或创建我们即将写入的合并配置文件。这可以确保每次运行时都是一个全新的文件。</span>
</span></span><span style="display:flex;"><span>&gt; <span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_CHINA_LIST_MERGED<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Processing china-list files to add ipset directive...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 for 循环，遍历上面定义的国内域名列表源文件名数组。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> file in <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>CHINA_LIST_SOURCE_FILES[@]<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># sed 是一个强大的文本处理工具。这行命令是整个自动化方案的关键之一。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># &#39;s|...|...|&#39;: s 代表替换 (substitute)。我们用 | 作为分隔符，避免与路径中的 / 冲突。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># &#39;s|/\([^/]*\)$|/\1\nipset=/\1/directlist|&#39;:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#   - `/\([^/]*\)$`: 这是要查找的模式。它匹配以 &#34;/&#34; 开头，后面跟着一串不包含 &#34;/&#34; 的字符，直到行尾。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     例如，它会匹配 &#39;server=/qq.com/119.29.29.29&#39; 中的 &#39;/qq.com&#39;。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     `\(` 和 `\)` 用于创建一个&#34;捕获组&#34;，把匹配到的域名（如 &#39;qq.com&#39;）存起来。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#   - `/\1\nipset=/\1/directlist`: 这是替换后的内容。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     `\1` 代表第一个捕获组的内容（即域名）。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     `\n` 代表换行符。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     所以，这整段的意思是：在原始行（如 &#39;server=/qq.com/...&#39;）的后面，换一行，并插入 &#39;ipset=/qq.com/directlist&#39;。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># `&#34;${CHINA_LIST_DIR}/${file}&#34;`: 这是 sed 命令要处理的输入文件。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># `&gt;&gt; &#34;$DNSMASQ_CONF_CHINA_LIST_MERGED&#34;`: `&gt;&gt;` 是追加重定向，将 sed 处理后的结果追加到我们合并的配置文件中。</span>
</span></span><span style="display:flex;"><span>  sed <span style="color:#e6db74">&#39;s|/\([^/]*\)$|/\1\nipset=/\1/directlist|&#39;</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>CHINA_LIST_DIR<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>file<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> &gt;&gt; <span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_CHINA_LIST_MERGED<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 3/4: Cleaning up old china-list files...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 为了避免 Dnsmasq 加载我们处理前的原始文件，造成规则冲突或重复，这里将它们从配置目录中删除。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># rm -f: -f (force) 表示即使文件不存在也不报错。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> file in <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>CHINA_LIST_SOURCE_FILES[@]<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    rm -f <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>DNSMASQ_CONF_DIR<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>file<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 4/4: Restarting Dnsmasq...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 所有规则都已更新并处理完毕，现在重启 Dnsmasq 服务以加载所有新的配置文件。</span>
</span></span><span style="display:flex;"><span>sudo systemctl restart dnsmasq
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Update process finished.&#34;</span>
</span></span></code></pre></div></li>
<li>
<p><strong>脚本2: 应用防火墙和路由规则 (<code>/usr/local/bin/apply-routing-rules.sh</code>)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /usr/local/bin/apply-routing-rules.sh
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>    粘贴以下内容：
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>bash
</span></span><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash</span>
</span></span><span style="display:flex;"><span>set -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 变量定义 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># FW_MARK: 防火墙标记，用于策略路由。可以任意，但通常用WireGuard端口号便于识别。</span>
</span></span><span style="display:flex;"><span>FW_MARK<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;51820&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># TABLE_ID: 自定义路由表的ID。避免与系统已使用的表冲突，100是一个安全的选择。</span>
</span></span><span style="display:flex;"><span>TABLE_ID<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;100&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># FOREIGN_DNS: 我们指定的国外/上游DNS服务器，用于DNS防泄漏。</span>
</span></span><span style="display:flex;"><span>FOREIGN_DNS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;8.8.8.8&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 1/3: Initializing ipsets...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 初始化IP集合 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 销毁并创建 gfwlist 和新的 directlist 集合，确保每次应用都是干净的状态。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2&gt;/dev/null: 将可能出现的&#34;集合不存在&#34;的错误信息重定向到&#34;黑洞&#34;，避免在首次运行时报错。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># || true: 即使ipset destroy命令失败（比如集合不存在），也确保脚本继续执行。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># timeout 86400: 设置ipset中条目的默认超时时间为一天(86400秒)，之后会自动过期。</span>
</span></span><span style="display:flex;"><span>ipset destroy gfwlist 2&gt;/dev/null <span style="color:#f92672">||</span> true; ipset create gfwlist hash:ip,family inet,timeout <span style="color:#ae81ff">86400</span>
</span></span><span style="display:flex;"><span>ipset destroy directlist 2&gt;/dev/null <span style="color:#f92672">||</span> true; ipset create directlist hash:ip,family inet,timeout <span style="color:#ae81ff">86400</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 2/3: Configuring firewall and policy routing (Default Proxy Mode)...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 清理旧规则 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -t mangle: 指定操作mangle表。-F: Flush，清空链。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># PREROUTING链: 处理进入本机、需要转发给局域网其他设备的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># OUTPUT链: 处理本机自己产生的数据包。</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -F PREROUTING; iptables -t mangle -F OUTPUT; iptables -t filter -F OUTPUT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 流量标记 (Mangle Table) ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># [策略反转]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 规则1: 优先标记本机发往国外DNS的查询请求，确保DNS解析本身走隧道，防止被窥探。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -p udp --dport 53: 匹配协议为udp、目标端口为53（DNS）的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -d $FOREIGN_DNS: 匹配目标地址是8.8.8.8的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -j MARK --set-mark $FW_MARK: 对匹配的数据包打上标记。</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -A OUTPUT -p udp --dport <span style="color:#ae81ff">53</span> -d $FOREIGN_DNS -j MARK --set-mark $FW_MARK
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 规则2: 白名单规则。如果流量的目标IP在直连白名单(directlist)中，则直接返回(RETURN)，</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 不进行后续任何标记。这意味着它将走系统默认路由（即本地网络出口）。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -m set --match-set directlist dst: 匹配目标IP(dst)在名为directlist的集合中的数据包。</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -A PREROUTING -m set --match-set directlist dst -j RETURN
</span></span><span style="display:flex;"><span>iptables -t mangle -A OUTPUT -m set --match-set directlist dst -j RETURN
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 规则3: 默认标记规则。对于所有不满足上一条白名单规则的流量，全部无条件打上标记。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这包括了gfwlist的流量和所有未知的互联网流量。</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -A PREROUTING -j MARK --set-mark $FW_MARK
</span></span><span style="display:flex;"><span>iptables -t mangle -A OUTPUT -j MARK --set-mark $FW_MARK
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Kill Switch (Filter Table) ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 在OUTPUT链顶部插入规则：如果数据包有标记但出口不是wg0，则丢弃(DROP)。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这是防止VPN断开时，被标记的流量从本地出口泄露真实IP。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -I OUTPUT 1: 在OUTPUT链的第1个位置插入此规则，确保最先被匹配。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -m mark --mark $FW_MARK: 匹配带有我们设置的标记的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ! -o wg0: 匹配出口网卡 *不是* wg0 的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -j DROP: 丢弃数据包。</span>
</span></span><span style="display:flex;"><span>iptables -I OUTPUT <span style="color:#ae81ff">1</span> -m mark --mark $FW_MARK ! -o wg0 -j DROP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 策略路由 ---</span>
</span></span></code></pre></div></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="//localhost:1313/tags/%E7%BD%91%E7%BB%9C/">网络</a></li>
      <li><a href="//localhost:1313/tags/wireguard/">WireGuard</a></li>
      <li><a href="//localhost:1313/tags/ipset/">Ipset</a></li>
      <li><a href="//localhost:1313/tags/dns/">DNS</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="//localhost:1313/">star徐的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
