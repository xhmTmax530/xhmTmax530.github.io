<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>注解和Map(新手理解) | star徐的博客</title><meta name=keywords content="Java,java注解,Web开发,基础编程,HashMap"><meta name=description content='注解和Map(新手理解)
把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。
Map 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：

第一列叫“键”（Key）
第二列叫“值”（Value）

只要给出一个 Key，就能立刻找到它对应的 Value。
常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。
举个生活化的例子：
如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。
注解和 Map 的关系
注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。
你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：

注解里的每一个属性（比如 @MyAnnotation(value="test", version=2) 中的 value、version）
都会被放进一个 Map 里，key 就是属性名，value 就是属性值。
当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。

所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景：
灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。

一句话总结
Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。
一、🎯 目标：
我们想做一个“用户信息校验”功能，比如：

用户名不能超过10个字符
年龄必须在18到60之间
邮箱必须包含 @ 符号

但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。'><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="注解和Map(新手理解)"><meta property="og:description" content='注解和Map(新手理解) 把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。
Map 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：
第一列叫“键”（Key） 第二列叫“值”（Value） 只要给出一个 Key，就能立刻找到它对应的 Value。 常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。
举个生活化的例子： 如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。
注解和 Map 的关系 注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。 你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：
注解里的每一个属性（比如 @MyAnnotation(value="test", version=2) 中的 value、version） 都会被放进一个 Map 里，key 就是属性名，value 就是属性值。 当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。 所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景： 灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。
一句话总结 Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。
一、🎯 目标： 我们想做一个“用户信息校验”功能，比如：
用户名不能超过10个字符 年龄必须在18到60之间 邮箱必须包含 @ 符号 但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-21T10:50:00+08:00"><meta property="article:modified_time" content="2025-11-21T10:50:00+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Java注解"><meta property="article:tag" content="Web开发"><meta property="article:tag" content="基础编程"><meta property="article:tag" content="HashMap"><meta name=twitter:card content="summary"><meta name=twitter:title content="注解和Map(新手理解)"><meta name=twitter:description content='注解和Map(新手理解)
把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。
Map 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：

第一列叫“键”（Key）
第二列叫“值”（Value）

只要给出一个 Key，就能立刻找到它对应的 Value。
常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。
举个生活化的例子：
如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。
注解和 Map 的关系
注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。
你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：

注解里的每一个属性（比如 @MyAnnotation(value="test", version=2) 中的 value、version）
都会被放进一个 Map 里，key 就是属性名，value 就是属性值。
当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。

所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景：
灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。

一句话总结
Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。
一、🎯 目标：
我们想做一个“用户信息校验”功能，比如：

用户名不能超过10个字符
年龄必须在18到60之间
邮箱必须包含 @ 符号

但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"注解和Map(新手理解)","item":"http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"注解和Map(新手理解)","name":"注解和Map(新手理解)","description":"注解和Map(新手理解) 把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。\nMap 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：\n第一列叫“键”（Key） 第二列叫“值”（Value） 只要给出一个 Key，就能立刻找到它对应的 Value。 常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。\n举个生活化的例子： 如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。\n注解和 Map 的关系 注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。 你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：\n注解里的每一个属性（比如 @MyAnnotation(value=\u0026quot;test\u0026quot;, version=2) 中的 value、version） 都会被放进一个 Map 里，key 就是属性名，value 就是属性值。 当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。 所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景： 灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。\n一句话总结 Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。\n一、🎯 目标： 我们想做一个“用户信息校验”功能，比如：\n用户名不能超过10个字符 年龄必须在18到60之间 邮箱必须包含 @ 符号 但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。\n","keywords":["Java","java注解","Web开发","基础编程","HashMap"],"articleBody":"注解和Map(新手理解) 把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。\nMap 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：\n第一列叫“键”（Key） 第二列叫“值”（Value） 只要给出一个 Key，就能立刻找到它对应的 Value。 常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。\n举个生活化的例子： 如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。\n注解和 Map 的关系 注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。 你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：\n注解里的每一个属性（比如 @MyAnnotation(value=\"test\", version=2) 中的 value、version） 都会被放进一个 Map 里，key 就是属性名，value 就是属性值。 当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。 所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景： 灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。\n一句话总结 Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。\n一、🎯 目标： 我们想做一个“用户信息校验”功能，比如：\n用户名不能超过10个字符 年龄必须在18到60之间 邮箱必须包含 @ 符号 但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。\n二、源码展示及分析 ✅ 第一步：定义一个注解 @ValidationRule import java.lang.annotation.*; // 这个注解可以加在字段（field）上 @Target(ElementType.FIELD) // 注解信息要保留到运行时，才能用反射读取 @Retention(RetentionPolicy.RUNTIME) public @interface ValidationRule { // 规则类型：比如 \"maxLength\", \"minValue\", \"pattern\" 等 String type(); // 规则的值，比如最大长度是10，最小年龄是18 int value() default 0; // 用于正则匹配的字符串，比如邮箱格式 String pattern() default \"\"; // 错误提示信息 String message() default \"该字段不符合规则\"; } 🔍 逐行解释：\n@Target(ElementType.FIELD)：说明这个注解只能用在“字段”上，比如类里的变量。\n@Retention(RetentionPolicy.RUNTIME)：表示这个注解在程序运行时还能被读取（靠反射）。\npublic @interface ValidationRule：声明一个叫 ValidationRule 的注解（不是类！是标签）。\nString type()：定义一个叫 type 的属性，用来表示规则类型，比如 \"maxLength\"。\nint value() default 0：定义一个整数型规则值，比如最大长度是10，不写就默认是0。\nString pattern()：用于正则表达式，比如邮箱格式 \".*@.*\\\\.com\"。\nString message()：出错时显示的提示语。\nString message()：出错时显示的提示语。\n✅ 第二步：创建一个用户类，用注解标注字段规则 public class User { @ValidationRule( type = \"maxLength\", value = 10, message = \"用户名不能超过10个字符\" ) private String username; @ValidationRule( type = \"minValue\", value = 18, message = \"年龄不能小于18\" ) @ValidationRule( type = \"maxValue\", value = 60, message = \"年龄不能大于60\" ) private int age; @ValidationRule( type = \"pattern\", pattern = \".*@.*\\\\.com\", message = \"邮箱必须包含@且以.com结尾\" ) private String email; // 构造方法 public User(String username, int age, String email) { this.username = username; this.age = age; this.email = email; } // getter 方法，方便外部读取字段 public String getUsername() { return username; } public int getAge() { return age; } public String getEmail() { return email; } } 🔍 解释：\n我们给 username、age、email 字段都加上了 @ValidationRule 注解。 每个注解都写了具体的规则（type、value、pattern、message）。 注意：age 有两个注解，一个限制最小值，一个最大值，Java 是允许一个字段加多个注解的！ ✅ 第三步：写一个校验器，把注解信息读出来，存进 Map，然后做校验 import java.lang.reflect.Field; import java.util.*; public class Validator { // 校验任意对象的方法 public static List\u003cString\u003e validate(Object obj) { List\u003cString\u003e errors = new ArrayList\u003c\u003e(); // 存放所有错误信息 // 获取这个对象的类结构（反射） Class\u003c?\u003e clazz = obj.getClass(); // 获取类里的所有字段（比如 username, age, email） Field[] fields = clazz.getDeclaredFields(); // 遍历每个字段 for (Field field : fields) { // 打开权限，让我们可以访问 private 字段 field.setAccessible(true); // 获取这个字段上的所有 @ValidationRule 注解 ValidationRule[] rules = field.getAnnotationsByType(ValidationRule.class); // 如果这个字段没有注解，跳过 if (rules.length == 0) continue; // 获取字段的当前值，比如 username 的值是 \"zhangsan\" Object value = null; try { value = field.get(obj); // 获取字段的实际值 } catch (IllegalAccessException e) { errors.add(field.getName() + \" 字段无法访问\"); continue; } // 把这个字段的所有规则放进一个 Map，方便查找和处理 Map\u003cString, Object\u003e ruleMap = new HashMap\u003c\u003e(); for (ValidationRule rule : rules) { // 把每个规则的 type 作为 key，整个注解对象作为 value ruleMap.put(rule.type(), rule); } // 开始根据规则校验 for (ValidationRule rule : rules) { String type = rule.type(); String msg = rule.message(); switch (type) { case \"maxLength\": if (value instanceof String \u0026\u0026 ((String) value).length() \u003e rule.value()) { errors.add(msg); } break; case \"minValue\": if (value instanceof Integer \u0026\u0026 (int) value \u003c rule.value()) { errors.add(msg); } break; case \"maxValue\": if (value instanceof Integer \u0026\u0026 (int) value \u003e rule.value()) { errors.add(msg); } break; case \"pattern\": if (value instanceof String \u0026\u0026 !((String) value).matches(rule.pattern())) { errors.add(msg); } break; } } } return errors; // 返回所有错误信息 } } 🔍 重点解释：\nfield.getAnnotationsByType(...)：反射读取字段上的所有 @ValidationRule 注解。\nMap ruleMap：我们把每个规则的 type（如 \"maxLength\"）作为 key，把整个注解对象存进去。这就是“注解 → Map”的典型用法！\n为什么要用 Map？因为后面查规则更快，比如你想知道有没有 minValue 规则，直接 ruleMap.containsKey(\"minValue\") 就行。\nswitch (type)：根据规则类型做不同的校验。\nerrors：收集所有错误提示，最后一起返回。\nerrors：收集所有错误提示，最后一起返回。\n✅ 第四步：测试代码 public class Main { public static void main(String[] args) { // 创建一个“有问题”的用户 User user = new User(\"zhangsan123\", 16, \"abc@163.net\"); // 调用校验器 List\u003cString\u003e result = Validator.validate(user); // 输出结果 if (result.isEmpty()) { System.out.println(\"✅ 校验通过！\"); } else { System.out.println(\"❌ 校验失败：\"); for (String error : result) { System.out.println(\" - \" + error); } } } } 📌 运行结果：\n❌ 校验失败： - 用户名不能超过10个字符 - 年龄不能小于18 - 邮箱必须包含@且以.com结尾 ✅ 总结：注解 + Map 的好处 优点 说明 ✅ 解耦 校验规则写在注解里，校验逻辑在 Validator 里，改规则不用动代码 ✅ 可读性强 看字段就知道它有哪些限制 ✅ 灵活扩展 想加新规则（比如 required），只需加个 type 就行 ✅ Map 提高效率 把注解信息转成 Map，方便快速查找和管理 💡 最后一句话： 注解是“贴在代码上的标签”，Map 是“运行时的规则仓库”。 我们用注解声明规则，用反射读取注解，再把它们放进 Map 动态处理——这就是现代 Java 框架（如 Spring、Hibernate）的常用套路！\n三、校验器源码解析 我们想通过 反射 读取类中所有字段上的 @ValidationRule 注解，并将这些注解的规则信息存入 Map，方便后续校验。\n✅ 完整的 validate 方法代码（逐行解释） // 定义一个静态方法 validate，接收一个对象 obj，返回错误信息列表 public static List\u003cString\u003e validate(Object obj) { public：表示这个方法可以被其他类访问。 static：表示这是一个“类方法”，可以直接用类名调用，不需要创建对象。 List：返回值类型是一个字符串列表（比如 [“错误1”, “错误2”]）。 Object obj：参数类型是“对象”，可以传任何类型的对象（比如 User、Order）。 List\u003cString\u003e errors = new ArrayList\u003c\u003e(); // 用于收集所有错误信息 List：声明一个字符串列表，用来装错误信息。 new ArrayList\u003c\u003e()：创建一个新的空列表，\u003c\u003e 是 Java 7+ 的语法，表示自动推断泛型类型。 errors：变量名，你可以理解为“错误清单”。 🧩 步骤 1：获取类的 Class 对象 Class\u003c?\u003e clazz = obj.getClass(); 解释： obj.getClass() 就是获取 obj 这个对象的“身份证号码”——它的类类型。 比如，如果 obj 是一个 User 类的对象，那么 clazz 就是 User.class，相当于拿到了 User 类的“蓝图”。 🧩 步骤 2：获取类的所有字段 Field[] fields = clazz.getDeclaredFields(); 解释： getDeclaredFields() 就是查看 User 类的“成员表”——所有字段（比如 username、age、email） 注意：这个方法会返回所有字段，包括 private（私有）字段，因为我们调用了 field.setAccessible(true)（后面会讲）。 🧩 步骤 3：遍历每个字段 for (Field field : fields) { 解释： 这个循环就是挨个查看 User 类的每个字段，比如先看 username，再看 age，最后看 email。 🧩 步骤 4：打开字段的“访问权限” field.setAccessible(true); 解释： 如果字段是 private（私有），默认不能直接访问。 setAccessible(true) 就像给私有字段开了个“后门”，允许我们绕过 Java 的访问控制规则去读取它的值。 🧩 步骤 5：获取字段上的所有 @ValidationRule 注解 ValidationRule[] rules = field.getAnnotationsByType(ValidationRule.class); 解释： getAnnotationsByType(...) 就是问这个字段：“你身上贴了哪些 @ValidationRule 的标签？”\n比如，username 字段上有 1 个 @ValidationRule，age 字段上有 2 个（因为写了两个注解）。\n返回的结果是一个数组，里面装着所有贴在字段上的 @ValidationRule 注解。\n🧩 步骤 6：检查是否有注解 if (rules.length == 0) continue; 解释： 如果字段上没有贴 @ValidationRule 标签，就跳过这个字段（继续处理下一个字段）。 🧩 步骤 7：获取字段的实际值 Object value = field.get(obj); 解释： field.get(obj) 就是问：“这个字段的实际值是多少？” 比如，如果 obj.username 是 \"zhangsan\"，那么 value 就是 \"zhangsan\"。 🧩 步骤 8：把注解信息存入 Map Map ruleMap = new HashMap\u003c\u003e(); for (ValidationRule rule : rules) { ruleMap.put(rule.type(), rule); } 解释\n这一步是把每个注解的 type（比如 \"maxLength\"）作为 键，整个注解对象作为 值，存入 ruleMap\n为什么要用 Map？因为后续校验时，我们可以直接通过 ruleMap.containsKey(\"maxLength\") 快速判断是否有某个规则。 🧩 步骤 9：根据规则类型执行校验 switch (type) { case \"maxLength\": if (value instanceof String \u0026\u0026 ((String) value).length() \u003e rule.value()) { errors.add(msg); } break; // 其他 case 类似 } 解释： 这一步是根据注解的 type（比如 \"maxLength\"）执行不同的校验逻辑： 如果是 maxLength，就检查字符串长度是否超过限制。 如果是 minValue，就检查数值是否小于最小值。 🧩 步骤 10：收集所有错误信息 List\u003cString\u003e errors = new ArrayList\u003c\u003e(); // ... 校验失败时添加错误信息 return errors; 解释： 如果校验失败，就把错误提示（比如 \"用户名不能超过10个字符\"）加到 errors 列表中。 最后返回 errors，这样调用者就能知道哪里出错了。 🧠 总结：为什么用反射 + Map？ 步骤 做了什么 为什么这样做 1. 获取 Class 对象 看到类的“身份证” 反射的第一步，才能操作类的结构 2. 获取字段列表 查看类的“成员表” 遍历所有字段，检查是否有注解 3. 打开字段权限 开启“后门”访问私有字段 绕过 Java 的访问控制 4. 读取注解 查看字段上的“标签” 获取校验规则（比如最大长度） 5. 存入 Map 把规则存成“键值表” 后续校验时能快速查找规则 6. 执行校验 根据规则类型做不同判断 动态校验，无需硬编码规则 🍱 举个生活化的例子： 假设你是一个餐厅的厨师，需要根据菜单（注解）来做菜：\n菜单（注解）： @ValidationRule(type=\"maxLength\", value=10) 就像菜单上写着“这道菜最多只能放10克盐”。 @ValidationRule(type=\"pattern\", pattern=\".*@.*\\\\.com\") 就像菜单上写着“这道菜必须包含葱花和姜丝”。 厨师（反射）： 你拿到菜单（注解），然后查看每道菜（字段）的规则。 你把规则存到“厨房备忘录”（Map）里，方便快速查找。 根据规则做菜（校验），如果做错了（校验失败），就记录错误（加到 errors 列表）。 🧩 总结：完整流程图解 传入一个对象（如 User） ↓ 获取它的类（User.class） ↓ 拿到所有字段（username, age, email） ↓ 逐个字段检查是否有 @ValidationRule 注解 ↓ 如果有，就用反射读取字段的值（比如 username = \"zhangsan\"） ↓ 根据注解里的 type（如 \"maxLength\"）判断是否符合规则 ↓ 不符合 → 添加错误信息到 errors 列表 ↓ 最后返回所有错误 ✅ 最后一句话： 反射是“动态查看代码结构”的工具，注解是“贴在代码上的配置标签”。 通过反射读取注解，并将规则存入 Map，我们就能实现“配置驱动”的校验逻辑——规则写在注解里，逻辑写在代码里，两者解耦，灵活又高效！\n额外补充(和主题无关)： 我们之前在讲解 第三步 的 Validator.validate() 方法时，确实漏掉了一小段关键代码——那就是 try-catch 异常处理块。\n🔍 补充解释：被遗漏的关键部分 try { ... } catch (IllegalAccessException e) { ... } jtry { value = field.get(obj); } catch (IllegalAccessException e) { errors.add(field.getName() + \" 字段无法访问\"); continue; } 为什么需要 try-catch？ 虽然我们用了 field.setAccessible(true) 打开了权限，但某些特殊情况下仍然可能访问失败，比如：\n字段被 final 修饰且无法读取 安全管理器（SecurityManager）禁止反射访问 模块系统限制（Java 9+） 这些情况会抛出 IllegalAccessException 异常。\ntry 是什么意思？ “尝试做这件事”：尝试读取字段的值。\ncatch 是什么意思？ “如果出错了，就在这里处理”：如果读取失败，就给用户一个友好的提示，比如 \"username 字段无法访问\"，然后跳过这个字段，继续检查下一个字段。\ncontinue 的作用 跳过当前字段，进入 for 循环的下一次迭代，避免程序因为一个字段出错而直接崩溃。\n✅ 这就是“健壮性”——即使部分出错，也要尽量完成其他任务。\n四、我的疑问点： 1. 实际中知道有 ValidationRule.class 吗？ ✅ 知道，而且必须知道。\nValidationRule.class 是你自己定义的注解类（就像你写的 User 类一样）。 因为你在字段上用了 @ValidationRule(...)，所以程序运行时肯定要读这个注解，就必须明确告诉 Java：“我要找的是 ValidationRule 这个注解”。 就像你去快递站取件，必须说清楚“我取的是张三的包裹”，不能只说“我取个包裹”。 📌 总结：ValidationRule.class 是你自己写的，编译器和 JVM 都认识它，所以能用。\n2. 为什么要根据类型对 value 做不同判断？ ✅ 因为不同的规则，检查的东西完全不同！\n举个例子：\n规则类型 要检查什么 数据类型 检查方式 \"maxLength\" 字符串长度 String 看 .length() 是否超限 \"minValue\" 数字最小值 int / Integer 看是否 \u003c rule.value() \"pattern\" 格式是否匹配 String 用正则 .matches() 👉 如果不区分类型：\n你拿一个字符串去和 minValue=18 比大小？会出错！ 你拿一个整数去调 .matches()？根本没这个方法！ 📌 总结：不同类型的数据，要用不同的方法检查，所以必须通过 type 来分支处理。\n3.编译器（Compiler） 和 JVM（Java 虚拟机） 的工作讲清楚 🧱 举个生活例子：做一道菜\n想象你要做一道“红烧肉”：\n编译器 = 厨师看菜谱，检查步骤对不对（比如有没有写“放盐”却没写“放肉”） JVM = 真正下锅炒菜、尝味道、端上桌的人 编译器负责“检查和翻译”，JVM 负责“真正执行”\n4.编译器（javac）—— 干活阶段：写完代码之后，运行之前 ✅ 它做什么？\n加载 .class 文件 把编译好的字节码读进内存（比如 User.class, Validator.class）。 验证字节码 确保字节码是合法的、安全的（防止恶意代码）。 解释/编译执行 把字节码一行行翻译成机器能执行的指令（有的还会用 JIT 编译成更快的本地代码）。 管理内存 分配对象内存（堆）、回收垃圾（GC）。 处理运行时行为 比如：反射（field.get(obj)）、异常（NullPointerException）、多线程。 读取运行时注解 如果注解用了 @Retention(RetentionPolicy.RUNTIME)，JVM 会在运行时保留它，并允许你用反射读取（比如我们的 @ValidationRule）。 ⏱️ 工作阶段：\n运行阶段 → 你执行 java Main 时，JVM 才启动并开始干活。\n🔧 特点：\n真正让程序跑起来。 能处理动态行为：比如不知道字段名是什么，但运行时通过反射拿到。 会抛运行时异常：比如空指针、数组越界，这些编译器没法提前知道。 🆚 对比总结表\n项目 编译器（javac） JVM 什么时候工作？ 写完代码后，运行前 程序真正运行时 输入是什么？ .java 源代码 .class 字节码 输出是什么？ .class 字节码文件 程序运行结果（打印、计算、网络请求等） 能发现什么错误？ 语法错误、类型错误 空指针、除零、数组越界等 能处理注解吗？ 只处理编译期注解（如 @Override） 能处理运行时注解（如 @ValidationRule） 是否需要安装？ 需要 JDK（含 javac） 需要 JRE 或 JDK（含 JVM） 💡 回到你的例子\n在你的校验代码中：\n编译器：检查 @ValidationRule 注解定义是否正确，字段是否拼写对。 JVM：运行时通过 field.getAnnotationsByType(...) 读取注解，并把规则放进 Map，再校验数据。 所以：注解要生效，必须靠 JVM 在运行时读取；而编译器只负责确保注解语法没错。\n五、注解 @ValidationRule源码解析 🧩 整体目标： 我们要自己发明一个标签（注解），名字叫 @ValidationRule，以后可以贴在字段上，比如：\n@ValidationRule(type = \"maxLength\", value = 10) private String username; 这个标签的作用是：告诉程序“这个字段要满足某种校验规则”。\n现在，我们来看看怎么“发明”这个标签。\n第一行：导入包 import java.lang.annotation.*; 意思：我要用 Java 里专门用来写“注解”的工具，所以先把这些工具引进来。 类比：就像你要画画，得先准备好画笔和颜料一样。 第二行：指定这个注解能贴在哪里 @Target(ElementType.FIELD) @Target：这是一个“元注解”——就是“用来描述注解的注解”。\nElementType.FIELD：表示你写的这个 @ValidationRule 只能贴在 字段（field） 上。\n字段就是类里的变量，比如 private String name;\n不能贴在哪？ 比如不能贴在方法上（public void run()）、类上（class User）等，除非你改这里。\n✅ 总结：这行规定了你的标签只能贴在“成员变量”上。\n第三行：指定这个注解保留到什么时候 @Retention(RetentionPolicy.RUNTIME) @Retention：另一个“元注解”，意思是“这个标签要保留多久？” RetentionPolicy.RUNTIME：表示这个标签一直保留到程序运行的时候 这样你才能在程序运行时，用“反射”去读它（比如我们的校验器 Validator 就是在运行时读的）。 其他选项（不用记，了解就行）： SOURCE：只在写代码时有用，编译完就扔掉（比如 @Override 实际是 SOURCE 级别，但 JDK 特殊处理了）。 CLASS：编译后保留在 .class 文件里，但运行时看不到（默认值）。 ✅ 总结：这行保证你的标签在程序跑起来后还能被读到！\n第四行：开始定义自己的注解 public @interface ValidationRule { public：这个注解可以被其他类使用。 @interface：这是关键！它不是普通类，而是定义一个注解类型 就像 class User 定义一个类，@interface ValidationRule 定义一个注解。 ValidationRule：你给这个注解起的名字，以后就用 @ValidationRule 来贴标签。 ✅ 总结：从这行开始，你在“设计一个新标签”。\n接下来的几行：定义标签里能填什么内容 注解不是光秃秃的，它可以带“参数”，就像函数有参数一样。\n1. 规则类型 String type(); 表示这个注解必须提供一个叫 type 的字符串。 使用时写成：@ValidationRule(type = \"maxLength\") 注意：没有 {}，也没有 return，因为注解里的方法只是“声明参数”，不是真正的方法！ 2. 规则的数值（可选） int value() default 0; 表示可以传一个整数，比如最大长度、最小年龄。 default 0：如果不写这个参数，默认值是 0。 使用时：@ValidationRule(type = \"maxLength\", value = 10) 3. 正则表达式（可选） String pattern() default \"\"; 用于格式校验，比如邮箱、手机号。 默认是空字符串 \"\"，表示不用正则。 使用时：@ValidationRule(type = \"pattern\", pattern = \".*@.*\\\\.com\") 4. 错误提示（可选） String message() default \"该字段不符合规则\"; 如果校验失败，显示什么错误信息。 如果你不写 message = \"...\"，就用默认的这句话。 ✅ 最终效果：你可以这样用这个注解\npublic class User { @ValidationRule( type = \"maxLength\", value = 10, message = \"用户名太长了！\" ) private String username; } 这个字段被贴了一个标签，里面包含了： 类型：\"maxLength\" 值：10 提示语：\"用户名太长了！\" 然后你的 Validator 类就能在运行时读到这些信息，并做校验！\n🧠 小白重点记住： 代码 作用 @Target(ElementType.FIELD) 这个标签只能贴在字段上 @Retention(RetentionPolicy.RUNTIME) 程序运行时还能读到它 String type(); 标签必须有一个 type 参数 int value() default 0; 可以传一个数字，不传就当 0 public @interface ... 这是在定义一个新的注解 💡 最后一句话： 注解就像是你给代码贴的“便利贴”，上面写着各种说明；而 @Target 和 @Retention 是规定这张便利贴能贴在哪、能保留多久。\n六、检查用户名流程 🎬 场景设定 你有一个用户类：\npublic class User { @ValidationRule( type = \"maxLength\", value = 10, message = \"用户名太长了！\" ) private String username; } 现在你想：创建一个用户，然后自动检查他的用户名有没有超过10个字符。\n🚶‍♂️ 第一步：创建 User 对象（准备“食材”） User user = new User(); user.username = \"这是一个超长的用户名\"; // 长度是12 此时，user 是一个对象，它的 username 字段值为 \"这是一个超长的用户名\"（12个字）。\n🧪 第二步：调用校验方法（交给“质检员”） List\u003cString\u003e errors = Validator.validate(user); 这行代码的意思是：\n“请 Validator 类帮我检查一下这个 user 对象，看看有没有不符合规则的地方。”\n🔍 第三步：Validator.validate() 内部发生了什么？ 我们跟着代码一步步看（简化版逻辑）：\n1️⃣ 获取 User 的类信息 Class\u003c?\u003e clazz = user.getClass(); // 得到 User.class 2️⃣ 拿到所有字段 Field[] fields = clazz.getDeclaredFields(); // 得到 [username] 3️⃣ 遍历每个字段（这里只有 username） for (Field field : fields) { 4️⃣ 打开私有字段访问权限 field.setAccessible(true); // 允许读取 private 字段 5️⃣ 读取字段上的注解 ValidationRule[] rules = field.getAnnotationsByType(ValidationRule.class); JVM 发现：username 字段上贴了一个 @ValidationRule 标签。 把这个标签的内容读出来，变成一个 ValidationRule 对象： type = \"maxLength\" value = 10 message = \"用户名太长了！\" 6️⃣ 读取字段的实际值 Object value = field.get(user); // 得到 \"这是一个超长的用户名\" 7️⃣ 开始校验：根据 type 判断规则 switch (rule.type()) { case \"maxLength\": if (value instanceof String \u0026\u0026 ((String) value).length() \u003e rule.value()) { errors.add(rule.message()); } break; } value 是字符串 ✅ ((String) value).length() = 12 rule.value() = 10 12 \u003e 10 → 校验失败！ 把错误信息 \"用户名太长了！\" 加入 errors 列表 📤 第四步：返回结果（拿到“质检报告”） return errors; // 返回 [\"用户名太长了！\"] 🖨️ 第五步：你在 main 方法里处理结果 public static void main(String[] args) { User user = new User(); user.username = \"这是一个超长的用户名\"; List errors = Validator.validate(user); if (!errors.isEmpty()) { for (String error : errors) { System.out.println(\"❌ \" + error); } } else { System.out.println(\"✅ 用户数据合法！\"); } } 输出结果：\n❌ 用户名太长了！ ✅ 总结：整个流程图 [你写注解] ↓ @ValidationRule(type=\"maxLength\", value=10) 贴在 username 上 ↓ 创建 User 对象，设置 username = \"超长名字\" ↓ 调用 Validator.validate(user) ↓ 反射读取 username 字段的注解和值 ↓ 发现 length=12 \u003e 10 → 违反 maxLength 规则 ↓ 把 \"用户名太长了！\" 加入错误列表 ↓ 你打印出错误提示 七、💡 关键点回顾（小白友好） 步骤 关键技术 作用 贴标签 @ValidationRule(...) 告诉程序这个字段要校验 保留标签 @Retention(RUNTIME) 让运行时能读到标签 读标签 field.getAnnotationsByType(...) 用反射拿到规则内容 读值 field.get(obj) 拿到字段的实际值 校验 if (长度 \u003e 10) 根据规则判断对错 报错 errors.add(...) 收集错误信息 🌟 最后一句话： 你写的注解就像是给字段“立规矩”，而 Validator 就是那个拿着尺子量一量、看有没有违规的“执法者”。\n八、HashMap 🔍 回顾：代码中 HashMap 出现的位置 在 Validator.validate() 方法里，有这样一段：\n// 把所有规则存入 Map，方便后续查找（可选优化） Map\u003cString, ValidationRule\u003e ruleMap = new HashMap\u003c\u003e(); for (ValidationRule rule : rules) { ruleMap.put(rule.type(), rule); } 然后后面其实并没有直接使用 ruleMap，而是继续用 for (ValidationRule rule : rules) 来遍历校验。\n所以很多初学者会困惑：\n“既然没用 ruleMap，为什么要创建它？它到底干了啥？”\n我们分两部分回答：\n我们分两部分回答：\n✅ HashMap 实际做了什么？ 1. 创建了一个空的 HashMap Map\u003cString, ValidationRule\u003e ruleMap = new HashMap\u003c\u003e(); 这是一个“键值对”容器。 键（Key）：是字符串，比如 \"maxLength\"、\"pattern\"。 值（Value）：是 ValidationRule 注解对象本身。 2. 把每条规则按类型存进去 ruleMap.put(rule.type(), rule); 假设一个字段上有两个注解：\n@ValidationRule(type = \"maxLength\", value = 10) @ValidationRule(type = \"pattern\", pattern = \"^[a-z]+$\") private String username; 那么循环后，ruleMap 里就有：\n{ \"maxLength\" → @ValidationRule(type=\"maxLength\", value=10), \"pattern\" → @ValidationRule(type=\"pattern\", pattern=\"^[a-z]+$\") } 3. 但！在校验时，并没有用 ruleMap 而是继续写：\nfor (ValidationRule rule : rules) { switch (rule.type()) { ... } } 👉 所以在这个当前版本的代码中，ruleMap 被创建了，但没被使用。 它是一个“预留设计”或“未来优化点”。\n🧠 第二部分：那为什么要写它？有什么用？ 虽然现在没用，但它非常有用，尤其是在更复杂的场景中。举个例子：\n场景：你想先检查“是否必填”，再检查其他规则\n假设你新增一种规则类型：\"required\"（不能为空）。\n你可能希望：\n先判断字段是不是 null； 如果是 null，就不用检查 maxLength、pattern 了（因为都没意义）。 这时候，如果你有 ruleMap，就可以快速判断：\nif (ruleMap.containsKey(\"required\")) { if (value == null || \"\".equals(value)) { errors.add(\"该字段不能为空\"); continue; // 跳过后续校验 } } 📌 总结：HashMap 在这段代码中的角色 项目 说明 是否运行？ 是的，每次校验字段时都会创建并填充它 是否被使用？ 在你看到的简化版代码中 没有被使用 为什么存在？ 1. 为未来扩展做准备 2. 展示“如何用 Map 优化规则查找” 3. 很多真实框架（如 Hibernate Validator）内部确实用类似结构 对小白的意义 理解：Map 是用来“快速按名字找东西”的工具 💡 一句话记住： HashMap 就像一本“规则字典”——你问“有没有 maxLength 规则？”，它立刻翻给你看；不用一条条去猜。\n","wordCount":"1807","inLanguage":"en","datePublished":"2025-11-21T10:50:00+08:00","dateModified":"2025-11-21T10:50:00+08:00","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">注解和Map(新手理解)</h1><div class=post-meta><span title='2025-11-21 10:50:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h1 id=注解和map新手理解>注解和Map(新手理解)<a hidden class=anchor aria-hidden=true href=#注解和map新手理解>#</a></h1><p>把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。</p><p>Map 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：</p><ul><li>第一列叫“键”（Key）</li><li>第二列叫“值”（Value）</li></ul><p>只要给出一个 Key，就能立刻找到它对应的 Value。
常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。</p><p>举个生活化的例子：
如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。</p><h3 id=注解和-map-的关系>注解和 Map 的关系<a hidden class=anchor aria-hidden=true href=#注解和-map-的关系>#</a></h3><p>注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。
你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：</p><ul><li>注解里的每一个属性（比如 <code>@MyAnnotation(value="test", version=2)</code> 中的 value、version）
都会被放进一个 Map 里，key 就是属性名，value 就是属性值。</li><li>当你用反射调用 <code>method.getAnnotation(MyAnnotation.class)</code> 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。</li></ul><p>所以，<strong>注解在 JVM 眼里就是一张只读的键值表</strong>——这正是 Map 最擅长的场景：
灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。</p><hr><p>一句话总结
Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。</p><h2 id=一-目标>一、🎯 目标：<a hidden class=anchor aria-hidden=true href=#一-目标>#</a></h2><p>我们想做一个“用户信息校验”功能，比如：</p><ul><li>用户名不能超过10个字符</li><li>年龄必须在18到60之间</li><li>邮箱必须包含 @ 符号</li></ul><p>但我们不想把规则写死在代码里，而是用<strong>注解</strong>来定义规则，然后程序运行时通过<strong>Map</strong>来存储这些规则，进行动态校验。</p><hr><h2 id=二源码展示及分析>二、源码展示及分析<a hidden class=anchor aria-hidden=true href=#二源码展示及分析>#</a></h2><h3 id=-第一步定义一个注解-validationrule>✅ 第一步：定义一个注解 <code>@ValidationRule</code><a hidden class=anchor aria-hidden=true href=#-第一步定义一个注解-validationrule>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.annotation.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这个注解可以加在字段（field）上</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(ElementType.<span style=color:#a6e22e>FIELD</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 注解信息要保留到运行时，才能用反射读取</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Retention</span>(RetentionPolicy.<span style=color:#a6e22e>RUNTIME</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> ValidationRule {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 规则类型：比如 &#34;maxLength&#34;, &#34;minValue&#34;, &#34;pattern&#34; 等</span>
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>type</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 规则的值，比如最大长度是10，最小年龄是18</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>value</span>() <span style=color:#66d9ef>default</span> 0;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 用于正则匹配的字符串，比如邮箱格式</span>
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>pattern</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 错误提示信息</span>
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>message</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;该字段不符合规则&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>🔍 <strong>逐行解释：</strong></p><ul><li><p><code>@Target(ElementType.FIELD)</code>：说明这个注解只能用在“字段”上，比如类里的变量。</p></li><li><p><code>@Retention(RetentionPolicy.RUNTIME)</code>：表示这个注解在程序运行时还能被读取（靠反射）。</p></li><li><p><code>public @interface ValidationRule</code>：声明一个叫 <code>ValidationRule</code> 的注解（不是类！是标签）。</p></li><li><p><code>String type()</code>：定义一个叫 <code>type</code> 的属性，用来表示规则类型，比如 <code>"maxLength"</code>。</p></li><li><p><code>int value() default 0</code>：定义一个整数型规则值，比如最大长度是10，不写就默认是0。</p></li><li><p><code>String pattern()</code>：用于正则表达式，比如邮箱格式 <code>".*@.*\\.com"</code>。</p></li><li><p><code>String message()</code>：出错时显示的提示语。</p></li><li><p><code>String message()</code>：出错时显示的提示语。</p></li></ul><hr><h3 id=-第二步创建一个用户类用注解标注字段规则>✅ 第二步：创建一个用户类，用注解标注字段规则<a hidden class=anchor aria-hidden=true href=#-第二步创建一个用户类用注解标注字段规则>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ValidationRule</span>(
</span></span><span style=display:flex><span>        type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;maxLength&#34;</span>, 
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> 10, 
</span></span><span style=display:flex><span>        message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;用户名不能超过10个字符&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String username;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ValidationRule</span>(
</span></span><span style=display:flex><span>        type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;minValue&#34;</span>, 
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> 18, 
</span></span><span style=display:flex><span>        message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;年龄不能小于18&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ValidationRule</span>(
</span></span><span style=display:flex><span>        type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;maxValue&#34;</span>, 
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> 60, 
</span></span><span style=display:flex><span>        message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;年龄不能大于60&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ValidationRule</span>(
</span></span><span style=display:flex><span>        type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pattern&#34;</span>, 
</span></span><span style=display:flex><span>        pattern <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.*@.*\\.com&#34;</span>, 
</span></span><span style=display:flex><span>        message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;邮箱必须包含@且以.com结尾&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String email;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构造方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>User</span>(String username, <span style=color:#66d9ef>int</span> age, String email) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>username</span> <span style=color:#f92672>=</span> username;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>email</span> <span style=color:#f92672>=</span> email;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// getter 方法，方便外部读取字段</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getUsername</span>() { <span style=color:#66d9ef>return</span> username; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span>() { <span style=color:#66d9ef>return</span> age; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getEmail</span>() { <span style=color:#66d9ef>return</span> email; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>🔍 <strong>解释：</strong></p><ul><li>我们给 <code>username</code>、<code>age</code>、<code>email</code> 字段都加上了 <code>@ValidationRule</code> 注解。</li><li>每个注解都写了具体的规则（type、value、pattern、message）。</li><li>注意：<code>age</code> 有两个注解，一个限制最小值，一个最大值，Java 是允许一个字段加多个注解的！</li></ul><hr><h3 id=-第三步写一个校验器把注解信息读出来存进-map然后做校验>✅ 第三步：写一个校验器，把注解信息读出来，存进 Map，然后做校验<a hidden class=anchor aria-hidden=true href=#-第三步写一个校验器把注解信息读出来存进-map然后做校验>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.reflect.Field;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.*;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Validator</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 校验任意对象的方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>validate</span>(Object obj) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> errors <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();  <span style=color:#75715e>// 存放所有错误信息</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取这个对象的类结构（反射）</span>
</span></span><span style=display:flex><span>        Class<span style=color:#f92672>&lt;?&gt;</span> clazz <span style=color:#f92672>=</span> obj.<span style=color:#a6e22e>getClass</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取类里的所有字段（比如 username, age, email）</span>
</span></span><span style=display:flex><span>        Field<span style=color:#f92672>[]</span> fields <span style=color:#f92672>=</span> clazz.<span style=color:#a6e22e>getDeclaredFields</span>();
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 遍历每个字段</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Field field : fields) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 打开权限，让我们可以访问 private 字段</span>
</span></span><span style=display:flex><span>            field.<span style=color:#a6e22e>setAccessible</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取这个字段上的所有 @ValidationRule 注解</span>
</span></span><span style=display:flex><span>            ValidationRule<span style=color:#f92672>[]</span> rules <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>getAnnotationsByType</span>(ValidationRule.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果这个字段没有注解，跳过</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (rules.<span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> 0) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 获取字段的当前值，比如 username 的值是 &#34;zhangsan&#34;</span>
</span></span><span style=display:flex><span>            Object value <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                value <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>get</span>(obj);  <span style=color:#75715e>// 获取字段的实际值</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (IllegalAccessException e) {
</span></span><span style=display:flex><span>                errors.<span style=color:#a6e22e>add</span>(field.<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 字段无法访问&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 把这个字段的所有规则放进一个 Map，方便查找和处理</span>
</span></span><span style=display:flex><span>            Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> ruleMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (ValidationRule rule : rules) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 把每个规则的 type 作为 key，整个注解对象作为 value</span>
</span></span><span style=display:flex><span>                ruleMap.<span style=color:#a6e22e>put</span>(rule.<span style=color:#a6e22e>type</span>(), rule);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 开始根据规则校验</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (ValidationRule rule : rules) {
</span></span><span style=display:flex><span>                String type <span style=color:#f92672>=</span> rule.<span style=color:#a6e22e>type</span>();
</span></span><span style=display:flex><span>                String msg <span style=color:#f92672>=</span> rule.<span style=color:#a6e22e>message</span>();
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>switch</span> (type) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;maxLength&#34;</span>:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (value <span style=color:#66d9ef>instanceof</span> String <span style=color:#f92672>&amp;&amp;</span> ((String) value).<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&gt;</span> rule.<span style=color:#a6e22e>value</span>()) {
</span></span><span style=display:flex><span>                            errors.<span style=color:#a6e22e>add</span>(msg);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;minValue&#34;</span>:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (value <span style=color:#66d9ef>instanceof</span> Integer <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#66d9ef>int</span>) value <span style=color:#f92672>&lt;</span> rule.<span style=color:#a6e22e>value</span>()) {
</span></span><span style=display:flex><span>                            errors.<span style=color:#a6e22e>add</span>(msg);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;maxValue&#34;</span>:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (value <span style=color:#66d9ef>instanceof</span> Integer <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#66d9ef>int</span>) value <span style=color:#f92672>&gt;</span> rule.<span style=color:#a6e22e>value</span>()) {
</span></span><span style=display:flex><span>                            errors.<span style=color:#a6e22e>add</span>(msg);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;pattern&#34;</span>:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (value <span style=color:#66d9ef>instanceof</span> String <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>((String) value).<span style=color:#a6e22e>matches</span>(rule.<span style=color:#a6e22e>pattern</span>())) {
</span></span><span style=display:flex><span>                            errors.<span style=color:#a6e22e>add</span>(msg);
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> errors;  <span style=color:#75715e>// 返回所有错误信息</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>🔍 <strong>重点解释：</strong></p><ul><li><p><code>field.getAnnotationsByType(...)</code>：反射读取字段上的所有 <code>@ValidationRule</code> 注解。</p></li><li><p><code>Map&lt;String, Object> ruleMap</code>：我们把每个规则的 <code>type</code>（如 <code>"maxLength"</code>）作为 key，把整个注解对象存进去。这就是“注解 → Map”的典型用法！</p></li><li><p>为什么要用 Map？因为后面查规则更快，比如你想知道有没有 <code>minValue</code> 规则，直接 <code>ruleMap.containsKey("minValue")</code> 就行。</p></li><li><p><code>switch (type)</code>：根据规则类型做不同的校验。</p></li><li><p><code>errors</code>：收集所有错误提示，最后一起返回。</p></li><li><p><code>errors</code>：收集所有错误提示，最后一起返回。</p></li></ul><hr><h3 id=-第四步测试代码>✅ 第四步：测试代码<a hidden class=anchor aria-hidden=true href=#-第四步测试代码>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Main</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建一个“有问题”的用户</span>
</span></span><span style=display:flex><span>        User user <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> User(<span style=color:#e6db74>&#34;zhangsan123&#34;</span>, 16, <span style=color:#e6db74>&#34;abc@163.net&#34;</span>);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用校验器</span>
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> result <span style=color:#f92672>=</span> Validator.<span style=color:#a6e22e>validate</span>(user);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 输出结果</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (result.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;✅ 校验通过！&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;❌ 校验失败：&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (String error : result) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;  - &#34;</span> <span style=color:#f92672>+</span> error);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>📌 <strong>运行结果：</strong></p><pre tabindex=0><code>❌ 校验失败：
  - 用户名不能超过10个字符
  - 年龄不能小于18
  - 邮箱必须包含@且以.com结尾
</code></pre><hr><h3 id=-总结注解--map-的好处>✅ 总结：注解 + Map 的好处<a hidden class=anchor aria-hidden=true href=#-总结注解--map-的好处>#</a></h3><table><thead><tr><th>优点</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>解耦</strong></td><td>校验规则写在注解里，校验逻辑在 <code>Validator</code> 里，改规则不用动代码</td></tr><tr><td>✅ <strong>可读性强</strong></td><td>看字段就知道它有哪些限制</td></tr><tr><td>✅ <strong>灵活扩展</strong></td><td>想加新规则（比如 <code>required</code>），只需加个 <code>type</code> 就行</td></tr><tr><td>✅ <strong>Map 提高效率</strong></td><td>把注解信息转成 Map，方便快速查找和管理</td></tr></tbody></table><hr><h3 id=-最后一句话>💡 最后一句话：<a hidden class=anchor aria-hidden=true href=#-最后一句话>#</a></h3><p><strong>注解是“贴在代码上的标签”，Map 是“运行时的规则仓库”</strong>。
我们用注解声明规则，用反射读取注解，再把它们放进 Map 动态处理——这就是现代 Java 框架（如 Spring、Hibernate）的常用套路！</p><h2 id=三校验器源码解析>三、校验器源码解析<a hidden class=anchor aria-hidden=true href=#三校验器源码解析>#</a></h2><p>我们想通过 <strong>反射</strong> 读取类中所有字段上的 <code>@ValidationRule</code> 注解，并将这些注解的规则信息存入 <strong>Map</strong>，方便后续校验。</p><hr><h3 id=-完整的-validate-方法代码逐行解释>✅ 完整的 <code>validate</code> 方法代码（逐行解释）<a hidden class=anchor aria-hidden=true href=#-完整的-validate-方法代码逐行解释>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 定义一个静态方法 validate，接收一个对象 obj，返回错误信息列表</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>validate</span>(Object obj) {
</span></span></code></pre></div><ul><li><strong><code>public</code></strong>：表示这个方法可以被其他类访问。</li><li><strong><code>static</code></strong>：表示这是一个“类方法”，可以直接用类名调用，不需要创建对象。</li><li><strong><code>List&lt;String></code></strong>：返回值类型是一个字符串列表（比如 <code>[“错误1”, “错误2”]</code>）。</li><li><strong><code>Object obj</code></strong>：参数类型是“对象”，可以传任何类型的对象（比如 <code>User</code>、<code>Order</code>）。</li></ul><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> errors <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();  <span style=color:#75715e>// 用于收集所有错误信息</span>
</span></span></code></pre></div><ul><li><strong><code>List&lt;String></code></strong>：声明一个字符串列表，用来装错误信息。</li><li><strong><code>new ArrayList&lt;>()</code></strong>：创建一个新的空列表，<code>&lt;></code> 是 Java 7+ 的语法，表示自动推断泛型类型。</li><li><strong><code>errors</code></strong>：变量名，你可以理解为“错误清单”。</li></ul><h3 id=-步骤-1获取类的-class-对象>🧩 步骤 1：获取类的 <code>Class</code> 对象<a hidden class=anchor aria-hidden=true href=#-步骤-1获取类的-class-对象>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Class<span style=color:#f92672>&lt;?&gt;</span> clazz <span style=color:#f92672>=</span> obj.<span style=color:#a6e22e>getClass</span>();
</span></span></code></pre></div><ul><li><strong>解释</strong>：
<code>obj.getClass()</code> 就是获取 <code>obj</code> 这个对象的“身份证号码”——它的类类型。
比如，如果 <code>obj</code> 是一个 <code>User</code> 类的对象，那么 <code>clazz</code> 就是 <code>User.class</code>，相当于拿到了 <code>User</code> 类的“蓝图”。</li></ul><hr><h3 id=-步骤-2获取类的所有字段>🧩 步骤 2：获取类的所有字段<a hidden class=anchor aria-hidden=true href=#-步骤-2获取类的所有字段>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Field<span style=color:#f92672>[]</span> fields <span style=color:#f92672>=</span> clazz.<span style=color:#a6e22e>getDeclaredFields</span>();
</span></span></code></pre></div><ul><li><strong>解释</strong>：
<code>getDeclaredFields()</code> 就是查看 <code>User</code> 类的“成员表”——所有字段（比如 <code>username</code>、<code>age</code>、<code>email</code>）</li><li><strong>注意</strong>：这个方法会返回所有字段，包括 <code>private</code>（私有）字段，因为我们调用了 <code>field.setAccessible(true)</code>（后面会讲）。</li></ul><hr><h3 id=-步骤-3遍历每个字段>🧩 步骤 3：遍历每个字段<a hidden class=anchor aria-hidden=true href=#-步骤-3遍历每个字段>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> (Field field : fields) {
</span></span></code></pre></div><ul><li><strong>解释</strong>：
这个循环就是挨个查看 <code>User</code> 类的每个字段，比如先看 <code>username</code>，再看 <code>age</code>，最后看 <code>email</code>。</li></ul><hr><h3 id=-步骤-4打开字段的访问权限>🧩 步骤 4：打开字段的“访问权限”<a hidden class=anchor aria-hidden=true href=#-步骤-4打开字段的访问权限>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>field.<span style=color:#a6e22e>setAccessible</span>(<span style=color:#66d9ef>true</span>);
</span></span></code></pre></div><ul><li><strong>解释</strong>：
如果字段是 <code>private</code>（私有），默认不能直接访问。
<code>setAccessible(true)</code> 就像给私有字段开了个“后门”，允许我们绕过 Java 的访问控制规则去读取它的值。</li></ul><hr><h3 id=-步骤-5获取字段上的所有-validationrule-注解>🧩 步骤 5：获取字段上的所有 <code>@ValidationRule</code> 注解<a hidden class=anchor aria-hidden=true href=#-步骤-5获取字段上的所有-validationrule-注解>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>ValidationRule<span style=color:#f92672>[]</span> rules <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>getAnnotationsByType</span>(ValidationRule.<span style=color:#a6e22e>class</span>);
</span></span></code></pre></div><p><strong>解释</strong>：
<code>getAnnotationsByType(...)</code> 就是问这个字段：“你身上贴了哪些 <code>@ValidationRule</code> 的标签？”</p><ul><li><p>比如，<code>username</code> 字段上有 1 个 <code>@ValidationRule</code>，<code>age</code> 字段上有 2 个（因为写了两个注解）。</p></li><li><p>返回的结果是一个数组，里面装着所有贴在字段上的 <code>@ValidationRule</code> 注解。</p></li></ul><hr><h3 id=-步骤-6检查是否有注解>🧩 步骤 6：检查是否有注解<a hidden class=anchor aria-hidden=true href=#-步骤-6检查是否有注解>#</a></h3><pre tabindex=0><code>if (rules.length == 0) continue;
</code></pre><ul><li><strong>解释</strong>：
如果字段上没有贴 <code>@ValidationRule</code> 标签，就跳过这个字段（继续处理下一个字段）。</li></ul><hr><h3 id=-步骤-7获取字段的实际值>🧩 步骤 7：获取字段的实际值<a hidden class=anchor aria-hidden=true href=#-步骤-7获取字段的实际值>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Object value <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>get</span>(obj);
</span></span></code></pre></div><ul><li><strong>解释</strong>：
<code>field.get(obj)</code> 就是问：“这个字段的实际值是多少？”
比如，如果 <code>obj.username</code> 是 <code>"zhangsan"</code>，那么 <code>value</code> 就是 <code>"zhangsan"</code>。</li></ul><hr><h3 id=-步骤-8把注解信息存入-map>🧩 步骤 8：把注解信息存入 <code>Map</code><a hidden class=anchor aria-hidden=true href=#-步骤-8把注解信息存入-map>#</a></h3><pre tabindex=0><code>Map&lt;String, Object&gt; ruleMap = new HashMap&lt;&gt;();
for (ValidationRule rule : rules) {
    ruleMap.put(rule.type(), rule);
}
</code></pre><ul><li><p>解释</p><p>这一步是把每个注解的 <code>type</code>（比如 <code>"maxLength"</code>）作为 <strong>键</strong>，整个注解对象作为 <strong>值</strong>，存入 <code>ruleMap</code></p><ul><li>为什么要用 <code>Map</code>？因为后续校验时，我们可以直接通过 <code>ruleMap.containsKey("maxLength")</code> 快速判断是否有某个规则。</li></ul><hr></li></ul><h3 id=-步骤-9根据规则类型执行校验>🧩 步骤 9：根据规则类型执行校验<a hidden class=anchor aria-hidden=true href=#-步骤-9根据规则类型执行校验>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>switch</span> (type) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;maxLength&#34;</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (value <span style=color:#66d9ef>instanceof</span> String <span style=color:#f92672>&amp;&amp;</span> ((String) value).<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&gt;</span> rule.<span style=color:#a6e22e>value</span>()) {
</span></span><span style=display:flex><span>            errors.<span style=color:#a6e22e>add</span>(msg);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 其他 case 类似</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><strong>解释</strong>：
这一步是根据注解的 <code>type</code>（比如 <code>"maxLength"</code>）执行不同的校验逻辑：<ul><li>如果是 <code>maxLength</code>，就检查字符串长度是否超过限制。</li><li>如果是 <code>minValue</code>，就检查数值是否小于最小值。</li></ul></li></ul><hr><h3 id=-步骤-10收集所有错误信息>🧩 步骤 10：收集所有错误信息<a hidden class=anchor aria-hidden=true href=#-步骤-10收集所有错误信息>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> errors <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// ... 校验失败时添加错误信息</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> errors;
</span></span></code></pre></div><ul><li><strong>解释</strong>：
如果校验失败，就把错误提示（比如 <code>"用户名不能超过10个字符"</code>）加到 <code>errors</code> 列表中。
最后返回 <code>errors</code>，这样调用者就能知道哪里出错了。</li></ul><hr><h3 id=-总结为什么用反射--map>🧠 总结：为什么用反射 + Map？<a hidden class=anchor aria-hidden=true href=#-总结为什么用反射--map>#</a></h3><table><thead><tr><th>步骤</th><th>做了什么</th><th>为什么这样做</th></tr></thead><tbody><tr><td>1. 获取 <code>Class</code> 对象</td><td>看到类的“身份证”</td><td>反射的第一步，才能操作类的结构</td></tr><tr><td>2. 获取字段列表</td><td>查看类的“成员表”</td><td>遍历所有字段，检查是否有注解</td></tr><tr><td>3. 打开字段权限</td><td>开启“后门”访问私有字段</td><td>绕过 Java 的访问控制</td></tr><tr><td>4. 读取注解</td><td>查看字段上的“标签”</td><td>获取校验规则（比如最大长度）</td></tr><tr><td>5. 存入 <code>Map</code></td><td>把规则存成“键值表”</td><td>后续校验时能快速查找规则</td></tr><tr><td>6. 执行校验</td><td>根据规则类型做不同判断</td><td>动态校验，无需硬编码规则</td></tr></tbody></table><hr><h4 id=-举个生活化的例子>🍱 举个生活化的例子：<a hidden class=anchor aria-hidden=true href=#-举个生活化的例子>#</a></h4><p>假设你是一个餐厅的厨师，需要根据菜单（注解）来做菜：</p><ol><li><strong>菜单</strong>（注解）：<ul><li><code>@ValidationRule(type="maxLength", value=10)</code> 就像菜单上写着“这道菜最多只能放10克盐”。</li><li><code>@ValidationRule(type="pattern", pattern=".*@.*\\.com")</code> 就像菜单上写着“这道菜必须包含葱花和姜丝”。</li></ul></li><li><strong>厨师</strong>（反射）：<ul><li>你拿到菜单（注解），然后查看每道菜（字段）的规则。</li><li>你把规则存到“厨房备忘录”（Map）里，方便快速查找。</li><li>根据规则做菜（校验），如果做错了（校验失败），就记录错误（加到 <code>errors</code> 列表）。</li></ul></li></ol><hr><h4 id=-总结完整流程图解>🧩 总结：完整流程图解<a hidden class=anchor aria-hidden=true href=#-总结完整流程图解>#</a></h4><pre tabindex=0><code>传入一个对象（如 User）
     ↓
获取它的类（User.class）
     ↓
拿到所有字段（username, age, email）
     ↓
逐个字段检查是否有 @ValidationRule 注解
     ↓
如果有，就用反射读取字段的值（比如 username = &#34;zhangsan&#34;）
     ↓
根据注解里的 type（如 &#34;maxLength&#34;）判断是否符合规则
     ↓
不符合 → 添加错误信息到 errors 列表
     ↓
最后返回所有错误
</code></pre><hr><h4 id=-最后一句话-1>✅ 最后一句话：<a hidden class=anchor aria-hidden=true href=#-最后一句话-1>#</a></h4><p><strong>反射是“动态查看代码结构”的工具，注解是“贴在代码上的配置标签”</strong>。
通过反射读取注解，并将规则存入 <code>Map</code>，我们就能实现“配置驱动”的校验逻辑——规则写在注解里，逻辑写在代码里，两者解耦，灵活又高效！</p><h3 id=额外补充和主题无关>额外补充(和主题无关)：<a hidden class=anchor aria-hidden=true href=#额外补充和主题无关>#</a></h3><p>我们之前在讲解 <strong>第三步</strong> 的 <code>Validator.validate()</code> 方法时，确实<strong>漏掉了一小段关键代码</strong>——那就是 <strong><code>try-catch</code> 异常处理块</strong>。</p><hr><h4 id=-补充解释被遗漏的关键部分>🔍 补充解释：被遗漏的关键部分<a hidden class=anchor aria-hidden=true href=#-补充解释被遗漏的关键部分>#</a></h4><ol><li><code>try { ... } catch (IllegalAccessException e) { ... }</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>jtry {
</span></span><span style=display:flex><span>    value <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>get</span>(obj);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (IllegalAccessException e) {
</span></span><span style=display:flex><span>    errors.<span style=color:#a6e22e>add</span>(field.<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; 字段无法访问&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p><strong>为什么需要 try-catch？</strong>
虽然我们用了 <code>field.setAccessible(true)</code> 打开了权限，但<strong>某些特殊情况下仍然可能访问失败</strong>，比如：</p><ul><li>字段被 <code>final</code> 修饰且无法读取</li><li>安全管理器（SecurityManager）禁止反射访问</li><li>模块系统限制（Java 9+）</li></ul><p>这些情况会抛出 <code>IllegalAccessException</code> 异常。</p></li><li><p><strong>try 是什么意思？</strong>
“尝试做这件事”：尝试读取字段的值。</p></li><li><p><strong>catch 是什么意思？</strong>
“如果出错了，就在这里处理”：如果读取失败，就给用户一个友好的提示，比如 <code>"username 字段无法访问"</code>，然后跳过这个字段，继续检查下一个字段。</p></li><li><p><strong>continue 的作用</strong>
跳过当前字段，进入 <code>for</code> 循环的下一次迭代，避免程序因为一个字段出错而直接崩溃。</p></li></ul><blockquote><p>✅ 这就是“健壮性”——即使部分出错，也要尽量完成其他任务。</p></blockquote><hr><h2 id=四我的疑问点>四、我的疑问点：<a hidden class=anchor aria-hidden=true href=#四我的疑问点>#</a></h2><h3 id=1-实际中知道有>1. <strong>实际中知道有 <code>ValidationRule.class</code> 吗？</strong><a hidden class=anchor aria-hidden=true href=#1-实际中知道有>#</a></h3><p>✅ <strong>知道，而且必须知道。</strong></p><ul><li><code>ValidationRule.class</code> 是你<strong>自己定义的注解类</strong>（就像你写的 <code>User</code> 类一样）。</li><li>因为你在字段上用了 <code>@ValidationRule(...)</code>，所以程序运行时<strong>肯定要读这个注解</strong>，就必须明确告诉 Java：“我要找的是 <code>ValidationRule</code> 这个注解”。</li><li>就像你去快递站取件，必须说清楚“我取的是张三的包裹”，不能只说“我取个包裹”。</li></ul><blockquote><p>📌 总结：<code>ValidationRule.class</code> 是你自己写的，编译器和 JVM 都认识它，所以能用。</p></blockquote><h3 id=2-为什么要根据类型对-value-做不同判断>2. <strong>为什么要根据类型对 value 做不同判断？</strong><a hidden class=anchor aria-hidden=true href=#2-为什么要根据类型对-value-做不同判断>#</a></h3><p>✅ <strong>因为不同的规则，检查的东西完全不同！</strong></p><p>举个例子：</p><table><thead><tr><th>规则类型</th><th>要检查什么</th><th>数据类型</th><th>检查方式</th></tr></thead><tbody><tr><td><code>"maxLength"</code></td><td>字符串长度</td><td><code>String</code></td><td>看 <code>.length()</code> 是否超限</td></tr><tr><td><code>"minValue"</code></td><td>数字最小值</td><td><code>int</code> / <code>Integer</code></td><td>看是否 <code>&lt; rule.value()</code></td></tr><tr><td><code>"pattern"</code></td><td>格式是否匹配</td><td><code>String</code></td><td>用正则 <code>.matches()</code></td></tr></tbody></table><p>👉 如果不区分类型：</p><ul><li>你拿一个字符串去和 <code>minValue=18</code> 比大小？会出错！</li><li>你拿一个整数去调 <code>.matches()</code>？根本没这个方法！</li></ul><blockquote><p>📌 总结：<strong>不同类型的数据，要用不同的方法检查</strong>，所以必须通过 <code>type</code> 来分支处理。</p></blockquote><h3 id=3编译器compiler-和-jvmjava-虚拟机-的工作讲清楚>3.<strong>编译器（Compiler）</strong> 和 <strong>JVM（Java 虚拟机）</strong> 的工作讲清楚<a hidden class=anchor aria-hidden=true href=#3编译器compiler-和-jvmjava-虚拟机-的工作讲清楚>#</a></h3><p><strong>🧱 举个生活例子：做一道菜</strong></p><p>想象你要做一道“红烧肉”：</p><ul><li><strong>编译器</strong> = 厨师看菜谱，检查步骤对不对（比如有没有写“放盐”却没写“放肉”）</li><li><strong>JVM</strong> = 真正下锅炒菜、尝味道、端上桌的人</li></ul><blockquote><p>编译器负责“检查和翻译”，JVM 负责“真正执行”</p></blockquote><hr><h3 id=4编译器javac-干活阶段写完代码之后运行之前>4.编译器（javac）—— 干活阶段：<strong>写完代码之后，运行之前</strong><a hidden class=anchor aria-hidden=true href=#4编译器javac-干活阶段写完代码之后运行之前>#</a></h3><p><strong>✅ 它做什么？</strong></p><ol><li><strong>加载 .class 文件</strong><ul><li>把编译好的字节码读进内存（比如 <code>User.class</code>, <code>Validator.class</code>）。</li></ul></li><li><strong>验证字节码</strong><ul><li>确保字节码是合法的、安全的（防止恶意代码）。</li></ul></li><li><strong>解释/编译执行</strong><ul><li>把字节码一行行翻译成机器能执行的指令（有的还会用 JIT 编译成更快的本地代码）。</li></ul></li><li><strong>管理内存</strong><ul><li>分配对象内存（堆）、回收垃圾（GC）。</li></ul></li><li><strong>处理运行时行为</strong><ul><li>比如：反射（<code>field.get(obj)</code>）、异常（<code>NullPointerException</code>）、多线程。</li></ul></li><li><strong>读取运行时注解</strong><ul><li>如果注解用了 <code>@Retention(RetentionPolicy.RUNTIME)</code>，JVM 会在运行时保留它，并允许你用反射读取（比如我们的 <code>@ValidationRule</code>）。</li></ul></li></ol><p><strong>⏱️ 工作阶段</strong>：</p><blockquote><p><strong>运行阶段</strong> → 你执行 <code>java Main</code> 时，JVM 才启动并开始干活。</p></blockquote><p><strong>🔧 特点：</strong></p><ul><li><strong>真正让程序跑起来</strong>。</li><li><strong>能处理动态行为</strong>：比如不知道字段名是什么，但运行时通过反射拿到。</li><li><strong>会抛运行时异常</strong>：比如空指针、数组越界，这些编译器没法提前知道。</li></ul><p><strong>🆚 对比总结表</strong></p><table><thead><tr><th>项目</th><th>编译器（javac）</th><th>JVM</th></tr></thead><tbody><tr><td><strong>什么时候工作？</strong></td><td>写完代码后，运行前</td><td>程序真正运行时</td></tr><tr><td><strong>输入是什么？</strong></td><td><code>.java</code> 源代码</td><td><code>.class</code> 字节码</td></tr><tr><td><strong>输出是什么？</strong></td><td><code>.class</code> 字节码文件</td><td>程序运行结果（打印、计算、网络请求等）</td></tr><tr><td><strong>能发现什么错误？</strong></td><td>语法错误、类型错误</td><td>空指针、除零、数组越界等</td></tr><tr><td><strong>能处理注解吗？</strong></td><td>只处理编译期注解（如 <code>@Override</code>）</td><td>能处理运行时注解（如 <code>@ValidationRule</code>）</td></tr><tr><td><strong>是否需要安装？</strong></td><td>需要 JDK（含 javac）</td><td>需要 JRE 或 JDK（含 JVM）</td></tr></tbody></table><hr><p><strong>💡 回到你的例子</strong></p><p>在你的校验代码中：</p><ul><li><strong>编译器</strong>：检查 <code>@ValidationRule</code> 注解定义是否正确，字段是否拼写对。</li><li><strong>JVM</strong>：运行时通过 <code>field.getAnnotationsByType(...)</code> 读取注解，并把规则放进 <code>Map</code>，再校验数据。</li></ul><blockquote><p>所以：<strong>注解要生效，必须靠 JVM 在运行时读取；而编译器只负责确保注解语法没错。</strong></p></blockquote><h2 id=五注解-validationrule源码解析>五、注解 <code>@ValidationRule</code>源码解析<a hidden class=anchor aria-hidden=true href=#五注解-validationrule源码解析>#</a></h2><h3 id=-整体目标>🧩 整体目标：<a hidden class=anchor aria-hidden=true href=#-整体目标>#</a></h3><p>我们要自己<strong>发明一个标签（注解）</strong>，名字叫 <code>@ValidationRule</code>，以后可以贴在字段上，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@ValidationRule</span>(type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;maxLength&#34;</span>, value <span style=color:#f92672>=</span> 10)
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> String username;
</span></span></code></pre></div><p>这个标签的作用是：告诉程序“这个字段要满足某种校验规则”。</p><p>现在，我们来看看怎么“发明”这个标签。</p><hr><h3 id=第一行导入包>第一行：导入包<a hidden class=anchor aria-hidden=true href=#第一行导入包>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.lang.annotation.*;
</span></span></code></pre></div><ul><li><strong>意思</strong>：我要用 Java 里专门用来写“注解”的工具，所以先把这些工具引进来。</li><li><strong>类比</strong>：就像你要画画，得先准备好画笔和颜料一样。</li></ul><hr><h3 id=第二行指定这个注解能贴在哪里>第二行：指定这个注解能贴在哪里<a hidden class=anchor aria-hidden=true href=#第二行指定这个注解能贴在哪里>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(ElementType.<span style=color:#a6e22e>FIELD</span>)
</span></span></code></pre></div><ul><li><p><strong><code>@Target</code></strong>：这是一个“元注解”——就是“用来描述注解的注解”。</p></li><li><p><strong><code>ElementType.FIELD</code></strong>：表示你写的这个 <code>@ValidationRule</code> 只能贴在 <strong>字段（field）</strong> 上。</p></li><li><p>字段就是类里的变量，比如 <code>private String name;</code></p></li><li><p><strong>不能贴在哪？</strong>
比如不能贴在方法上（<code>public void run()</code>）、类上（<code>class User</code>）等，除非你改这里。</p></li></ul><p>✅ <strong>总结</strong>：这行规定了你的标签只能贴在“成员变量”上。</p><hr><h3 id=第三行指定这个注解保留到什么时候>第三行：指定这个注解保留到什么时候<a hidden class=anchor aria-hidden=true href=#第三行指定这个注解保留到什么时候>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Retention</span>(RetentionPolicy.<span style=color:#a6e22e>RUNTIME</span>)
</span></span></code></pre></div><ul><li><strong><code>@Retention</code></strong>：另一个“元注解”，意思是“这个标签要保留多久？”</li><li><code>RetentionPolicy.RUNTIME</code>：表示这个标签<strong>一直保留到程序运行的时候</strong><ul><li>这样你才能在程序运行时，用“反射”去读它（比如我们的校验器 <code>Validator</code> 就是在运行时读的）。</li></ul></li><li>其他选项（不用记，了解就行）：<ul><li><code>SOURCE</code>：只在写代码时有用，编译完就扔掉（比如 <code>@Override</code> 实际是 <code>SOURCE</code> 级别，但 JDK 特殊处理了）。</li><li><code>CLASS</code>：编译后保留在 <code>.class</code> 文件里，但运行时看不到（默认值）。</li></ul></li></ul><p>✅ <strong>总结</strong>：这行保证你的标签在程序跑起来后还能被读到！</p><hr><h3 id=第四行开始定义自己的注解>第四行：开始定义自己的注解<a hidden class=anchor aria-hidden=true href=#第四行开始定义自己的注解>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>@interface</span> ValidationRule {
</span></span></code></pre></div><ul><li><strong><code>public</code></strong>：这个注解可以被其他类使用。</li><li><code>@interface</code>：这是关键！它不是普通类，而是定义一个注解类型<ul><li>就像 <code>class User</code> 定义一个类，<code>@interface ValidationRule</code> 定义一个注解。</li></ul></li><li><strong><code>ValidationRule</code></strong>：你给这个注解起的名字，以后就用 <code>@ValidationRule</code> 来贴标签。</li></ul><p>✅ <strong>总结</strong>：从这行开始，你在“设计一个新标签”。</p><hr><h3 id=接下来的几行定义标签里能填什么内容>接下来的几行：定义标签里能填什么内容<a hidden class=anchor aria-hidden=true href=#接下来的几行定义标签里能填什么内容>#</a></h3><p>注解不是光秃秃的，它可以带“参数”，就像函数有参数一样。</p><h4 id=1-规则类型>1. 规则类型<a hidden class=anchor aria-hidden=true href=#1-规则类型>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>String <span style=color:#a6e22e>type</span>();
</span></span></code></pre></div><ul><li>表示这个注解必须提供一个叫 <code>type</code> 的字符串。</li><li>使用时写成：<code>@ValidationRule(type = "maxLength")</code></li><li>注意：<strong>没有 <code>{}</code>，也没有 <code>return</code></strong>，因为注解里的方法只是“声明参数”，不是真正的方法！</li></ul><h4 id=2-规则的数值可选>2. 规则的数值（可选）<a hidden class=anchor aria-hidden=true href=#2-规则的数值可选>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>value</span>() <span style=color:#66d9ef>default</span> 0;
</span></span></code></pre></div><ul><li>表示可以传一个整数，比如最大长度、最小年龄。</li><li><strong><code>default 0</code></strong>：如果不写这个参数，默认值是 0。</li><li>使用时：<code>@ValidationRule(type = "maxLength", value = 10)</code></li></ul><h4 id=3-正则表达式可选>3. 正则表达式（可选）<a hidden class=anchor aria-hidden=true href=#3-正则表达式可选>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>String <span style=color:#a6e22e>pattern</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span></code></pre></div><ul><li>用于格式校验，比如邮箱、手机号。</li><li>默认是空字符串 <code>""</code>，表示不用正则。</li><li>使用时：<code>@ValidationRule(type = "pattern", pattern = ".*@.*\\.com")</code></li></ul><h4 id=4-错误提示可选>4. 错误提示（可选）<a hidden class=anchor aria-hidden=true href=#4-错误提示可选>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>String <span style=color:#a6e22e>message</span>() <span style=color:#66d9ef>default</span> <span style=color:#e6db74>&#34;该字段不符合规则&#34;</span>;
</span></span></code></pre></div><ul><li>如果校验失败，显示什么错误信息。</li><li>如果你不写 <code>message = "..."</code>，就用默认的这句话。</li></ul><hr><p><strong>✅ 最终效果：你可以这样用这个注解</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ValidationRule</span>(
</span></span><span style=display:flex><span>        type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;maxLength&#34;</span>,
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> 10,
</span></span><span style=display:flex><span>        message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;用户名太长了！&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String username;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>这个字段被贴了一个标签，里面包含了：<ul><li>类型：<code>"maxLength"</code></li><li>值：<code>10</code></li><li>提示语：<code>"用户名太长了！"</code></li></ul></li></ul><p>然后你的 <code>Validator</code> 类就能在<strong>运行时</strong>读到这些信息，并做校验！</p><hr><h4 id=-小白重点记住>🧠 小白重点记住：<a hidden class=anchor aria-hidden=true href=#-小白重点记住>#</a></h4><table><thead><tr><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><code>@Target(ElementType.FIELD)</code></td><td>这个标签只能贴在字段上</td></tr><tr><td><code>@Retention(RetentionPolicy.RUNTIME)</code></td><td>程序运行时还能读到它</td></tr><tr><td><code>String type();</code></td><td>标签必须有一个 <code>type</code> 参数</td></tr><tr><td><code>int value() default 0;</code></td><td>可以传一个数字，不传就当 0</td></tr><tr><td><code>public @interface ...</code></td><td>这是在定义一个新的注解</td></tr></tbody></table><h4 id=-最后一句话-2>💡 最后一句话：<a hidden class=anchor aria-hidden=true href=#-最后一句话-2>#</a></h4><blockquote><p><strong>注解就像是你给代码贴的“便利贴”，上面写着各种说明；而 <code>@Target</code> 和 <code>@Retention</code> 是规定这张便利贴能贴在哪、能保留多久。</strong></p></blockquote><h2 id=六检查用户名流程>六、检查用户名流程<a hidden class=anchor aria-hidden=true href=#六检查用户名流程>#</a></h2><h3 id=-场景设定>🎬 场景设定<a hidden class=anchor aria-hidden=true href=#-场景设定>#</a></h3><p>你有一个用户类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@ValidationRule</span>(
</span></span><span style=display:flex><span>        type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;maxLength&#34;</span>,
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> 10,
</span></span><span style=display:flex><span>        message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;用户名太长了！&#34;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String username;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在你想：<strong>创建一个用户，然后自动检查他的用户名有没有超过10个字符。</strong></p><hr><h3 id=-第一步创建-user-对象准备食材>🚶‍♂️ 第一步：创建 User 对象（准备“食材”）<a hidden class=anchor aria-hidden=true href=#-第一步创建-user-对象准备食材>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>User user <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> User();
</span></span><span style=display:flex><span>user.<span style=color:#a6e22e>username</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;这是一个超长的用户名&#34;</span>; <span style=color:#75715e>// 长度是12</span>
</span></span></code></pre></div><blockquote><p>此时，<code>user</code> 是一个对象，它的 <code>username</code> 字段值为 <code>"这是一个超长的用户名"</code>（12个字）。</p></blockquote><hr><h3 id=-第二步调用校验方法交给质检员>🧪 第二步：调用校验方法（交给“质检员”）<a hidden class=anchor aria-hidden=true href=#-第二步调用校验方法交给质检员>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> errors <span style=color:#f92672>=</span> Validator.<span style=color:#a6e22e>validate</span>(user);
</span></span></code></pre></div><p>这行代码的意思是：</p><blockquote><p>“请 <code>Validator</code> 类帮我检查一下这个 <code>user</code> 对象，看看有没有不符合规则的地方。”</p></blockquote><hr><h3 id=-第三步validatorvalidate-内部发生了什么>🔍 第三步：<code>Validator.validate()</code> 内部发生了什么？<a hidden class=anchor aria-hidden=true href=#-第三步validatorvalidate-内部发生了什么>#</a></h3><p>我们跟着代码一步步看（简化版逻辑）：</p><h4 id=1-获取-user-的类信息>1️⃣ 获取 User 的类信息<a hidden class=anchor aria-hidden=true href=#1-获取-user-的类信息>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Class<span style=color:#f92672>&lt;?&gt;</span> clazz <span style=color:#f92672>=</span> user.<span style=color:#a6e22e>getClass</span>(); <span style=color:#75715e>// 得到 User.class</span>
</span></span></code></pre></div><h4 id=2-拿到所有字段>2️⃣ 拿到所有字段<a hidden class=anchor aria-hidden=true href=#2-拿到所有字段>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Field<span style=color:#f92672>[]</span> fields <span style=color:#f92672>=</span> clazz.<span style=color:#a6e22e>getDeclaredFields</span>(); <span style=color:#75715e>// 得到 [username]</span>
</span></span></code></pre></div><h4 id=3-遍历每个字段这里只有-username>3️⃣ 遍历每个字段（这里只有 <code>username</code>）<a hidden class=anchor aria-hidden=true href=#3-遍历每个字段这里只有-username>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> (Field field : fields) {
</span></span></code></pre></div><h4 id=4-打开私有字段访问权限>4️⃣ 打开私有字段访问权限<a hidden class=anchor aria-hidden=true href=#4-打开私有字段访问权限>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>field.<span style=color:#a6e22e>setAccessible</span>(<span style=color:#66d9ef>true</span>); <span style=color:#75715e>// 允许读取 private 字段</span>
</span></span></code></pre></div><h4 id=5-读取字段上的注解>5️⃣ 读取字段上的注解<a hidden class=anchor aria-hidden=true href=#5-读取字段上的注解>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>ValidationRule<span style=color:#f92672>[]</span> rules <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>getAnnotationsByType</span>(ValidationRule.<span style=color:#a6e22e>class</span>);
</span></span></code></pre></div><ul><li>JVM 发现：<code>username</code> 字段上贴了一个 <code>@ValidationRule</code> 标签。</li><li>把这个标签的内容读出来，变成一个 <code>ValidationRule</code> 对象：<ul><li><code>type = "maxLength"</code></li><li><code>value = 10</code></li><li><code>message = "用户名太长了！"</code></li></ul></li></ul><h4 id=6-读取字段的实际值>6️⃣ 读取字段的实际值<a hidden class=anchor aria-hidden=true href=#6-读取字段的实际值>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Object value <span style=color:#f92672>=</span> field.<span style=color:#a6e22e>get</span>(user); <span style=color:#75715e>// 得到 &#34;这是一个超长的用户名&#34;</span>
</span></span></code></pre></div><h4 id=7-开始校验根据-type-判断规则>7️⃣ 开始校验：根据 type 判断规则<a hidden class=anchor aria-hidden=true href=#7-开始校验根据-type-判断规则>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>switch</span> (rule.<span style=color:#a6e22e>type</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;maxLength&#34;</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (value <span style=color:#66d9ef>instanceof</span> String <span style=color:#f92672>&amp;&amp;</span> ((String) value).<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&gt;</span> rule.<span style=color:#a6e22e>value</span>()) {
</span></span><span style=display:flex><span>            errors.<span style=color:#a6e22e>add</span>(rule.<span style=color:#a6e22e>message</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>value</code> 是字符串 ✅</li><li><code>((String) value).length()</code> = 12</li><li><code>rule.value()</code> = 10</li><li>12 > 10 → <strong>校验失败！</strong></li><li>把错误信息 <code>"用户名太长了！"</code> 加入 <code>errors</code> 列表</li></ul><hr><h3 id=-第四步返回结果拿到质检报告>📤 第四步：返回结果（拿到“质检报告”）<a hidden class=anchor aria-hidden=true href=#-第四步返回结果拿到质检报告>#</a></h3><pre tabindex=0><code>return errors; // 返回 [&#34;用户名太长了！&#34;]
</code></pre><h3 id=-第五步你在-main-方法里处理结果>🖨️ 第五步：你在 main 方法里处理结果<a hidden class=anchor aria-hidden=true href=#-第五步你在-main-方法里处理结果>#</a></h3><pre tabindex=0><code>public static void main(String[] args) {
    User user = new User();
    user.username = &#34;这是一个超长的用户名&#34;;

    List&lt;String&gt; errors = Validator.validate(user);

    if (!errors.isEmpty()) {
        for (String error : errors) {
            System.out.println(&#34;❌ &#34; + error);
        }
    } else {
        System.out.println(&#34;✅ 用户数据合法！&#34;);
    }
}
</code></pre><p><strong>输出结果：</strong></p><pre tabindex=0><code>❌ 用户名太长了！
</code></pre><h3 id=-总结整个流程图>✅ 总结：整个流程图<a hidden class=anchor aria-hidden=true href=#-总结整个流程图>#</a></h3><pre tabindex=0><code>[你写注解] 
     ↓
@ValidationRule(type=&#34;maxLength&#34;, value=10) 贴在 username 上
     ↓
创建 User 对象，设置 username = &#34;超长名字&#34;
     ↓
调用 Validator.validate(user)
     ↓
反射读取 username 字段的注解和值
     ↓
发现 length=12 &gt; 10 → 违反 maxLength 规则
     ↓
把 &#34;用户名太长了！&#34; 加入错误列表
     ↓
你打印出错误提示
</code></pre><h2 id=七-关键点回顾小白友好>七、💡 关键点回顾（小白友好）<a hidden class=anchor aria-hidden=true href=#七-关键点回顾小白友好>#</a></h2><table><thead><tr><th>步骤</th><th>关键技术</th><th>作用</th></tr></thead><tbody><tr><td>贴标签</td><td><code>@ValidationRule(...)</code></td><td>告诉程序这个字段要校验</td></tr><tr><td>保留标签</td><td><code>@Retention(RUNTIME)</code></td><td>让运行时能读到标签</td></tr><tr><td>读标签</td><td><code>field.getAnnotationsByType(...)</code></td><td>用反射拿到规则内容</td></tr><tr><td>读值</td><td><code>field.get(obj)</code></td><td>拿到字段的实际值</td></tr><tr><td>校验</td><td><code>if (长度 > 10)</code></td><td>根据规则判断对错</td></tr><tr><td>报错</td><td><code>errors.add(...)</code></td><td>收集错误信息</td></tr></tbody></table><hr><h3 id=-最后一句话-3>🌟 最后一句话：<a hidden class=anchor aria-hidden=true href=#-最后一句话-3>#</a></h3><blockquote><p><strong>你写的注解就像是给字段“立规矩”，而 <code>Validator</code> 就是那个拿着尺子量一量、看有没有违规的“执法者”。</strong></p></blockquote><h2 id=八hashmap>八、HashMap<a hidden class=anchor aria-hidden=true href=#八hashmap>#</a></h2><h3 id=-回顾代码中-hashmap-出现的位置>🔍 回顾：代码中 <code>HashMap</code> 出现的位置<a hidden class=anchor aria-hidden=true href=#-回顾代码中-hashmap-出现的位置>#</a></h3><p>在 <code>Validator.validate()</code> 方法里，有这样一段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 把所有规则存入 Map，方便后续查找（可选优化）</span>
</span></span><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>String, ValidationRule<span style=color:#f92672>&gt;</span> ruleMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (ValidationRule rule : rules) {
</span></span><span style=display:flex><span>    ruleMap.<span style=color:#a6e22e>put</span>(rule.<span style=color:#a6e22e>type</span>(), rule);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后后面其实<strong>并没有直接使用 <code>ruleMap</code></strong>，而是继续用 <code>for (ValidationRule rule : rules)</code> 来遍历校验。</p><p>所以很多初学者会困惑：</p><blockquote><p>“既然没用 <code>ruleMap</code>，为什么要创建它？它到底干了啥？”</p></blockquote><p>我们分两部分回答：</p><p>我们分两部分回答：</p><hr><h2 id=--hashmap-实际做了什么>✅ <code>HashMap</code> <strong>实际做了什么</strong>？<a hidden class=anchor aria-hidden=true href=#--hashmap-实际做了什么>#</a></h2><h3 id=1-创建了一个空的-hashmap>1. 创建了一个空的 <code>HashMap</code><a hidden class=anchor aria-hidden=true href=#1-创建了一个空的-hashmap>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>String, ValidationRule<span style=color:#f92672>&gt;</span> ruleMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span></code></pre></div><ul><li>这是一个“键值对”容器。</li><li><strong>键（Key）</strong>：是字符串，比如 <code>"maxLength"</code>、<code>"pattern"</code>。</li><li><strong>值（Value）</strong>：是 <code>ValidationRule</code> 注解对象本身。</li></ul><h3 id=2-把每条规则按类型存进去>2. 把每条规则按类型存进去<a hidden class=anchor aria-hidden=true href=#2-把每条规则按类型存进去>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>ruleMap.<span style=color:#a6e22e>put</span>(rule.<span style=color:#a6e22e>type</span>(), rule);
</span></span></code></pre></div><p>假设一个字段上有两个注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@ValidationRule</span>(type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;maxLength&#34;</span>, value <span style=color:#f92672>=</span> 10)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ValidationRule</span>(type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pattern&#34;</span>, pattern <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;^[a-z]+$&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> String username;
</span></span></code></pre></div><p>那么循环后，<code>ruleMap</code> 里就有：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;maxLength&#34;</span> <span style=color:#960050;background-color:#1e0010>→</span> <span style=color:#a6e22e>@ValidationRule</span>(type<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;maxLength&#34;</span>, value<span style=color:#f92672>=</span>10),
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;pattern&#34;</span>  <span style=color:#960050;background-color:#1e0010>→</span> <span style=color:#a6e22e>@ValidationRule</span>(type<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;pattern&#34;</span>, pattern<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;^[a-z]+$&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-但在校验时并没有用-rulemap>3. 但！在校验时，并没有用 <code>ruleMap</code><a hidden class=anchor aria-hidden=true href=#3-但在校验时并没有用-rulemap>#</a></h3><p>而是继续写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> (ValidationRule rule : rules) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (rule.<span style=color:#a6e22e>type</span>()) { ... }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>👉 所以在这个<strong>当前版本的代码中，<code>ruleMap</code> 被创建了，但没被使用</strong>。
它是一个“预留设计”或“未来优化点”。</p><hr><h3 id=-第二部分那为什么要写它有什么用>🧠 第二部分：那为什么要写它？有什么用？<a hidden class=anchor aria-hidden=true href=#-第二部分那为什么要写它有什么用>#</a></h3><p>虽然现在没用，但它<strong>非常有用</strong>，尤其是在更复杂的场景中。举个例子：</p><p><strong>场景：你想先检查“是否必填”，再检查其他规则</strong></p><p>假设你新增一种规则类型：<code>"required"</code>（不能为空）。</p><p>你可能希望：</p><ol><li>先判断字段是不是 <code>null</code>；</li><li>如果是 <code>null</code>，就不用检查 <code>maxLength</code>、<code>pattern</code> 了（因为都没意义）。</li></ol><p>这时候，如果你有 <code>ruleMap</code>，就可以快速判断：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> (ruleMap.<span style=color:#a6e22e>containsKey</span>(<span style=color:#e6db74>&#34;required&#34;</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (value <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>equals</span>(value)) {
</span></span><span style=display:flex><span>        errors.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;该字段不能为空&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>; <span style=color:#75715e>// 跳过后续校验</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=-总结hashmap-在这段代码中的角色>📌 总结：<code>HashMap</code> 在这段代码中的角色<a hidden class=anchor aria-hidden=true href=#-总结hashmap-在这段代码中的角色>#</a></h3><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>是否运行？</strong></td><td>是的，每次校验字段时都会创建并填充它</td></tr><tr><td><strong>是否被使用？</strong></td><td>在你看到的简化版代码中 <strong>没有被使用</strong></td></tr><tr><td><strong>为什么存在？</strong></td><td>1. 为未来扩展做准备 2. 展示“如何用 Map 优化规则查找” 3. 很多真实框架（如 Hibernate Validator）内部确实用类似结构</td></tr><tr><td><strong>对小白的意义</strong></td><td>理解：<strong>Map 是用来“快速按名字找东西”的工具</strong></td></tr></tbody></table><hr><h3 id=-一句话记住>💡 一句话记住：<a hidden class=anchor aria-hidden=true href=#-一句话记住>#</a></h3><blockquote><p><strong><code>HashMap</code> 就像一本“规则字典”——你问“有没有 maxLength 规则？”，它立刻翻给你看；不用一条条去猜。</strong></p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/java/>Java</a></li><li><a href=http://ljj1992.fun/tags/java%E6%B3%A8%E8%A7%A3/>Java注解</a></li><li><a href=http://ljj1992.fun/tags/web%E5%BC%80%E5%8F%91/>Web开发</a></li><li><a href=http://ljj1992.fun/tags/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/>基础编程</a></li><li><a href=http://ljj1992.fun/tags/hashmap/>HashMap</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>