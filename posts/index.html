<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | star徐的博客</title><meta name=keywords content><meta name=description content="Posts - star徐的博客"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://ljj1992.fun/posts/index.xml title=rss><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="Posts"><meta property="og:description" content="个人博客，分享技术心得和生活感悟"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="个人博客，分享技术心得和生活感悟"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a></div><h1>Posts</h1></header><div class=posts><article class=post-entry><header class=entry-header><h2>JNDI注入</h2></header><div class=entry-content><p>JNDI注入 什么是内存马 内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。
内存马常见类别 • Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。 • Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。 • 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。 • 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行
为什么会存在内存马 根本原因在于 Java 的“动态性”： • 类可以在运行时从网络、数据库或其他非文件源加载； • 字节码可以被 Instrumentation API 在运行时修改； • 反射和动态代理允许在不改动源码的前提下改变程序行为。 攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。
Java 架构如何助长内存马 • JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类； • 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制； • “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。 因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。
一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。
一、什么是JNDI注入 JNDI为什么会成为黑客的工具
1.1 一句话区分： JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。
...</p></div><footer class=entry-footer><span title='2025-11-21 12:44:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to JNDI注入" href=http://ljj1992.fun/posts/jndi%E6%B3%A8%E5%85%A5/></a></article><article class=post-entry><header class=entry-header><h2>注解和Map(新手理解)</h2></header><div class=entry-content><p>注解和Map(新手理解) 把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。
Map 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：
第一列叫“键”（Key） 第二列叫“值”（Value） 只要给出一个 Key，就能立刻找到它对应的 Value。 常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。
举个生活化的例子： 如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。
注解和 Map 的关系 注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。 你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：
注解里的每一个属性（比如 @MyAnnotation(value="test", version=2) 中的 value、version） 都会被放进一个 Map 里，key 就是属性名，value 就是属性值。 当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。 所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景： 灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。
一句话总结 Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。
一、🎯 目标： 我们想做一个“用户信息校验”功能，比如：
用户名不能超过10个字符 年龄必须在18到60之间 邮箱必须包含 @ 符号 但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。
...</p></div><footer class=entry-footer><span title='2025-11-21 10:50:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 注解和Map(新手理解)" href=http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/></a></article><article class=post-entry><header class=entry-header><h2>观察者模式(YouTuber订阅)</h2></header><div class=entry-content><p>观察者模式(YouTuber订阅) 一、观察者模式到底是干嘛的？为什么会有人发明它？ 想象一下现实生活中的场景：
你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。
这里的关键问题就是：
“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”
如果没有观察者模式，我们会怎么做？最笨的办法：
老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知； 或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。 这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。
观察者模式解决的核心痛点： 解耦：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。 一对多依赖：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。 动态订阅/退订：粉丝可以随时订阅、随时取关，主题完全不关心。 松耦合：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。 一句话总结： 当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。
二、经典使用场景（你以后一定会遇到） 聊天软件：有人发消息，所有在线好友收到通知 股票软件：股价变动，所有关注这只股票的人收到推送 GUI界面：点击按钮，所有注册了点击事件的监听器执行 消息队列、事件总线（EventBus） Vue/React 中的数据响应式（本质也是观察者） Python 中的信号槽（PyQt/PySide）、Java 中的 Listener 三、用大白话理解观察者模式的四个核心角色 角色 现实中对应 代码中对应 职责 Subject（主题） YouTuber Youtuber 类 维护订阅者列表，提供 attach/detach/notify 方法 Observer（观察者接口） “订阅后必须能收到通知”这个约定 Observer 抽象类 定义 update 方法 ConcreteObserver（具体观察者） 具体的粉丝小明、小红 Fan 类 实现 update，真正干活的地方 Client（客户代码） 我们写的主程序 最后的运行逻辑 创建对象、订阅、触发通知 四、代码分析 # ------------------------------------------------- # 步骤1：定义“主题”（Youtuber） # ------------------------------------------------- class Youtuber: # 定义一个类，名叫 Youtuber，代表“被订阅的对象” def __init__(self, name): # 构造函数，创建对象时自动执行 self.name = name # 给这个YouTuber起个名字，比如“老王” self._observers = [] # 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问 # [] 表示创建一个空列表，用来装所有粉丝对象 def attach(self, observer): # “订阅”方法，参数 observer 就是一个粉丝对象 """添加一个观察者（订阅）""" if observer not in self._observers: # 判断这个粉丝是否已经订阅过，防止重复 self._observers.append(observer) # append 是列表的内置方法，把粉丝对象加到列表末尾 print(f"[{observer.name}] 订阅了 [{self.name}]") # 打印一条提示信息 def detach(self, observer): # “取消订阅”方法 """移除一个观察者（取消订阅）""" try: self._observers.remove(observer) # remove 是列表的内置方法，直接删除这个对象 print(f"[{observer.name}] 取消订阅了 [{self.name}]") except ValueError: # 如果列表里根本没有这个对象，remove 会报错 pass # 我们选择忽略这个错误，什么都不做 def notify(self, video_title): # 最最重要的“发布视频”方法，也就是状态发生变化 """通知所有观察者""" print(f"\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...") for observer in self._observers: # 遍历当前所有的粉丝对象 observer.update(self.name, video_title) # **核心中的核心！** # 调用每个粉丝的 update 方法，把视频信息告诉他 # ------------------------------------------------- # 步骤2：定义“观察者”模板和具体观察者（粉丝） # ------------------------------------------------- from abc import ABC, abstractmethod # 从 abc 模块导入工具，用来创建抽象类 class Observer(ABC): # 定义一个抽象基类（模板），所有观察者都必须遵守 @abstractmethod # 装饰器：表示下面的方法是“抽象方法”，子类必须实现 def update(self, youtuber_name, video_title): # 抽象方法，只定义签名，不写具体内容 pass # pass 表示“占个位置，啥也不干” class Fan(Observer): # Fan 类继承 Observer，代表具体的粉丝 def __init__(self, name): self.name = name # 每个粉丝也有自己的名字 def update(self, youtuber_name, video_title): # 必须实现父类的抽象方法，否则会报错 """当收到通知时，粉丝的反应""" print(f" -> 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]") # 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等 # ------------------------------------------------- # 步骤3：运行逻辑（真正看到效果的地方） # ------------------------------------------------- # 1. 创建主题和观察者 youtuber_A = Youtuber("老王") # 创建一个YouTuber，名字叫“老王” fan_1 = Fan("小明") # 创建三个粉丝对象 fan_2 = Fan("小红") fan_3 = Fan("小刚") # 2. 观察者“订阅”主题 youtuber_A.attach(fan_1) # 小明和小红先订阅 youtuber_A.attach(fan_2) # 3. 主题发布新内容（状态变更） youtuber_A.notify("观察者模式入门") # 老王发第一条视频，只有小明和小红收到 # 4. 另一个粉丝也订阅了 youtuber_A.attach(fan_3) # 小刚中途订阅 # 5. 小红取消订阅 youtuber_A.detach(fan_2) # 小红取关 # 6. 主题再次发布新内容 youtuber_A.notify("工厂模式yyds") # 老王再发一条视频，只有小明和小刚收到 运行后你会看到输出：
...</p></div><footer class=entry-footer><span title='2025-11-20 15:36:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 观察者模式(YouTuber订阅)" href=http://ljj1992.fun/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2>策略模式</h2></header><div class=entry-content><p>策略模式 🌟 什么是策略模式？ 一句话解释：
策略模式就是“把不同的做法（算法）封装成独立的类，让它们可以互相替换，而不影响主程序”。
就像你出门：
可以走路 可以骑车 可以开车 可以坐地铁 这些是不同的“策略”，你根据情况选择一种。程序里也一样，我们可以把每种“方式”封装起来，随时切换。
✅ 场景举例：不同支付方式（微信、支付宝、银行卡）
我们写一个简单的购物程序，支持多种支付方式，使用策略模式来实现。
💡 第一步：定义一个“支付策略”接口 // 定义一个统一的“支付方式”接口 // 所有具体的支付方式（如微信、支付宝）都要实现这个接口 public interface PaymentStrategy { // 这个方法表示“执行支付”，具体怎么付由子类决定 void pay(double amount); } 🔍 解释：
interface 是 Java 中的“接口”，规定了一组行为（方法）。 这里说：任何支付方式都必须有 pay(double amount) 方法。 但不关心它内部怎么实现，只关心“能付钱”。 💡 第二步：实现具体的支付策略 1. 微信支付策略 // 微信支付的具体实现类 public class WeChatPayment implements PaymentStrategy { // 实现 pay 方法：用微信支付 @Override public void pay(double amount) { System.out.println("✅ 使用微信支付：金额 " + amount + " 元"); System.out.println("📱 扫码成功，正在扣款..."); System.out.println("🔔 微信提示：支付成功！"); } } 🔍 解释：
...</p></div><footer class=entry-footer><span title='2025-11-20 15:30:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 策略模式" href=http://ljj1992.fun/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2>Skill Seeker中文使用手册</h2></header><div class=entry-content><p>Skill Seeker中文使用手册 概述：Skill Seeker 是什么？ Skill Seeker 是一个开源工具，由 Yusuf Karaaslan 开发（GitHub 仓库：https://github.com/yusufkaraaslan/Skill_Seekers），旨在从文档网站（如编程框架、API 或游戏引擎的官方文档）中自动抓取、组织和打包内容，创建“skills”（技能包）。这些技能包可以上传到 Anthropic 的 Claude AI（特别是 Claude Code），让 Claude 成为特定领域的“专家”，例如 React、Godot 或 Steam API 的文档专家。
核心目的：简化将大量文档注入 AI 的过程，让用户可以通过自然语言查询获取准确、结构化的信息，而无需手动搜索或复制文档。基于提供的参考文件（如 QUICKSTART.md 和 MCP_SETUP.md），它专注于自动化文档处理，支持从小型网站到大型文档（如 10K+ 页）的抓取，并通过增强功能（如本地或 API 增强）提升技能包的质量。
从我的理解来看，Skill Seeker 解决了 AI 知识局限性的痛点：在通用 AI 如 Claude 中注入专业知识通常很繁琐（手动上传文件或编写提示），而 Skill Seeker 像一个“文档到 AI 技能”的桥梁，让非技术用户也能轻松创建自定义 AI 助手。它强调效率、隔离依赖和可扩展性，适合开发者、教育者和研究者使用。
架构组成与设计框架 整体架构
Skill Seeker 采用模块化设计，分为 CLI（命令行接口）、MCP 服务器和辅助脚本。核心是 Python 脚本，使用 requests 和 beautifulsoup4 抓取网页。
CLI 核心（cli/ 目录） doc_scraper.py：抓取文档，生成 raw 数据和技能目录。 pdf_extractor_poc.py：PDF 处理，支持 OCR、表格、图像提取。 enhance_skill_local.py：本地增强 SKILL.md。 package_skill.py：打包 ZIP。 split_config.py：分割大型配置。 estimate_pages.py：估算页面数。 MCP 服务器（skill_seeker_mcp/ 目录） server.py：MCP 协议服务器，与 Claude Code 通信，支持 9 个工具（如 generate_config、scrape_docs）。 通过自然语言桥接 CLI 功能。 配置与输出 configs/：JSON 预设（如 base_url、max_pages）。 output/：技能目录（SKILL.md + references/）和 ZIP 文件。 依赖：requests、beautifulsoup4、pytesseract（OCR）、PyMuPDF（PDF）等。虚拟环境（venv）隔离。 设计框架
...</p></div><footer class=entry-footer><span title='2025-11-19 17:00:00 +0800 +0800'>November 19, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to Skill Seeker中文使用手册" href=http://ljj1992.fun/posts/skillseeker2025111901/></a></article><article class=post-entry><header class=entry-header><h2>SuperClaude.md</h2></header><div class=entry-content><p>SuperClaude中文使用手册 一、产品概述 SuperClaude 是一个上下文工程框架 (Context Engineering Framework)。
可以把它想象成一套给 Claude Code 使用的**“专家行为配置包”。它通过一系列精心设计的 Markdown (.md) 指令文件，来配置和增强**你现有的 Claude Code，注入特定的行为、知识和工作流程。
💡 核心比喻：
标准 Claude Code 就像一位知识渊博、但经验泛泛的全才程序员。 SuperClaude 则给了这位程序员一整套专家工具箱：里面有顶尖架构师的设计蓝图、安全专家的审计清单、前端大师的组件库以及项目经理的详细流程图。 当你使用 SuperClaude 的命令时，你其实是在告诉这位全才程序员：“嘿，现在请你戴上‘安全专家’的帽子，并遵循这套‘代码审计’的流程来工作。”
1.它解决了什么核心痛点 从“随性”到“系统”：标准的AI编程往往是“一问一答”式的，缺乏系统性和长远规划。SuperClaude 将这种随性的请求，转化为结构化的、可验证的、有质量门禁的开发工作流。 从“全才”到“专家”：通用AI模型在特定领域的深度和最佳实践上有所欠缺。SuperClaude 通过 AI Agents (AI 专家) 机制，让 Claude Code 能够调用特定领域的深层知识，如安全、性能、前端架构等。 从“短期记忆”到“长期项目”：AI 在长对话中容易丢失上下文。SuperClaude 通过会话管理和 MCP 服务器 (如 Serena)，实现了跨对话的持久化项目记忆，让你可以真正地进行长期、复杂的项目开发。 从“孤立工具”到“生态联动”：AI 无法直接使用外部工具。SuperClaude 通过 MCP 服务器，打通了 Claude Code 与真实开发工具（如浏览器测试、UI组件库、文档查询等）的连接，极大地扩展了其能力边界。 2.SuperClaude的解决方案 14个领域专家自动协作，无需手动切换 21个系统命令提供端到端工作流 持久会话管理保持项目上下文 智能工具路由自动选择最佳MCP服务器 质量门控自动集成安全、性能、测试专家 3.产品特点 🧠 21个命令：结构化开发工作流（如/sc:brainstorm, /sc:analyze） 🧪 14个AI代理：领域专家（如@agent-security, @agent-python） ⚙️ 6种行为模式：上下文优化模式（如--ultrathink, --token-efficient） 🔌 6个MCP服务器：工具集成（如Morphllm, Tavily） 📦 无缝集成：直接在Claude Code中使用/sc:命令 💡 关键洞察：SuperClaude不是执行软件，而是配置框架，通过修改Claude Code的上下文来增强其行为。它不替代Claude Code，而是使其成为更强大的开发伙伴。
...</p></div><footer class=entry-footer><span title='2025-11-18 17:35:00 +0800 +0800'>November 18, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to SuperClaude.md" href=http://ljj1992.fun/posts/superclaude/></a></article><article class=post-entry><header class=entry-header><h2>servlet基础知识</h2></header><div class=entry-content><p>servlet基础知识 作为安全爱好者的基础性研究
Servlet：名字的由来
Servlet = “Server” + “Applet” 早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 服务器端 的小程序，所以叫 “Server Applet”，简称 Servlet。
它在解决什么问题？
动态内容：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。 性能瓶颈：传统 CGI 为每个请求开一个进程，开销大、响应慢。 跨平台：CGI 脚本依赖操作系统，移植困难。 ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。
作用一句话
接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。
底层逻辑与框架
阶段 动作 关键角色 1. 请求到达 浏览器发 HTTP 请求到 Web 服务器（如 Tomcat） Web 服务器 2. 路由到 Servlet 服务器根据 URL 把请求交给对应的 Servlet 类 Servlet 容器 3. 生命周期 容器负责：加载类 → 创建实例 → 调用 init() → 多次 service() → 最终 destroy() Servlet 本身 4. 处理请求 service() 方法根据 HTTP 方法（GET/POST）调用 doGet()/doPost()，开发者只写业务逻辑 HttpServlet 5. 生成响应 通过 HttpServletResponse 写回 HTML、JSON 或文件 Servlet 6. 线程复用 同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁 JVM 线程池 核心优势
...</p></div><footer class=entry-footer><span title='2025-11-17 23:58:00 +0800 +0800'>November 17, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to servlet基础知识" href=http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/></a></article><article class=post-entry><header class=entry-header><h2>claudecode常用命令使用解析</h2></header><div class=entry-content><p>Claude Code 常用命令使用解析 大家好，作为一个刚接触 Claude Code 的新手，我根据官方文档和一些热门的介绍视频，整理这份学习笔记和实践总结。主要是为了记录自己的学习过程，同时也希望能起到一个抛砖引玉的作用，为同样在入门路上的朋友们提供一些参考和便利。
这篇总结更多是我个人的理解和实践，内容可能比较基础，难免有疏漏或错误之处，对于经验丰富的高手们，可以直接略过这篇文章。
🚀 第一部分：基础入门 - 安装与启动 1. 环境准备 安装 Node.js： Claude Code 是一个基于 Node.js 的命令行工具。请先访问 Node.js 官网，下载并安装推荐的 LTS (长期支持) 版本。 2. 安装 Claude Code 打开你的终端（Windows 用户使用 PowerShell，Mac/Linux 用户使用 Terminal），输入以下命令并回车：
codeBash
npm install -g @anthropic-ai/claude-code 【原理讲解】 npm 是 Node.js 的包管理器。-g 参数代表“全局安装”，这意味着你可以在电脑的任何文件夹中使用 claude 命令。
3. 启动与初始化 创建项目文件夹： 在你希望的位置创建一个新文件夹（例如 my-first-app），然后通过终端进入该文件夹。 启动 Claude Code： 在项目文件夹的终端中，输入 claude 并回车。 初始化项目： 启动后，立刻输入 /init 命令。 【至关重要】 /init 命令是与 Claude Code 高效协作的基石。它会扫描当前项目并创建一个 CLAUDE.md 文件。这个文件相当于 AI 的“项目记忆”，后续所有操作，AI 都会参考它来理解你的项目结构，确保它的行为与你的项目高度相关。
...</p></div><footer class=entry-footer><span title='2025-11-17 17:20:00 +0800 +0800'>November 17, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to claudecode常用命令使用解析" href=http://ljj1992.fun/posts/claudecode%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/></a></article><article class=post-entry><header class=entry-header><h2>Java内存马-监听器</h2></header><div class=entry-content><p>Java内存马-监听器 以下内容仅限Java小白，高手无视就可以
一、 Java 监听器到底有啥用？ 你可以把监听器想象成“保安”或者“监控摄像头”。 在 Web 应用里，有三件大事经常发生：
应用启动 / 关闭（ServletContext） 用户登录 / 退出（HttpSession） 每次发请求 / 请求结束（ServletRequest） 监听器就是提前注册好，告诉系统：“一旦发生上面这些事，就立刻通知我，让我执行一段代码”。
比如：
应用启动时，自动创建数据库连接池； 用户登录时，记录日志； 每次请求到来时，检查是否携带了合法的 token。 这样就把“业务逻辑”和“事件”分开，代码更清晰，也更容易扩展。
二、 为什么监听器能变成“内存马”？ 内存马”就是黑客把一段恶意代码悄悄塞进正在运行的 Java 应用里，让它像木马一样长期潜伏，即使服务器重启也不会消失（因为代码已经加载到内存）。 监听器之所以容易被利用，是因为：
它能在每次请求或应用启动时自动执行；
只要能往 web.xml 里加一行配置，或者用注解 @WebListener，就能让这段代码生效；
黑客把恶意逻辑写在监听器的回调方法里，就能在不修改原有业务代码的情况下，偷偷执行命令、回弹 shell 等。
三. 工作原理 Java Web 的监听器基于“观察者模式”：
被观察者（事件源）：ServletContext、HttpSession、ServletRequest 等；
观察者（监听器）：你写的类，实现对应的 *Listener 接口；
当事件源状态变化（创建、销毁、属性改变），容器会自动调用监听器里对应的方法。
3.1 举个简单的“监听器”例子 // 1. 导入需要的类 import javax.servlet.ServletRequest; import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; import javax.servlet.annotation.WebListener; // 2. 告诉 Tomcat：这是一个监听器，请自动注册 @WebListener public class MyRequestListener implements ServletRequestListener { // 3. 当请求开始时（用户发来请求），这个方法自动执行 @Override public void requestInitialized(ServletRequestEvent event) { System.out.println("🔔 请求开始了！有人访问服务器了！"); // 4. 我们还可以拿到具体是哪个请求 ServletRequest request = event.getServletRequest(); String remoteAddr = request.getRemoteAddr(); // 用户的 IP String method = request.getMethod(); // 请求方式 GET/POST String uri = request.getRequestURI(); // 访问的路径 System.out.printf("📌 来访者IP: %s | 方法: %s | 路径: %s%n", remoteAddr, method, uri); } // 5. 当请求结束时（服务器响应完），这个方法自动执行 @Override public void requestDestroyed(ServletRequestEvent event) { System.out.println("🔚 请求结束了！用户请求处理完成。"); } } 🔍逐行解释：
...</p></div><footer class=entry-footer><span title='2025-11-17 16:30:00 +0800 +0800'>November 17, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to Java内存马-监听器" href=http://ljj1992.fun/posts/java%E5%86%85%E5%AD%98%E9%A9%AC-%E7%9B%91%E5%90%AC%E5%99%A8/></a></article><article class=post-entry><header class=entry-header><h2>CC链跟踪</h2></header><div class=entry-content><p>你的文章正文内容，从这里开始… 写在前面：一份关于CC1调用链的个人学习笔记 在您深入阅读本文档之前，笔者希望先分享几点说明：
要完全理解本文所剖析的调用链，建议您对Java中的一些基础概念有一定了解，例如 Map 接口、注解（Annotation）、反射（Reflection）以及 HashMap 的内部工作方式。尤其是，理解 Map 结构与Java注解机制如何在此场景下协同工作，并最终为何会成为触发漏洞的关键，是掌握整个攻击链的重中之重。
我本人也没有从事过Java开发，说实话也是东一榔头西一棒子的学习零散知识，本文并非原创性的漏洞研究，其内容是在安全领域前辈们（大神）已经完整梳理出攻击链的基础之上，并借助AI辅助学习和分析(源码不能确保百分百真实，但是逻辑经过我确认应该没问题的)，将整个调用流程一步步跟踪下来，旨在理清每一环节的执行逻辑与内在联系。
因此，这更像是一篇详细的学习笔记和思考过程的记录。希望能对同样在学习路上的朋友们有所启发，文中若有任何疏漏或不当之处，也恳请各位不吝赐教。
一、核心思想概述 “⚠️ 本测试方案仅用于安全研究与学习目的。任何未经授权的利用行为均违反法律，请务必在授权的测试环境中使用。”
目标：通过AnnotationInvocationHandler和TransformedMap构造恶意对象，在反序列化时触发Runtime.exec()执行任意命令。
✍️核心逻辑： 攻击者使用 TransformedMap.decorate() 方法，将一个包含恶意 ChainedTransformer 链的 valueTransformer 绑定到一个普通的 HashMap 上，构造出具有自动转换能力的恶意 TransformedMap。 该 ChainedTransformer 链被精心设计为依次执行：获取 Runtime.class → 反射调用 getRuntime() → 获取 Runtime 实例 → 调用 exec("calc")，从而实现任意命令执行。 攻击者通过反射创建 AnnotationInvocationHandler 实例，并将上述恶意 TransformedMap 作为其 memberValues 字段的值，使该 handler 在语义上“看起来像”一个合法的注解代理对象。 攻击者将整个 AnnotationInvocationHandler 对象序列化，生成可传输的 payload，并发送给存在反序列化漏洞的目标服务。 目标服务在反序列化该 payload 时，自动调用 AnnotationInvocationHandler.readObject() 方法；该方法会遍历 memberValues.entrySet()，并对每个条目进行类型校验。 在反序列化过程中，AnnotationInvocationHandler.readObject()会遍历memberValues的键值对。当它尝试将memberValues中的值转换为注解定义的类型时，如果类型不匹配（如String被转换为Integer），JDK会自动调用entry.setValue(newValue)，来更新值，即使新旧值相同。这个动作恰好触发了我们预设的陷阱。 💡不懂的强烈建议学下Map和注解是干什么的，其实最终目的就是为了解耦，本人也是Java小白 而 TransformedMap 重写了 entrySet()，返回的是自定义的 EntrySetView；其迭代器 TransformedMapEntryIterator 会将原始 Map.Entry 包装为 TransformedMapEntry，并在构造时保存对 TransformedMap 自身（即 parent）的引用。 因此，e.setValue(newValue) 实际调用的是 TransformedMapEntry.setValue()，该方法首先调用 parent.checkSetValue(value)，进而触发 valueTransformer.transform(value)。 最终，绑定在 TransformedMap 中的 ChainedTransformer 链被执行，完成 Runtime.getRuntime().exec("calc") 的调用，实现远程命令执行（RCE）。 📝 漏洞原理"小结 “漏洞本质：利用JDK反序列化过程中对AnnotationInvocationHandler的处理逻辑，结合Apache Commons Collections的TransformedMap的自动转换特性，实现任意命令执行。”
...</p></div><footer class=entry-footer><span title='2025-11-13 19:00:00 +0820 +0820'>November 13, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to CC链跟踪" href=http://ljj1992.fun/posts/cc%E9%93%BE%E8%B7%9F%E8%B8%AA/></a></article></div><nav class=pagination><a class=next href=/posts/page/2/>Next »</a></nav></main><footer class=footer><span>&copy; 2025 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>