<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | star徐的博客</title><meta name=keywords content><meta name=description content="Posts - star徐的博客"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://ljj1992.fun/posts/index.xml title=rss><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="Posts"><meta property="og:description" content="个人博客，分享技术心得和生活感悟"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="个人博客，分享技术心得和生活感悟"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a></div><h1>Posts</h1></header><div class=posts><article class=post-entry><header class=entry-header><h2>解构 Anthropic Agent 标准：深入理解并构建 Claude Skills</h2></header><div class=entry-content><p>解构 Anthropic Agent 标准：深入理解并构建 Claude Skills 简介：
在大模型应用开发中，如何让 LLM 既保持通用的对话能力，又能精准执行特定领域的复杂任务？Anthropic 最近推出的 Claude Code 和配套的 Skills 架构 给出了一个优雅的答案。
这里的 Skills 并非简单的系统提示词（System Prompt），而是一个包含**路由层（Router）、指令层（Instruction）和执行层（Execution）**的完整微服务架构。它允许 Claude 根据用户意图动态挂载上下文，甚至调用本地 Python 脚本执行实际操作。这实际上是将传统的“人机对话”升级为了“人与 Agent 的协作”。
在这篇文章中，我整理了基于官方文档Skills 的运行原理，并跳过繁琐的理论，通过贴近实际的演示案例来如何利用 Claude 的自举能力（Bootstrapping）来快速构建高效的 Agent 技能包。
一、安装要求： 网络环境需要自己解决，我建议使用Linux（Ubuntu系统），如果你是Windows系统可以安装WSL配合Vscode插件也非常好用
在 Ubuntu 系统（需为 20.04+ 版本）上安装 Claude Code 非常简单，官方推荐使用原生安装程序。
以下是具体的安装步骤：
系统要求检查 • 操作系统：Ubuntu 20.04 或更高版本。
• 硬件：至少 4 GB 内存。
• 网络：需要互联网连接。
执行安装命令（推荐方式） 在终端中直接运行以下官方提供的原生安装脚本，这是最快且最稳定的方式：,
curl -fsSL https://claude.anthropic.com/install.sh | sh 此脚本会自动下载适用于 Linux 的二进制文件并完成配置。
二、Skills 的架构与运行原理 Claude Skills（特别是用于 Claude Code CLI 的 Skills）的核心设计理念是按需加载的专家系统。它的架构可以清晰地分为三层：
...</p></div><footer class=entry-footer><span title='2026-02-03 15:30:00 +0800 +0800'>February 3, 2026</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 解构 Anthropic Agent 标准：深入理解并构建 Claude Skills" href=http://ljj1992.fun/posts/agentskill/></a></article><article class=post-entry><header class=entry-header><h2>openspec新人手册</h2></header><div class=entry-content><p>openspec新人手册 欢迎来到OpenSpec的新人手册！本手册将为您全面介绍OpenSpec的理念、工作流程和使用方法，帮助您快速掌握这个强大的AI编程规范工具。
✨ 为什么选择 OpenSpec？ AI 编码助手功能强大，但如果需求记录在聊天记录中，其表现就难以预测。OpenSpec 提供了一种轻量级的规范工作流程，在实现之前锁定意图，从而提供确定性且可审查的输出。
🎯 主要成果： 共识达成：在工作开始前，人类和人工智能相关人员需就技术规范达成一致 结构化变更：结构化的变更文件夹（提案、任务和规范更新）使范围明确且可审计 可见性共享：共享对已提议、正在进行或已存档内容的可见性 工具兼容：可与您已使用的 AI 工具配合使用：在支持自定义斜杠命令的地方使用自定义斜杠命令，在其他所有地方使用上下文规则 📊 OpenSpec 的对比（概览） 特性 OpenSpec 传统AI编程 工作流程 简单轻量级 复杂不可预测 现有功能移植 优秀（0→1和1→n） 困难（仅0→1优秀） 变更跟踪 完整提案-任务-归档流程 无系统化跟踪 兼容性 无需API密钥，设置极少 依赖特定工具 详细对比：
轻量级：工作流程简单，无需 API 密钥，设置极少 先进行现有功能移植：在 0→1 之后也能很好地工作。OpenSpec 将真实数据源与提案分开：@0#（当前真实数据源）和 @1#（提案更新）。这使得不同功能之间的差异清晰明了且易于管理 变更跟踪：提案、任务和规范增量放在一起；归档会将已批准的更新合并回规范中 与 spec-kit 和 Kiro 相比：它们在全新特性（0→1）方面表现出色。OpenSpec 在修改现有行为（1→n）方面也同样优秀，尤其是在更新涉及多个规范时 🔄 工作原理 OpenSpec 的核心理念是通过四个阶段将模糊需求转化为精确代码：
┌──────────────────────────────┐ │ 1. 意图"翻译" (Draft) │ │ (把"人话"变成"技术文档") │ └──────────────┬───────────────┘ │ 你的原始需求："给网页加个夜间模式" ▼ ┌──────────────────────────────┐ │ 2. 签订"施工合同" (Review) │◀───[ 拒绝无效返工 ]───┐ │ (锁定修改范围，禁止AI乱动) │ │ └──────────────┬───────────────┘ │ │ 你点头确认："就改这3个文件，别的别动" │ ▼ │ ┌──────────────────────────────┐ │ │ 3. 傻瓜式执行 (Implement) │ 🚧 发现逻辑漏洞？ │ │ (AI 闭嘴干活，只写代码) │ 🛑 停！回去改文档！────┘ └──────────────┬───────────────┘ │ 代码跑通，测试通过 ▼ ┌──────────────────────────────┐ │ 4. 更新"项目宪法" (Archive) │ │ (让项目永远保持最新状态) │ └──────────────────────────────┘ 我把这个流程分成了四个更有深度的阶段，咱们一个个来看：
...</p></div><footer class=entry-footer><span title='2025-12-13 15:30:00 +0800 +0800'>December 13, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to openspec新人手册" href=http://ljj1992.fun/posts/openspec%E6%96%B0%E4%BA%BA%E6%89%8B%E5%86%8C/></a></article><article class=post-entry><header class=entry-header><h2>Gemini Cli 新手教程</h2></header><div class=entry-content><p>Gemini Cli 新手教程 windows安装gemini cli 安装到D盘的方式： 默认情况下，Node.js 的安装机制（npm）会将全局包（Global Packages）和缓存都放在 C 盘的用户目录下（AppData），随着时间推移，这会占用大量空间。
作为专家，我为你提供一套最稳妥、最标准的解决方案：修改 npm 的全局安装路径配置。这样你不需要重新安装 Windows，也不用把 Node.js 主程序卸载（虽然也可以），就能把占用空间最大的“包”和“缓存”全部迁移到 D 盘。
请跟着我的步骤一步步操作：
第一步：在 D 盘建立专属目录 我们需要在 D 盘手动创建两个文件夹，一个用来放程序（如 Gemini CLI），一个用来放缓存。
打开 D 盘。 创建一个名为 NodeJS 的文件夹（名字随意，建议英文，不要有空格）。 进入 D:\NodeJS，再新建两个文件夹： node_global （用来存放安装的程序，如 gemini） node_cache （用来存放下载过程中的缓存，省 C 盘空间） 第二步：告诉 npm 修改路径 打开你的终端（PowerShell 或 CMD），分别输入以下两条命令（一行输入完按回车）：
修改全局安装路径到 D 盘：
npm config set prefix "D:\NodeJS\node_global" 修改缓存路径到 D 盘：
npm config set cache "D:\NodeJS\node_cache" 验证一下： 输入 npm config list，检查输出信息中是否包含了你刚才设置的 D 盘路径。
...</p></div><footer class=entry-footer><span title='2025-11-28 12:35:00 +0800 +0800'>November 28, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to Gemini Cli 新手教程" href=http://ljj1992.fun/posts/gemini-cli-%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B/></a></article><article class=post-entry><header class=entry-header><h2>Gemini API File Search</h2></header><div class=entry-content><p>Gemini API File Search 一. 概述 核心功能：它是一个全托管的RAG（检索增强生成）服务。开发者不需要自己搭建向量数据库、不需要自己写代码切分文档、不需要计算Embedding（向量化），直接把文件扔给Google，它就能自动处理好索引和检索。 最大卖点： 极简开发：从原来的“搭建复杂的RAG系统”变成了“几行API代码调用”。 成本极低：视频强调了目前的高性价比，甚至存储和检索在一定额度内免费（具体看下文分析）。 自带引用：回答问题时会自动标注参考了文档的哪一部分，解决了AI胡编乱造的问题。 二、深度问答与分析 Q1: API 托管 RAG 是最新的技术吗？ 结论：不是行业首创，但在“性价比”和“生态整合”上是强有力的竞争者。
竞品对比： OpenAI：早在2023年推出的 Assistants API 中就包含了 file_search（以前叫Retrieval）功能。原理几乎一模一样：上传文件 -> 自动切片 -> 自动检索。 Anthropic (Claude)：目前主要依赖长上下文（Context Window）硬吃文件，或者需要配合第三方库，还没有原生的类似Assistants API这种全托管RAG接口。 Gemini的后发优势： 上下文窗口更大：Gemini 1.5 Pro/Flash 支持百万级token，结合File Search可以处理更复杂的混合场景。 价格策略：OpenAI的向量存储是按GB收费的，而Gemini API目前的策略非常激进（在很多层面上提供了免费的存储额度或极低的索引费），这对开发者吸引力巨大。 Q2: 它和传统RAG、增强性RAG的区别？ 维度 传统 RAG (DIY) API 托管 RAG (Gemini File Search) 搭建难度 高。需要自己选向量数据库(Pinecone/Milvus)、自己写切片算法(Chunking)、选Embedding模型。 极低。黑盒服务，上传文件即可。 可控性 高。你可以精确控制怎么切分段落、用什么检索算法（混合检索/重排序）。 低。Google帮你决定怎么切、怎么搜，你只能调少量参数。 维护成本 高。需要运维数据库，关注数据更新和一致性。 零。Google维护。 技术归类 基础架构。 SaaS化服务 (RAG as a Service)。 关于增强性RAG (Advanced RAG)：增强性RAG通常指在检索前后加了“预处理（查询重写）”和“后处理（重排序 Rerank）”。Gemini File Search 内部其实已经集成了增强性技术（例如它会自动对检索结果进行相关性排序），只是没暴露给你看。所以它在效果上优于最简陋的传统RAG，但弱于顶级专家精心调优的定制化RAG。 Q3: 能解决什么痛点？ 门槛过高：以前想做个“知识库问答”，即使是Demo也要配环境、装库、买数据库服务。现在只要会调API就行。 效果调优难：新手很难搞定“文档切分”和“向量检索”的参数，Google用通用的最佳实践帮你解决了。 幻觉问题：通过强制的**Citation（引用归属）**功能，大大增加了回答的可信度，解决了老板和客户最担心的“AI瞎说”问题。 Q4: 未来方向 是的，绝对是方向。
...</p></div><footer class=entry-footer><span title='2025-11-26 18:00:00 +0800 +0800'>November 26, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to Gemini API File Search" href=http://ljj1992.fun/posts/gemini-api-file-search/></a></article><article class=post-entry><header class=entry-header><h2>AOP切面(java新手)</h2></header><div class=entry-content><p>AOP切面(java新手) 🌟 一、为什么要用 AOP？ 想象一下：你在开发一个电商网站，有几十个接口，比如
用户登录 下单 查看商品 修改地址 支付订单 这些功能都属于“业务逻辑”（核心功能）。但你发现，每个接口都需要做两件事：
记录日志（谁在什么时候调用了哪个接口？） 检查用户有没有权限（比如普通用户不能删别人订单） 如果不用 AOP，你可能会在每个方法里手动写日志和权限检查代码，像这样
问题来了：
代码重复！每个方法都要写一样的日志和权限。 业务逻辑被“污染”了，看不清核心功能。 如果哪天要改日志格式？得改几十个地方！ 👉 AOP 就是为了解决这种“横着切”的公共问题而生的！
👉 AOP 就是为了解决这种“横着切”的公共问题而生的！
✅ AOP 的核心思想： 把那些和业务无关但又到处要用的功能（比如日志、权限、事务、防重提交）抽出来，写在一个地方，自动“织入”到需要的地方。 业务代码只管做自己的事，干净清爽！
🧩 二、怎么理解 AOP？用两个真实例子 ✅ 自动记录接口日志（最常见！） 场景： 你想知道哪些用户调用了哪些接口、花了多长时间。
不用 AOP（麻烦）： 每个 Controller 方法里手写 logger.info(...)。
用 AOP（优雅）： 定义一个“切面”类（专门处理日志）： @Aspect @Component public class LogAspect { private static final Logger logger = LoggerFactory.getLogger(LogAspect.class); // 定义“切入点”：所有 Controller 包下的 public 方法 @Pointcut("execution(public * com.example.controller..*.*(..))") public void controllerMethods() {} // 在方法执行前记录开始 @Before("controllerMethods()") public void logBefore(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); logger.info("调用方法: {}, 参数: {}", methodName, Arrays.toString(args)); } // 在方法执行后记录耗时 @Around("controllerMethods()") public Object logTime(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); Object result = joinPoint.proceed(); // 执行原方法 long time = System.currentTimeMillis() - start; logger.info("方法 {} 耗时 {}ms", joinPoint.getSignature().getName(), time); return result; } } 你的业务代码完全不用改！ @RestController public class OrderController { @PostMapping("/order") public String createOrder(@RequestBody Order order) { // 只写业务逻辑！日志自动加上了 orderService.save(order); return "success"; } } ✅ 效果：只要调用 /order，AOP 自动帮你打日志、算时间，业务代码零侵入！
...</p></div><footer class=entry-footer><span title='2025-11-23 18:30:00 +0800 +0800'>November 23, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to AOP切面(java新手)" href=http://ljj1992.fun/posts/aop%E5%88%87%E9%9D%A2/></a></article><article class=post-entry><header class=entry-header><h2>AutoGen小白篇(Windows)</h2></header><div class=entry-content><p>AutoGen小白篇(Windows) 1. 什么是 AutoGen？它解决了什么痛点？ AutoGen 是一个开源框架，用于构建多代理（multi-agent）AI 应用程序，这些代理可以自主行动或与人类协作。根据提供的文档和 GitHub 仓库（https://github.com/microsoft/autogen），AutoGen 旨在简化 AI 代理系统的开发，支持从简单聊天代理到复杂分布式系统的构建。它由 Microsoft xAI 团队开发，支持 Python 和 .NET 等语言，强调事件驱动的编程模型、异步消息传递和可扩展性
从我的理解来看，AutoGen 不仅仅是一个库，而是一个生态系统，包括核心框架、扩展工具和开发者工具（如 AutoGen Studio）。它允许开发者创建 AI 代理，这些代理可以处理任务如代码生成、网页浏览、数学计算等，通过事件和消息进行协作。相比传统单代理系统，AutoGen 专注于多代理协作，类似于一个“AI 团队”来解决问题。
核心定义 它不仅仅是一个调用 LLM（大语言模型）的工具，而是一个协作平台。它允许你创建多个“角色”（Agents），这些角色可以相互对话、分工合作、调用工具，甚至可以让人类参与其中。
解决的痛点 单打独斗的局限性：单个 ChatGPT 只能回答问题，难以完成复杂任务（如“写代码并运行测试，如果报错则修复”）。AutoGen 让一个负责写，一个负责审，形成闭环。 上下文管理难：在长任务中，手动管理对话历史很痛苦。AutoGen 自动处理多轮对话的上下文。 工具集成繁琐：让 AI 浏览网页、执行 Python 代码通常需要大量胶水代码。AutoGen 提供了标准化的工具接口（如 MCP Server）。 扩展性差：旧的 Agent 框架难以跨语言或跨网络分布。v0.4 引入了“事件驱动”架构，支持分布式部署。 2. 核心特点与架构组成 (核心分析) AutoGen v0.4 的设计理念是 “异步、事件驱动、分布式”。
2.1 架构分层 AutoGen 的架构是分层的、可扩展的，基于发布-订阅模型。核心组件包括： 代理（Agents）：基本单元，处理事件、调用模型、访问内存或工具。每个代理有事件处理器（Event Handlers），响应特定事件类型。 事件（Events）：使用 CloudEvents 格式，包括 ID、源和类型。系统内置事件如系统事件（启动/停止代理）。 主题（Topics）：代理订阅主题以接收消息。主题 ID 包括类型和源，支持匹配和映射到代理。 服务（Services）：包括 Worker（托管代理）、Gateway（RPC 和事件桥接）、Registry（代理注册）、AgentState（持久状态）和 Routing（事件路由）。 后端选项：内存、Python 服务、Microsoft Orleans（分布式演员系统）。 整体架构：代理通过 Worker 连接服务，事件在服务间流动。分布式时，使用 gRPC 通信。
...</p></div><footer class=entry-footer><span title='2025-11-22 12:35:00 +0800 +0800'>November 22, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to AutoGen小白篇(Windows)" href=http://ljj1992.fun/posts/autogen/></a></article><article class=post-entry><header class=entry-header><h2>JNDI注入</h2></header><div class=entry-content><p>JNDI注入 什么是内存马 内存马是一段仅驻留在服务器内存中的恶意代码，它不写入磁盘文件，因此传统基于文件扫描的杀毒软件很难发现。在 Java 里，它通常表现为一个被动态加载到 JVM 内存中的恶意类，可以接收远程指令、执行任意命令或窃取敏感数据。
内存马常见类别 • Servlet 型：通过篡改或新增 Servlet、Filter、Listener 实现流量拦截与命令执行。 • Agent 型：利用 Java Instrumentation API 在运行时修改已有类的字节码，植入后门。 • 动态代理/反射型：通过 Proxy、InvocationHandler 或反射机制把恶意逻辑挂接到正常业务流程中。 • 代码执行型：借助脚本引擎（如 Nashorn、Groovy）把恶意脚本直接加载到内存并执行
为什么会存在内存马 根本原因在于 Java 的“动态性”： • 类可以在运行时从网络、数据库或其他非文件源加载； • 字节码可以被 Instrumentation API 在运行时修改； • 反射和动态代理允许在不改动源码的前提下改变程序行为。 攻击者正是利用这些特性，把恶意代码“注入”到正在运行的 JVM 里，而不留下任何文件痕迹。
Java 架构如何助长内存马 • JVM 的类加载机制是“按需加载”，运行时可随时从任意来源读取字节码并定义成类； • 运行时数据区（堆、方法区等）对动态生成的类和对象没有额外限制； • “沙箱”模型只在早期 Applet 时代严格实施，现代服务器应用往往以全权模式运行，一旦获得 ClassLoader 或 Instrumentation 实例，就能突破信任边界。 因此，只要攻击者拿到能够动态加载或修改字节码的入口（如反序列化漏洞、JNDI 注入、Groovy 脚本执行等），就能把恶意逻辑直接塞进内存，形成无文件驻留。
一句话总结：内存马的本质是“把恶意代码当成普通 Java 类一样加载到内存并执行”，它之所以能成为“无文件”，正是因为 Java 的类加载、字节码改写和反射机制允许在不落地文件的前提下完成整个攻击链。
一、什么是JNDI注入 JNDI为什么会成为黑客的工具
1.1 一句话区分： JNDI 注入是黑客把“资源查找”这把正经钥匙，拧成了撬锁的铁丝。
...</p></div><footer class=entry-footer><span title='2025-11-21 12:44:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to JNDI注入" href=http://ljj1992.fun/posts/jndi%E6%B3%A8%E5%85%A5/></a></article><article class=post-entry><header class=entry-header><h2>注解和Map(新手理解)</h2></header><div class=entry-content><p>注解和Map(新手理解) 把「注解」和「Map」结合起来用，让你明白它们在实际开发中是怎么配合工作的。
Map 就是“映射”的意思，你可以把它想象成一张 Excel 表，只有两列：
第一列叫“键”（Key） 第二列叫“值”（Value） 只要给出一个 Key，就能立刻找到它对应的 Value。 常见的 HashMap、TreeMap、LinkedHashMap 都是 Java 里对 Map 的具体实现，它们的共同接口就是 java.util.Map。
举个生活化的例子： 如果你想用手机号（Key）查人名（Value），用 Map 就像查通讯录，输入号码就能秒回名字，不用从头翻到尾。
注解和 Map 的关系 注解（Annotation）本质上是一段附加在类、方法或字段上的“元数据”。 你可能觉得注解就是个标签，其实 JVM 在底层把每个注解都当成一个 Map 来存储：
注解里的每一个属性（比如 @MyAnnotation(value="test", version=2) 中的 value、version） 都会被放进一个 Map 里，key 就是属性名，value 就是属性值。 当你用反射调用 method.getAnnotation(MyAnnotation.class) 时，JVM 会从这张“注解属性表”（也就是 Map）里把值取出来，再通过动态代理把它们返回给你。 所以，注解在 JVM 眼里就是一张只读的键值表——这正是 Map 最擅长的场景： 灵活、可扩展、查询快，而且天然支持“属性名→属性值”的映射逻辑。
一句话总结 Map 是 Java 里“键→值”映射的通用容器；注解在运行时被 JVM 用 Map 来保存其属性，因此二者在底层确实是一家人。
一、🎯 目标： 我们想做一个“用户信息校验”功能，比如：
用户名不能超过10个字符 年龄必须在18到60之间 邮箱必须包含 @ 符号 但我们不想把规则写死在代码里，而是用注解来定义规则，然后程序运行时通过Map来存储这些规则，进行动态校验。
...</p></div><footer class=entry-footer><span title='2025-11-21 10:50:00 +0800 +0800'>November 21, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 注解和Map(新手理解)" href=http://ljj1992.fun/posts/%E6%B3%A8%E8%A7%A3%E5%92%8Cmap/></a></article><article class=post-entry><header class=entry-header><h2>观察者模式(YouTuber订阅)</h2></header><div class=entry-content><p>观察者模式(YouTuber订阅) 一、观察者模式到底是干嘛的？为什么会有人发明它？ 想象一下现实生活中的场景：
你很喜欢某个YouTuber（比如“老王”），于是你点了一下“订阅”按钮。 以后老王每发一个新视频，YouTube 就会自动给你推送通知，你不用每时每刻去他的主页刷新看他发没发视频。
这里的关键问题就是：
“一个对象（YouTuber）的状态变了，怎么让一大堆关心它的对象（粉丝）立刻知道，并且各自做出反应？”
如果没有观察者模式，我们会怎么做？最笨的办法：
老王每次发视频后，自己记住所有粉丝的电话，一个一个打电话通知； 或者每个粉丝自己写一个死循环，每隔10秒去老王的主页看一遍有没有新视频（浪费资源，还不及时）。 这两种方式都很蠢，观察者模式就是为了优雅地解决这个问题而诞生的。
观察者模式解决的核心痛点： 解耦：主题（YouTuber）不需要知道粉丝具体是谁、怎么通知，只需要知道“我有一堆订阅者，出事了就告诉他们”。 一对多依赖：一个主题可以有 0个、1个、10000个观察者，增删都非常方便。 动态订阅/退订：粉丝可以随时订阅、随时取关，主题完全不关心。 松耦合：主题和观察者只通过一个约定的接口（update方法）沟通，互不依赖具体实现。 一句话总结： 当一个对象的状态改变需要通知给其他众多对象，并且这些对象可能随时增删时，就用观察者模式。
二、经典使用场景（你以后一定会遇到） 聊天软件：有人发消息，所有在线好友收到通知 股票软件：股价变动，所有关注这只股票的人收到推送 GUI界面：点击按钮，所有注册了点击事件的监听器执行 消息队列、事件总线（EventBus） Vue/React 中的数据响应式（本质也是观察者） Python 中的信号槽（PyQt/PySide）、Java 中的 Listener 三、用大白话理解观察者模式的四个核心角色 角色 现实中对应 代码中对应 职责 Subject（主题） YouTuber Youtuber 类 维护订阅者列表，提供 attach/detach/notify 方法 Observer（观察者接口） “订阅后必须能收到通知”这个约定 Observer 抽象类 定义 update 方法 ConcreteObserver（具体观察者） 具体的粉丝小明、小红 Fan 类 实现 update，真正干活的地方 Client（客户代码） 我们写的主程序 最后的运行逻辑 创建对象、订阅、触发通知 四、代码分析 # ------------------------------------------------- # 步骤1：定义“主题”（Youtuber） # ------------------------------------------------- class Youtuber: # 定义一个类，名叫 Youtuber，代表“被订阅的对象” def __init__(self, name): # 构造函数，创建对象时自动执行 self.name = name # 给这个YouTuber起个名字，比如“老王” self._observers = [] # 核心：一个“订阅者列表”，_ 开头通常表示内部使用，不建议外部直接访问 # [] 表示创建一个空列表，用来装所有粉丝对象 def attach(self, observer): # “订阅”方法，参数 observer 就是一个粉丝对象 """添加一个观察者（订阅）""" if observer not in self._observers: # 判断这个粉丝是否已经订阅过，防止重复 self._observers.append(observer) # append 是列表的内置方法，把粉丝对象加到列表末尾 print(f"[{observer.name}] 订阅了 [{self.name}]") # 打印一条提示信息 def detach(self, observer): # “取消订阅”方法 """移除一个观察者（取消订阅）""" try: self._observers.remove(observer) # remove 是列表的内置方法，直接删除这个对象 print(f"[{observer.name}] 取消订阅了 [{self.name}]") except ValueError: # 如果列表里根本没有这个对象，remove 会报错 pass # 我们选择忽略这个错误，什么都不做 def notify(self, video_title): # 最最重要的“发布视频”方法，也就是状态发生变化 """通知所有观察者""" print(f"\n[{self.name}] 发布了新视频: {video_title}！正在通知所有订阅者...") for observer in self._observers: # 遍历当前所有的粉丝对象 observer.update(self.name, video_title) # **核心中的核心！** # 调用每个粉丝的 update 方法，把视频信息告诉他 # ------------------------------------------------- # 步骤2：定义“观察者”模板和具体观察者（粉丝） # ------------------------------------------------- from abc import ABC, abstractmethod # 从 abc 模块导入工具，用来创建抽象类 class Observer(ABC): # 定义一个抽象基类（模板），所有观察者都必须遵守 @abstractmethod # 装饰器：表示下面的方法是“抽象方法”，子类必须实现 def update(self, youtuber_name, video_title): # 抽象方法，只定义签名，不写具体内容 pass # pass 表示“占个位置，啥也不干” class Fan(Observer): # Fan 类继承 Observer，代表具体的粉丝 def __init__(self, name): self.name = name # 每个粉丝也有自己的名字 def update(self, youtuber_name, video_title): # 必须实现父类的抽象方法，否则会报错 """当收到通知时，粉丝的反应""" print(f" -> 粉丝 [{self.name}] 收到了！正在打开 App 查看 [{youtuber_name}] 的 [{video_title}]") # 这里就是粉丝真正的反应逻辑，你可以改成发邮件、弹窗、播放声音等等 # ------------------------------------------------- # 步骤3：运行逻辑（真正看到效果的地方） # ------------------------------------------------- # 1. 创建主题和观察者 youtuber_A = Youtuber("老王") # 创建一个YouTuber，名字叫“老王” fan_1 = Fan("小明") # 创建三个粉丝对象 fan_2 = Fan("小红") fan_3 = Fan("小刚") # 2. 观察者“订阅”主题 youtuber_A.attach(fan_1) # 小明和小红先订阅 youtuber_A.attach(fan_2) # 3. 主题发布新内容（状态变更） youtuber_A.notify("观察者模式入门") # 老王发第一条视频，只有小明和小红收到 # 4. 另一个粉丝也订阅了 youtuber_A.attach(fan_3) # 小刚中途订阅 # 5. 小红取消订阅 youtuber_A.detach(fan_2) # 小红取关 # 6. 主题再次发布新内容 youtuber_A.notify("工厂模式yyds") # 老王再发一条视频，只有小明和小刚收到 运行后你会看到输出：
...</p></div><footer class=entry-footer><span title='2025-11-20 15:36:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 观察者模式(YouTuber订阅)" href=http://ljj1992.fun/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/></a></article><article class=post-entry><header class=entry-header><h2>策略模式</h2></header><div class=entry-content><p>策略模式 🌟 什么是策略模式？ 一句话解释：
策略模式就是“把不同的做法（算法）封装成独立的类，让它们可以互相替换，而不影响主程序”。
就像你出门：
可以走路 可以骑车 可以开车 可以坐地铁 这些是不同的“策略”，你根据情况选择一种。程序里也一样，我们可以把每种“方式”封装起来，随时切换。
✅ 场景举例：不同支付方式（微信、支付宝、银行卡）
我们写一个简单的购物程序，支持多种支付方式，使用策略模式来实现。
💡 第一步：定义一个“支付策略”接口 // 定义一个统一的“支付方式”接口 // 所有具体的支付方式（如微信、支付宝）都要实现这个接口 public interface PaymentStrategy { // 这个方法表示“执行支付”，具体怎么付由子类决定 void pay(double amount); } 🔍 解释：
interface 是 Java 中的“接口”，规定了一组行为（方法）。 这里说：任何支付方式都必须有 pay(double amount) 方法。 但不关心它内部怎么实现，只关心“能付钱”。 💡 第二步：实现具体的支付策略 1. 微信支付策略 // 微信支付的具体实现类 public class WeChatPayment implements PaymentStrategy { // 实现 pay 方法：用微信支付 @Override public void pay(double amount) { System.out.println("✅ 使用微信支付：金额 " + amount + " 元"); System.out.println("📱 扫码成功，正在扣款..."); System.out.println("🔔 微信提示：支付成功！"); } } 🔍 解释：
...</p></div><footer class=entry-footer><span title='2025-11-20 15:30:00 +0800 +0800'>November 20, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></footer><a class=entry-link aria-label="post link to 策略模式" href=http://ljj1992.fun/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/></a></article></div><nav class=pagination><a class=next href=/posts/page/2/>Next »</a></nav></main><footer class=footer><span>&copy; 2026 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>