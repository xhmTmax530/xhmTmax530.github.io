<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>智能分流网关分流部署方案(ipset、wireguard、dnsmasq) | star徐的博客</title><meta name=keywords content="网络,WireGuard,ipset,DNS"><meta name=description content="方案概览

核心技术: WireGuard, Dnsmasq, Iptables, IPset, 策略路由
核心策略: 白名单直连，默认代理。
流量路径:

DNS查询:

国内域名 (匹配dnsmasq-china-list): 通过国内DNS (119.29.29.29等) 直接解析，并将结果IP自动加入directlist IP白名单集合。
被墙域名 & 未知域名: 统一通过WireGuard隧道向上游DNS (8.8.8.8) 查询。被墙域名的结果IP会自动加入gfwlist IP集合。


数据传输:

国内IP (匹配directlist IP白名单): 直接连接（走本地出口）。
所有其他IP (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。




核心特性:

DNS查询保护: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。
默认代理: 任何未明确指定为“直连”的流量，都将默认通过隧道，提供更强的隐私保护。
Kill Switch: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。
全自动化: 定时脚本自动更新国内外域名与IP列表，无需人工干预。




第一部分：VPS (服务器端) 配置
VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。
1. 系统准备与软件安装
# 更新系统软件包列表并升级已安装的软件
sudo apt update && sudo apt upgrade -y

# 安装WireGuard
sudo apt install wireguard -y
2. 启用IP转发
# 编辑sysctl配置文件
sudo nano /etc/sysctl.conf
确保文件中包含以下行（去掉前面的#号）："><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88-%E7%99%BD%E5%90%8D%E5%8D%95%E7%9B%B4%E8%BF%9E%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%90%86/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88-%E7%99%BD%E5%90%8D%E5%8D%95%E7%9B%B4%E8%BF%9E%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%90%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88-%E7%99%BD%E5%90%8D%E5%8D%95%E7%9B%B4%E8%BF%9E%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%90%86/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="智能分流网关分流部署方案(ipset、wireguard、dnsmasq)"><meta property="og:description" content="方案概览 核心技术: WireGuard, Dnsmasq, Iptables, IPset, 策略路由 核心策略: 白名单直连，默认代理。 流量路径: DNS查询: 国内域名 (匹配dnsmasq-china-list): 通过国内DNS (119.29.29.29等) 直接解析，并将结果IP自动加入directlist IP白名单集合。 被墙域名 & 未知域名: 统一通过WireGuard隧道向上游DNS (8.8.8.8) 查询。被墙域名的结果IP会自动加入gfwlist IP集合。 数据传输: 国内IP (匹配directlist IP白名单): 直接连接（走本地出口）。 所有其他IP (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。 核心特性: DNS查询保护: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。 默认代理: 任何未明确指定为“直连”的流量，都将默认通过隧道，提供更强的隐私保护。 Kill Switch: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。 全自动化: 定时脚本自动更新国内外域名与IP列表，无需人工干预。 第一部分：VPS (服务器端) 配置 VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。
1. 系统准备与软件安装 # 更新系统软件包列表并升级已安装的软件 sudo apt update && sudo apt upgrade -y # 安装WireGuard sudo apt install wireguard -y 2. 启用IP转发 # 编辑sysctl配置文件 sudo nano /etc/sysctl.conf 确保文件中包含以下行（去掉前面的#号）："><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-13T18:00:00+08:00"><meta property="article:modified_time" content="2025-11-13T18:00:00+08:00"><meta property="article:tag" content="网络"><meta property="article:tag" content="WireGuard"><meta property="article:tag" content="Ipset"><meta property="article:tag" content="DNS"><meta name=twitter:card content="summary"><meta name=twitter:title content="智能分流网关分流部署方案(ipset、wireguard、dnsmasq)"><meta name=twitter:description content="方案概览

核心技术: WireGuard, Dnsmasq, Iptables, IPset, 策略路由
核心策略: 白名单直连，默认代理。
流量路径:

DNS查询:

国内域名 (匹配dnsmasq-china-list): 通过国内DNS (119.29.29.29等) 直接解析，并将结果IP自动加入directlist IP白名单集合。
被墙域名 & 未知域名: 统一通过WireGuard隧道向上游DNS (8.8.8.8) 查询。被墙域名的结果IP会自动加入gfwlist IP集合。


数据传输:

国内IP (匹配directlist IP白名单): 直接连接（走本地出口）。
所有其他IP (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。




核心特性:

DNS查询保护: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。
默认代理: 任何未明确指定为“直连”的流量，都将默认通过隧道，提供更强的隐私保护。
Kill Switch: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。
全自动化: 定时脚本自动更新国内外域名与IP列表，无需人工干预。




第一部分：VPS (服务器端) 配置
VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。
1. 系统准备与软件安装
# 更新系统软件包列表并升级已安装的软件
sudo apt update && sudo apt upgrade -y

# 安装WireGuard
sudo apt install wireguard -y
2. 启用IP转发
# 编辑sysctl配置文件
sudo nano /etc/sysctl.conf
确保文件中包含以下行（去掉前面的#号）："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"智能分流网关分流部署方案(ipset、wireguard、dnsmasq)","item":"http://ljj1992.fun/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88-%E7%99%BD%E5%90%8D%E5%8D%95%E7%9B%B4%E8%BF%9E%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"智能分流网关分流部署方案(ipset、wireguard、dnsmasq)","name":"智能分流网关分流部署方案(ipset、wireguard、dnsmasq)","description":"方案概览 核心技术: WireGuard, Dnsmasq, Iptables, IPset, 策略路由 核心策略: 白名单直连，默认代理。 流量路径: DNS查询: 国内域名 (匹配dnsmasq-china-list): 通过国内DNS (119.29.29.29等) 直接解析，并将结果IP自动加入directlist IP白名单集合。 被墙域名 \u0026amp; 未知域名: 统一通过WireGuard隧道向上游DNS (8.8.8.8) 查询。被墙域名的结果IP会自动加入gfwlist IP集合。 数据传输: 国内IP (匹配directlist IP白名单): 直接连接（走本地出口）。 所有其他IP (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。 核心特性: DNS查询保护: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。 默认代理: 任何未明确指定为“直连”的流量，都将默认通过隧道，提供更强的隐私保护。 Kill Switch: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。 全自动化: 定时脚本自动更新国内外域名与IP列表，无需人工干预。 第一部分：VPS (服务器端) 配置 VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。\n1. 系统准备与软件安装 # 更新系统软件包列表并升级已安装的软件 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # 安装WireGuard sudo apt install wireguard -y 2. 启用IP转发 # 编辑sysctl配置文件 sudo nano /etc/sysctl.conf 确保文件中包含以下行（去掉前面的#号）：\n","keywords":["网络","WireGuard","ipset","DNS"],"articleBody":"方案概览 核心技术: WireGuard, Dnsmasq, Iptables, IPset, 策略路由 核心策略: 白名单直连，默认代理。 流量路径: DNS查询: 国内域名 (匹配dnsmasq-china-list): 通过国内DNS (119.29.29.29等) 直接解析，并将结果IP自动加入directlist IP白名单集合。 被墙域名 \u0026 未知域名: 统一通过WireGuard隧道向上游DNS (8.8.8.8) 查询。被墙域名的结果IP会自动加入gfwlist IP集合。 数据传输: 国内IP (匹配directlist IP白名单): 直接连接（走本地出口）。 所有其他IP (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。 核心特性: DNS查询保护: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。 默认代理: 任何未明确指定为“直连”的流量，都将默认通过隧道，提供更强的隐私保护。 Kill Switch: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。 全自动化: 定时脚本自动更新国内外域名与IP列表，无需人工干预。 第一部分：VPS (服务器端) 配置 VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。\n1. 系统准备与软件安装 # 更新系统软件包列表并升级已安装的软件 sudo apt update \u0026\u0026 sudo apt upgrade -y # 安装WireGuard sudo apt install wireguard -y 2. 启用IP转发 # 编辑sysctl配置文件 sudo nano /etc/sysctl.conf 确保文件中包含以下行（去掉前面的#号）：\n# 启用IPv4数据包转发 net.ipv4.ip_forward=1 保存文件后，执行命令使其立即生效：\n# 从/etc/sysctl.conf加载内核参数 sudo sysctl -p 3. 生成WireGuard密钥 # 一步完成生成私钥、保存、计算公钥、保存 wg genkey | tee vps_privatekey | wg pubkey \u003e vps_publickey 提示: 请记下 vps_privatekey 和 vps_publickey 文件的内容。\n4. 配置WireGuard (/etc/wireguard/wg0.conf) # 创建并编辑配置文件 sudo nano /etc/wireguard/wg0.conf ```填入以下内容： ```ini [Interface] # 本服务器在隧道中的IPv4地址 Address = 10.0.0.1/24 SaveConfig = true # WireGuard监听的UDP端口 ListenPort = 51820 # 填入您上一步生成的VPS私钥 PrivateKey = \u003c在此粘贴vps_privatekey的内容\u003e [Peer] # 稍后填入国内网关的公钥 PublicKey = \u003c稍后填入国内网关的公钥\u003e # 分配给国内网关的隧道IP地址 AllowedIPs = 10.0.0.2/32 5. 配置防火墙NAT规则 注意: 如果你的公网网卡不是 eth0，请用 ip a 命令查看并替换。这一步是必需的，它负责将从隧道过来的、源地址为私网IP（10.0.0.2）的数据包，在发送到公网前，将其源地址“伪装”成VPS自己的公网IP，从而让目标服务器知道将响应数据发回给谁。\n# 允许所有来自wg0接口的数据包被转发 sudo iptables -A FORWARD -i wg0 -j ACCEPT # 将所有从公网网卡出去的包，其源地址伪装成公网地址 sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 6. 启动WireGuard服务 # 启动名为wg0的WireGuard接口 sudo wg-quick up wg0 # 设置WireGuard服务开机自启 sudo systemctl enable wg-quick@wg0 第二部分：国内Linux网关 (客户端) 配置 这是整个系统的核心，所有智能分流逻辑都在此实现。\n1. 系统准备与软件安装 # 更新并升级 sudo apt update \u0026\u0026 sudo apt upgrade -y # 安装所有必需的软件 sudo apt install wireguard dnsmasq ipset git curl -y 2. 生成WireGuard密钥 wg genkey | tee domestic_privatekey | wg pubkey \u003e domestic_publickey``` \u003e **重要**: 将 `domestic_publickey` 文件的内容，填入您VPS上 `wg0.conf` 文件里 `[Peer]` 部分的 `PublicKey` 字段。然后在VPS上重启WireGuard (`sudo wg-quick down wg0 \u0026\u0026 sudo wg-quick up wg0`)。 ### 3. 配置Dnsmasq * **主配置文件 (`/etc/dnsmasq.conf`)**: ```bash sudo nano /etc/dnsmasq.conf 清空并填入以下内容 (将`192.168.1.1`替换为您的网关实际IP): ```ini resolv-file=/etc/resolv.dnsmasq.conf strict-order listen-address=127.0.0.1,192.168.1.1 bind-interfaces conf-dir=/etc/dnsmasq.d,*.conf cache-size=10000 no-poll no-hosts ``` 上游DNS服务器文件 (/etc/resolv.dnsmasq.conf): sudo nano /etc/resolv.dnsmasq.conf 填入（这是未匹配到任何规则时，默认使用的DNS）： nameserver 8.8.8.8 4. 创建自动化与路由脚本 您需要手动创建以下三个脚本。\n脚本1: 更新规则库 (/usr/local/bin/update-lists.sh) sudo nano /usr/local/bin/update-lists.sh 粘贴以下内容（已包含详细注释）： #!/bin/bash # 脚本的开头，声明使用bash解释器来执行。 # set -e 是一个安全设置。它告诉脚本，如果任何命令执行后返回非零的退出状态（通常表示错误）， # 整个脚本将立即停止执行。这可以防止在某个步骤失败后，脚本继续执行错误或不完整的操作。 set -e # --- 变量定义 --- # 定义一些常用的路径和文件名，方便后续引用和修改。 # gfwlist2dnsmasq 工具的存放目录 GFWLIST2DNSMASQ_DIR=\"/opt/gfwlist2dnsmasq\" # dnsmasq-china-list 项目的存放目录 CHINA_LIST_DIR=\"/opt/dnsmasq-china-list\" # Dnsmasq 加载额外配置文件的目录 DNSMASQ_CONF_DIR=\"/etc/dnsmasq.d\" # 由 gfwlist 生成的 Dnsmasq 配置文件路径 DNSMASQ_CONF_GFWLIST=\"$DNSMASQ_CONF_DIR/gfwlist.conf\" # 我们自己处理并合并后的国内域名 Dnsmasq 配置文件路径 DNSMASQ_CONF_CHINA_LIST_MERGED=\"$DNSMASQ_CONF_DIR/china-list.conf\" # 定义需要处理的国内域名列表源文件名数组 CHINA_LIST_SOURCE_FILES=( \"accelerated-domains.china.conf\" \"apple.china.conf\" \"google.china.conf\" ) echo \"--\u003e 1/4: Updating gfwlist rules...\" # 检查 gfwlist2dnsmasq 工具目录是否存在。 if [ ! -d \"$GFWLIST2DNSMASQ_DIR\" ]; then # 如果目录不存在 (! -d)，说明是第一次运行，就从 GitHub 克隆 (clone) 整个项目到指定目录。 git clone https://github.com/cokebar/gfwlist2dnsmasq.git \"$GFWLIST2DNSMASQ_DIR\" fi # 使用 cd 命令进入该工具的目录，并用 git pull 拉取最新的更新。 cd \"$GFWLIST2DNSMASQ_DIR\" \u0026\u0026 git pull # 执行 gfwlist2dnsmasq.sh 脚本，生成 Dnsmasq 配置文件。 # -d 8.8.8.8: 指定解析这些域名时使用的DNS服务器。 # -s gfwlist: 指定解析出的IP要加入名为 \"gfwlist\" 的 ipset 集合。 # -o \"...\": 指定输出配置文件的路径。 ./gfwlist2dnsmasq.sh -d 8.8.8.8 -s gfwlist -o \"$DNSMASQ_CONF_GFWLIST\" echo \"--\u003e 2/4: Updating and processing domestic domain lists...\" # 检查 dnsmasq-china-list 的本地仓库目录是否存在。 if [ ! -d \"$CHINA_LIST_DIR\" ]; then # 如果不存在，就从 GitHub 克隆项目。 git clone https://github.com/felixonmars/dnsmasq-china-list.git \"$CHINA_LIST_DIR\" fi # 进入该目录并拉取最新更新。 cd \"$CHINA_LIST_DIR\" \u0026\u0026 git pull # --- 自动化处理核心 --- # 使用 \u003e 操作符，清空或创建我们即将写入的合并配置文件。这可以确保每次运行时都是一个全新的文件。 \u003e \"$DNSMASQ_CONF_CHINA_LIST_MERGED\" echo \"Processing china-list files to add ipset directive...\" # 使用 for 循环，遍历上面定义的国内域名列表源文件名数组。 for file in \"${CHINA_LIST_SOURCE_FILES[@]}\"; do # sed 是一个强大的文本处理工具。这行命令是整个自动化方案的关键之一。 # 's|...|...|': s 代表替换 (substitute)。我们用 | 作为分隔符，避免与路径中的 / 冲突。 # 's|/\\([^/]*\\)$|/\\1\\nipset=/\\1/directlist|': # - `/\\([^/]*\\)$`: 这是要查找的模式。它匹配以 \"/\" 开头，后面跟着一串不包含 \"/\" 的字符，直到行尾。 # 例如，它会匹配 'server=/qq.com/119.29.29.29' 中的 '/qq.com'。 # `\\(` 和 `\\)` 用于创建一个“捕获组”，把匹配到的域名（如 'qq.com'）存起来。 # - `/\\1\\nipset=/\\1/directlist`: 这是替换后的内容。 # `\\1` 代表第一个捕获组的内容（即域名）。 # `\\n` 代表换行符。 # 所以，这整段的意思是：在原始行（如 'server=/qq.com/...'）的后面，换一行，并插入 'ipset=/qq.com/directlist'。 # `\"${CHINA_LIST_DIR}/${file}\"`: 这是 sed 命令要处理的输入文件。 # `\u003e\u003e \"$DNSMASQ_CONF_CHINA_LIST_MERGED\"`: `\u003e\u003e` 是追加重定向，将 sed 处理后的结果追加到我们合并的配置文件中。 sed 's|/\\([^/]*\\)$|/\\1\\nipset=/\\1/directlist|' \"${CHINA_LIST_DIR}/${file}\" \u003e\u003e \"$DNSMASQ_CONF_CHINA_LIST_MERGED\" done echo \"--\u003e 3/4: Cleaning up old china-list files...\" # 为了避免 Dnsmasq 加载我们处理前的原始文件，造成规则冲突或重复，这里将它们从配置目录中删除。 # rm -f: -f (force) 表示即使文件不存在也不报错。 for file in \"${CHINA_LIST_SOURCE_FILES[@]}\"; do rm -f \"${DNSMASQ_CONF_DIR}/${file}\" done echo \"--\u003e 4/4: Restarting Dnsmasq...\" # 所有规则都已更新并处理完毕，现在重启 Dnsmasq 服务以加载所有新的配置文件。 sudo systemctl restart dnsmasq echo \"Update process finished.\" 脚本1: 更新规则库 (/usr/local/bin/update-lists.sh)\nsudo nano /usr/local/bin/update-lists.sh 粘贴以下内容（已包含详细注释）：\n#!/bin/bash # 脚本的开头，声明使用bash解释器来执行。 # set -e 是一个安全设置。它告诉脚本，如果任何命令执行后返回非零的退出状态（通常表示错误）， # 整个脚本将立即停止执行。这可以防止在某个步骤失败后，脚本继续执行错误或不完整的操作。 set -e # --- 变量定义 --- # 定义一些常用的路径和文件名，方便后续引用和修改。 # gfwlist2dnsmasq 工具的存放目录 GFWLIST2DNSMASQ_DIR=\"/opt/gfwlist2dnsmasq\" # dnsmasq-china-list 项目的存放目录 CHINA_LIST_DIR=\"/opt/dnsmasq-china-list\" # Dnsmasq 加载额外配置文件的目录 DNSMASQ_CONF_DIR=\"/etc/dnsmasq.d\" # 由 gfwlist 生成的 Dnsmasq 配置文件路径 DNSMASQ_CONF_GFWLIST=\"$DNSMASQ_CONF_DIR/gfwlist.conf\" # 我们自己处理并合并后的国内域名 Dnsmasq 配置文件路径 DNSMASQ_CONF_CHINA_LIST_MERGED=\"$DNSMASQ_CONF_DIR/china-list.conf\" # 定义需要处理的国内域名列表源文件名数组 CHINA_LIST_SOURCE_FILES=( \"accelerated-domains.china.conf\" \"apple.china.conf\" \"google.china.conf\" ) echo \"--\u003e 1/4: Updating gfwlist rules...\" # 检查 gfwlist2dnsmasq 工具目录是否存在。 if [ ! -d \"$GFWLIST2DNSMASQ_DIR\" ]; then # 如果目录不存在 (! -d)，说明是第一次运行，就从 GitHub 克隆 (clone) 整个项目到指定目录。 git clone https://github.com/cokebar/gfwlist2dnsmasq.git \"$GFWLIST2DNSMASQ_DIR\" fi # 使用 cd 命令进入该工具的目录，并用 git pull 拉取最新的更新。 cd \"$GFWLIST2DNSMASQ_DIR\" \u0026\u0026 git pull # 执行 gfwlist2dnsmasq.sh 脚本，生成 Dnsmasq 配置文件。 # -d 8.8.8.8: 指定解析这些域名时使用的DNS服务器。 # -s gfwlist: 指定解析出的IP要加入名为 \"gfwlist\" 的 ipset 集合。 # -o \"...\": 指定输出配置文件的路径。 ./gfwlist2dnsmasq.sh -d 8.8.8.8 -s gfwlist -o \"$DNSMASQ_CONF_GFWLIST\" echo \"--\u003e 2/4: Updating and processing domestic domain lists...\" # 检查 dnsmasq-china-list 的本地仓库目录是否存在。 if [ ! -d \"$CHINA_LIST_DIR\" ]; then # 如果不存在，就从 GitHub 克隆项目。 git clone https://github.com/felixonmars/dnsmasq-china-list.git \"$CHINA_LIST_DIR\" fi # 进入该目录并拉取最新更新。 cd \"$CHINA_LIST_DIR\" \u0026\u0026 git pull # --- 自动化处理核心 --- # 使用 \u003e 操作符，清空或创建我们即将写入的合并配置文件。这可以确保每次运行时都是一个全新的文件。 \u003e \"$DNSMASQ_CONF_CHINA_LIST_MERGED\" echo \"Processing china-list files to add ipset directive...\" # 使用 for 循环，遍历上面定义的国内域名列表源文件名数组。 for file in \"${CHINA_LIST_SOURCE_FILES[@]}\"; do # sed 是一个强大的文本处理工具。这行命令是整个自动化方案的关键之一。 # 's|...|...|': s 代表替换 (substitute)。我们用 | 作为分隔符，避免与路径中的 / 冲突。 # 's|/\\([^/]*\\)$|/\\1\\nipset=/\\1/directlist|': # - `/\\([^/]*\\)$`: 这是要查找的模式。它匹配以 \"/\" 开头，后面跟着一串不包含 \"/\" 的字符，直到行尾。 # 例如，它会匹配 'server=/qq.com/119.29.29.29' 中的 '/qq.com'。 # `\\(` 和 `\\)` 用于创建一个“捕获组”，把匹配到的域名（如 'qq.com'）存起来。 # - `/\\1\\nipset=/\\1/directlist`: 这是替换后的内容。 # `\\1` 代表第一个捕获组的内容（即域名）。 # `\\n` 代表换行符。 # 所以，这整段的意思是：在原始行（如 'server=/qq.com/...'）的后面，换一行，并插入 'ipset=/\\1/directlist'。 # `\"${CHINA_LIST_DIR}/${file}\"`: 这是 sed 命令要处理的输入文件。 # `\u003e\u003e \"$DNSMASQ_CONF_CHINA_LIST_MERGED\"`: `\u003e\u003e` 是追加重定向，将 sed 处理后的结果追加到我们合并的配置文件中。 sed 's|/\\([^/]*\\)$|/\\1\\nipset=/\\1/directlist|' \"${CHINA_LIST_DIR}/${file}\" \u003e\u003e \"$DNSMASQ_CONF_CHINA_LIST_MERGED\" done echo \"--\u003e 3/4: Cleaning up old china-list files...\" # 为了避免 Dnsmasq 加载我们处理前的原始文件，造成规则冲突或重复，这里将它们从配置目录中删除。 # rm -f: -f (force) 表示即使文件不存在也不报错。 for file in \"${CHINA_LIST_SOURCE_FILES[@]}\"; do rm -f \"${DNSMASQ_CONF_DIR}/${file}\" done echo \"--\u003e 4/4: Restarting Dnsmasq...\" # 所有规则都已更新并处理完毕，现在重启 Dnsmasq 服务以加载所有新的配置文件。 sudo systemctl restart dnsmasq echo \"Update process finished.\" 脚本2: 应用防火墙和路由规则 (/usr/local/bin/apply-routing-rules.sh)\nsudo nano /usr/local/bin/apply-routing-rules.sh ``` 粘贴以下内容： ```bash #!/bin/bash set -e # --- 变量定义 --- # FW_MARK: 防火墙标记，用于策略路由。可以任意，但通常用WireGuard端口号便于识别。 FW_MARK=\"51820\" # TABLE_ID: 自定义路由表的ID。避免与系统已使用的表冲突，100是一个安全的选择。 TABLE_ID=\"100\" # FOREIGN_DNS: 我们指定的国外/上游DNS服务器，用于DNS防泄漏。 FOREIGN_DNS=\"8.8.8.8\" echo \"--\u003e 1/3: Initializing ipsets...\" # --- 初始化IP集合 --- # 销毁并创建 gfwlist 和新的 directlist 集合，确保每次应用都是干净的状态。 # 2\u003e/dev/null: 将可能出现的“集合不存在”的错误信息重定向到“黑洞”，避免在首次运行时报错。 # || true: 即使ipset destroy命令失败（比如集合不存在），也确保脚本继续执行。 # timeout 86400: 设置ipset中条目的默认超时时间为一天(86400秒)，之后会自动过期。 ipset destroy gfwlist 2\u003e/dev/null || true; ipset create gfwlist hash:ip,family inet,timeout 86400 ipset destroy directlist 2\u003e/dev/null || true; ipset create directlist hash:ip,family inet,timeout 86400 # --- 流量标记 (Mangle Table) --- # [策略反转] # 规则1: 优先标记本机发往国外DNS的查询请求，确保DNS解析本身走隧道，防止被窥探。 # -p udp --dport 53: 匹配协议为udp、目标端口为53（DNS）的数据包。 # -d $FOREIGN_DNS: 匹配目标地址是8.8.8.8的数据包。 # -j MARK --set-mark $FW_MARK: 对匹配的数据包打上标记。 iptables -t mangle -A OUTPUT -p udp --dport 53 -d $FOREIGN_DNS -j MARK --set-mark $FW_MARK # 规则2: 白名单规则。如果流量的目标IP在直连白名单(directlist)中，则直接返回(RETURN)， # 不进行后续任何标记。这意味着它将走系统默认路由（即本地网络出口）。 # -m set --match-set directlist dst: 匹配目标IP(dst)在名为directlist的集合中的数据包。 iptables -t mangle -A PREROUTING -m set --match-set directlist dst -j RETURN iptables -t mangle -A OUTPUT -m set --match-set directlist dst -j RETURN # 规则3: 默认标记规则。对于所有不满足上一条白名单规则的流量，全部无条件打上标记。 # 这包括了gfwlist的流量和所有未知的互联网流量。 iptables -t mangle -A PREROUTING -j MARK --set-mark $FW_MARK iptables -t mangle -A OUTPUT -j MARK --set-mark $FW_MARK # --- Kill Switch (Filter Table) --- # 在OUTPUT链顶部插入规则：如果数据包有标记但出口不是wg0，则丢弃(DROP)。 # 这是防止VPN断开时，被标记的流量从本地出口泄露真实IP。 # -I OUTPUT 1: 在OUTPUT链的第1个位置插入此规则，确保最先被匹配。 # -m mark --mark $FW_MARK: 匹配带有我们设置的标记的数据包。 # ! -o wg0: 匹配出口网卡 *不是* wg0 的数据包。 # -j DROP: 丢弃数据包。 iptables -I OUTPUT 1 -m mark --mark $FW_MARK ! -o wg0 -j DROP # --- 策略路由 --- # 删除可能存在的旧规则，然后添加新规则：所有带标记的包，去查询ID为100的路由表。 ip rule del fwmark $FW_MARK table $TABLE_ID 2\u003e/dev/null || true ip rule add fwmark $FW_MARK table $TABLE_ID # 在路由表100中，设置默认路由为通过wg0接口发出。 ip route add default dev wg0 table $TABLE_ID # 刷新路由缓存使规则立即生效。 ip route flush cache echo \"--\u003e 3/3: Routing rules applied.\" 脚本3: 清理所有规则 (/usr/local/bin/cleanup-routing-rules.sh)\nsudo nano /usr/local/bin/cleanup-routing-rules.sh 粘贴以下内容：\n#!/bin/bash set -e # --- 变量定义 --- FW_MARK=\"51820\" TABLE_ID=\"100\" echo \"--\u003e Cleaning up all firewall and routing rules...\" # --- 清理iptables规则 --- # 清空 Mangle 表和 Filter 表中我们可能添加过规则的链 iptables -t mangle -F PREROUTING; iptables -t mangle -F OUTPUT; iptables -t filter -F OUTPUT # --- 清理策略路由 --- # 删除之前添加的策略路由规则 ip rule del fwmark $FW_MARK table $TABLE_ID 2\u003e/dev/null || true # --- 清理ipset集合 --- # 销毁 ipset 集合，释放内存 ipset destroy gfwlist 2\u003e/dev/null || true ipset destroy directlist 2\u003e/dev/null || true echo \"Cleanup complete.\" ; \u003c\u003c\u003e\u003e DiG 9.16.1-Ubuntu \u003c\u003c\u003e\u003e www.baidu.com @192.168.1.1 ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 54010 ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 65494 ;; QUESTION SECTION: ;www.baidu.com. IN A ;; ANSWER SECTION: www.baidu.com. 600 IN CNAME www.a.shifen.com. www.a.shifen.com. 60 IN A 110.242.68.3 www.a.shifen.com. 60 IN A 110.242.68.4 ;; Query time: 15 msec ;; SERVER: 192.168.1.1#53(192.168.1.1) \u003c-- 关键看这里！ ;; WHEN: Thu Oct 23 11:30:00 UTC 2025 ;; MSG SIZE rcvd: 107 ``` 查询时间 (`Query time`) 通常会很短（例如 \u003c 50ms）。 * **测试国外域名**: 同样，在局域网客户端上执行： ```bash dig www.google.com @192.168.1.1 ``` **预期结果**: `SERVER` 行依然显示的是你**网关的IP地址**。这表明请求被网关Dnsmasq接收，然后Dnsmasq根据规则（未匹配国内域名列表），将查询转发给了默认的上游DNS `8.8.8.8`。由于这个转发过程是通过WireGuard隧道的，所以查询时间 (`Query time`) 可能会比国内域名稍长一些。 ``` ; \u003c\u003c\u003e\u003e DiG 9.16.1-Ubuntu \u003c\u003c\u003e\u003e www.google.com @192.168.1.1 ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 37123 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 65494 ;; QUESTION SECTION: ;www.google.com. IN A ;; ANSWER SECTION: www.google.com. 242 IN A 142.250.199.100 ;; Query time: 120 msec \u003c-- 时间可能因隧道延迟而变长 ;; SERVER: 192.168.1.1#53(192.168.1.1) \u003c-- 关键看这里！ ;; WHEN: Thu Oct 23 11:32:15 UTC 2025 ;; MSG SIZE rcvd: 59 ``` 通过这两个 `dig` 测试，你可以百分之百确认Dnsmasq的分流策略已经按预期工作。 文档结束\n检查与改进建议 一、 技术方案审查 (Technical Review) 总体评价：方案设计非常出色，技术实现合理且正确。\n这是一个工业级的个人网关部署方案，逻辑环环相扣，考虑了自动化和安全性。我对方案中的命令和配置逐一进行了检查，结论如下：\nVPS端配置：完全正确。net.ipv4.ip_forward=1 开启了路由功能，iptables 的 MASQUERADE 规则是实现NAT转换的标准做法，配置无误。 网关端Dnsmasq配置：配置合理。通过 conf-dir 加载分流规则，通过 resolv-file 指定默认上游DNS，这是实现DNS分流的标准实践。 核心脚本 update-lists.sh：逻辑严谨，实现巧妙。 git clone/pull 的逻辑可以确保规则库始终是最新版本。 核心命令 sed 's|/\\([^/]*\\)$|/\\1\\nipset=/\\1/directlist|' 是整个自动化方案的精髓。它没有修改原始规则文件，而是在内存中处理每一行，动态地为每个国内域名规则追加一条 ipset 指令。这使得Dnsmasq在解析这些域名的同时，能自动将解析出的IP地址添加到名为 directlist 的IP集合中。这个实现非常优雅且高效。 核心脚本 apply-routing-rules.sh：逻辑正确，实现了“白名单直连，默认代理”的反向策略。 IPset初始化：ipset destroy ... || true 的写法很规范，能避免脚本在首次运行时因集合不存在而报错中断。 流量标记逻辑：这是典型的“策略反转”思路。它没有去标记“需要代理”的流量，而是先匹配“需要直连”的流量（-m set --match-set directlist dst -j RETURN）让其通过，然后将所有剩下的流量（-j MARK）无条件标记。这确保了任何未知流量都会默认走代理，增强了隐私性。 Kill Switch：iptables -I OUTPUT 1 -m mark --mark $FW_MARK ! -o wg0 -j DROP 是一条非常关键和正确的安全规则。它为网关本机提供了强有力的防泄漏保障。对于局域网内的其他设备，当 wg0 接口关闭时，策略路由 ip rule 所指向的路由表 100 中的 default dev wg0 路由会失效，数据包同样无法发出，从而实现了对整个局域网的Kill Switch效果。 WireGuard客户端配置：配置正确，特别是 Table = off 的使用。 Table = off 是高级用法，它阻止了 wg-quick 工具修改系统默认的主路由表。这是本方案能正常工作的关键设置，因为它把路由控制权完全交给了我们的 PostUp 脚本和策略路由，避免了路由冲突。 通过 PostUp 和 PreDown 钩子来自动执行规则应用和清理脚本，是 wg-quick 的标准集成方式，实现了配置的自动化和原子性。 二、 总结与细微改进建议 总结\n这篇部署方案从技术角度看是一份可以被直接采纳并部署的、高质量的生产级方案。它逻辑清晰、自动化程度高、安全性强，并且正确地运用了Linux网络栈的各项高级功能（策略路由、ipset、mangle标记等）。对于想要实现精细化流量控制的用户来说，这是一个极佳的模板和学习材料。\n细微改进建议（非错误修正）\n脚本注释增强：我已经根据您的要求，在上面的原文副本中，对 apply-routing-rules.sh 和其他脚本的部分关键命令增加了更详细的注释，以便于新手理解每个参数的意义。 Crontab命令：在“设置自动化更新”部分，原命令 crontab -e 会编辑当前用户的定时任务。由于更新脚本和重启服务需要root权限，建议明确为 sudo crontab -e，以编辑root用户的定时任务。这一点我也在上面的副本中修正了。 ipset持久化（可选）：当前的ipset规则是临时的，每次重启网关或重启 wg-quick 服务时，apply-routing-rules.sh 会重建它们。这是完全可行的。但如果追求更快的启动速度，可以研究 ipset-persistent 等工具，将ipset集合保存到磁盘，并在系统启动时自动加载。不过对于本方案来说，现有机制已经足够好，这并非必要项。 ","wordCount":"1553","inLanguage":"en","datePublished":"2025-11-13T18:00:00+08:00","dateModified":"2025-11-13T18:00:00+08:00","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88-%E7%99%BD%E5%90%8D%E5%8D%95%E7%9B%B4%E8%BF%9E%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%90%86/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">智能分流网关分流部署方案(ipset、wireguard、dnsmasq)</h1><div class=post-meta><span title='2025-11-13 18:00:00 +0800 +0800'>November 13, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h2 id=方案概览>方案概览<a hidden class=anchor aria-hidden=true href=#方案概览>#</a></h2><ul><li><strong>核心技术</strong>: WireGuard, Dnsmasq, Iptables, IPset, 策略路由</li><li><strong>核心策略</strong>: <strong>白名单直连，默认代理</strong>。</li><li><strong>流量路径</strong>:<ol><li><strong>DNS查询</strong>:<ul><li><strong>国内域名</strong> (匹配<code>dnsmasq-china-list</code>): 通过国内DNS (<code>119.29.29.29</code>等) 直接解析，并将结果IP自动加入<code>directlist</code> IP白名单集合。</li><li><strong>被墙域名 & 未知域名</strong>: 统一通过WireGuard隧道向上游DNS (<code>8.8.8.8</code>) 查询。被墙域名的结果IP会自动加入<code>gfwlist</code> IP集合。</li></ul></li><li><strong>数据传输</strong>:<ul><li><strong>国内IP</strong> (匹配<code>directlist</code> IP白名单): 直接连接（走本地出口）。</li><li><strong>所有其他IP</strong> (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。</li></ul></li></ol></li><li><strong>核心特性</strong>:<ul><li><strong>DNS查询保护</strong>: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。</li><li><strong>默认代理</strong>: 任何未明确指定为“直连”的流量，都将默认通过隧道，提供更强的隐私保护。</li><li><strong>Kill Switch</strong>: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。</li><li><strong>全自动化</strong>: 定时脚本自动更新国内外域名与IP列表，无需人工干预。</li></ul></li></ul><hr><h2 id=第一部分vps-服务器端-配置>第一部分：VPS (服务器端) 配置<a hidden class=anchor aria-hidden=true href=#第一部分vps-服务器端-配置>#</a></h2><p>VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。</p><h3 id=1-系统准备与软件安装>1. 系统准备与软件安装<a hidden class=anchor aria-hidden=true href=#1-系统准备与软件安装>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 更新系统软件包列表并升级已安装的软件</span>
</span></span><span style=display:flex><span>sudo apt update <span style=color:#f92672>&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 安装WireGuard</span>
</span></span><span style=display:flex><span>sudo apt install wireguard -y
</span></span></code></pre></div><h3 id=2-启用ip转发>2. 启用IP转发<a hidden class=anchor aria-hidden=true href=#2-启用ip转发>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 编辑sysctl配置文件</span>
</span></span><span style=display:flex><span>sudo nano /etc/sysctl.conf
</span></span></code></pre></div><p>确保文件中包含以下行（去掉前面的<code>#</code>号）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e># 启用IPv4数据包转发</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>net.ipv4.ip_forward</span><span style=color:#f92672>=</span><span style=color:#e6db74>1</span>
</span></span></code></pre></div><p>保存文件后，执行命令使其立即生效：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 从/etc/sysctl.conf加载内核参数</span>
</span></span><span style=display:flex><span>sudo sysctl -p
</span></span></code></pre></div><h3 id=3-生成wireguard密钥>3. 生成WireGuard密钥<a hidden class=anchor aria-hidden=true href=#3-生成wireguard密钥>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 一步完成生成私钥、保存、计算公钥、保存</span>
</span></span><span style=display:flex><span>wg genkey | tee vps_privatekey | wg pubkey &gt; vps_publickey
</span></span></code></pre></div><blockquote><p><strong>提示</strong>: 请记下 <code>vps_privatekey</code> 和 <code>vps_publickey</code> 文件的内容。</p></blockquote><h3 id=4-配置wireguard-etcwireguardwg0conf>4. 配置WireGuard (<code>/etc/wireguard/wg0.conf</code>)<a hidden class=anchor aria-hidden=true href=#4-配置wireguard-etcwireguardwg0conf>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 创建并编辑配置文件</span>
</span></span><span style=display:flex><span>sudo nano /etc/wireguard/wg0.conf
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>填入以下内容：
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>ini
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Interface<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 本服务器在隧道中的IPv4地址</span>
</span></span><span style=display:flex><span>Address <span style=color:#f92672>=</span> 10.0.0.1/24
</span></span><span style=display:flex><span>SaveConfig <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span><span style=color:#75715e># WireGuard监听的UDP端口</span>
</span></span><span style=display:flex><span>ListenPort <span style=color:#f92672>=</span> <span style=color:#ae81ff>51820</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 填入您上一步生成的VPS私钥</span>
</span></span><span style=display:flex><span>PrivateKey <span style=color:#f92672>=</span> &lt;在此粘贴vps_privatekey的内容&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>Peer<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 稍后填入国内网关的公钥</span>
</span></span><span style=display:flex><span>PublicKey <span style=color:#f92672>=</span> &lt;稍后填入国内网关的公钥&gt;
</span></span><span style=display:flex><span><span style=color:#75715e># 分配给国内网关的隧道IP地址</span>
</span></span><span style=display:flex><span>AllowedIPs <span style=color:#f92672>=</span> 10.0.0.2/32
</span></span></code></pre></div><h3 id=5-配置防火墙nat规则>5. 配置防火墙NAT规则<a hidden class=anchor aria-hidden=true href=#5-配置防火墙nat规则>#</a></h3><blockquote><p><strong>注意</strong>: 如果你的公网网卡不是 <code>eth0</code>，请用 <code>ip a</code> 命令查看并替换。这一步是必需的，它负责将从隧道过来的、源地址为私网IP（<code>10.0.0.2</code>）的数据包，在发送到公网前，将其源地址“伪装”成VPS自己的公网IP，从而让目标服务器知道将响应数据发回给谁。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 允许所有来自wg0接口的数据包被转发</span>
</span></span><span style=display:flex><span>sudo iptables -A FORWARD -i wg0 -j ACCEPT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 将所有从公网网卡出去的包，其源地址伪装成公网地址</span>
</span></span><span style=display:flex><span>sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</span></span></code></pre></div><h3 id=6-启动wireguard服务>6. 启动WireGuard服务<a hidden class=anchor aria-hidden=true href=#6-启动wireguard服务>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 启动名为wg0的WireGuard接口</span>
</span></span><span style=display:flex><span>sudo wg-quick up wg0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 设置WireGuard服务开机自启</span>
</span></span><span style=display:flex><span>sudo systemctl enable wg-quick@wg0
</span></span></code></pre></div><hr><h2 id=第二部分国内linux网关-客户端-配置>第二部分：国内Linux网关 (客户端) 配置<a hidden class=anchor aria-hidden=true href=#第二部分国内linux网关-客户端-配置>#</a></h2><p>这是整个系统的核心，所有智能分流逻辑都在此实现。</p><h3 id=1-系统准备与软件安装-1>1. 系统准备与软件安装<a hidden class=anchor aria-hidden=true href=#1-系统准备与软件安装-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 更新并升级</span>
</span></span><span style=display:flex><span>sudo apt update <span style=color:#f92672>&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 安装所有必需的软件</span>
</span></span><span style=display:flex><span>sudo apt install wireguard dnsmasq ipset git curl -y
</span></span></code></pre></div><h3 id=2-生成wireguard密钥>2. 生成WireGuard密钥<a hidden class=anchor aria-hidden=true href=#2-生成wireguard密钥>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>wg genkey | tee domestic_privatekey | wg pubkey &gt; domestic_publickey<span style=color:#e6db74>```</span>
</span></span><span style=display:flex><span>&gt; **重要**: 将 <span style=color:#e6db74>`</span>domestic_publickey<span style=color:#e6db74>`</span> 文件的内容，填入您VPS上 <span style=color:#e6db74>`</span>wg0.conf<span style=color:#e6db74>`</span> 文件里 <span style=color:#e6db74>`</span><span style=color:#f92672>[</span>Peer<span style=color:#f92672>]</span><span style=color:#e6db74>`</span> 部分的 <span style=color:#e6db74>`</span>PublicKey<span style=color:#e6db74>`</span> 字段。然后在VPS上重启WireGuard <span style=color:#f92672>(</span><span style=color:#e6db74>`</span>sudo wg-quick down wg0 <span style=color:#f92672>&amp;&amp;</span> sudo wg-quick up wg0<span style=color:#e6db74>`</span><span style=color:#f92672>)</span>。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>### 3. 配置Dnsmasq</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>*   **主配置文件 <span style=color:#f92672>(</span><span style=color:#e6db74>`</span>/etc/dnsmasq.conf<span style=color:#e6db74>`</span><span style=color:#f92672>)</span>**:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>```</span>bash
</span></span><span style=display:flex><span>    sudo nano /etc/dnsmasq.conf
</span></span></code></pre></div><pre><code>清空并填入以下内容 (将`192.168.1.1`替换为您的网关实际IP):
```ini
resolv-file=/etc/resolv.dnsmasq.conf
strict-order
listen-address=127.0.0.1,192.168.1.1
bind-interfaces
conf-dir=/etc/dnsmasq.d,*.conf
cache-size=10000
no-poll
no-hosts
```
</code></pre><ul><li><strong>上游DNS服务器文件 (<code>/etc/resolv.dnsmasq.conf</code>)</strong>:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nano /etc/resolv.dnsmasq.conf
</span></span></code></pre></div>填入（这是未匹配到任何规则时，默认使用的DNS）：<pre tabindex=0><code>nameserver 8.8.8.8
</code></pre></li></ul><h3 id=4-创建自动化与路由脚本>4. 创建自动化与路由脚本<a hidden class=anchor aria-hidden=true href=#4-创建自动化与路由脚本>#</a></h3><p>您需要手动创建以下三个脚本。</p><ul><li><strong>脚本1: 更新规则库 (<code>/usr/local/bin/update-lists.sh</code>)</strong><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nano /usr/local/bin/update-lists.sh
</span></span></code></pre></div>粘贴以下内容（<strong>已包含详细注释</strong>）：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># 脚本的开头，声明使用bash解释器来执行。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># set -e 是一个安全设置。它告诉脚本，如果任何命令执行后返回非零的退出状态（通常表示错误），</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 整个脚本将立即停止执行。这可以防止在某个步骤失败后，脚本继续执行错误或不完整的操作。</span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 变量定义 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义一些常用的路径和文件名，方便后续引用和修改。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># gfwlist2dnsmasq 工具的存放目录</span>
</span></span><span style=display:flex><span>GFWLIST2DNSMASQ_DIR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/opt/gfwlist2dnsmasq&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dnsmasq-china-list 项目的存放目录</span>
</span></span><span style=display:flex><span>CHINA_LIST_DIR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/opt/dnsmasq-china-list&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Dnsmasq 加载额外配置文件的目录</span>
</span></span><span style=display:flex><span>DNSMASQ_CONF_DIR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/etc/dnsmasq.d&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 由 gfwlist 生成的 Dnsmasq 配置文件路径</span>
</span></span><span style=display:flex><span>DNSMASQ_CONF_GFWLIST<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_DIR<span style=color:#e6db74>/gfwlist.conf&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 我们自己处理并合并后的国内域名 Dnsmasq 配置文件路径</span>
</span></span><span style=display:flex><span>DNSMASQ_CONF_CHINA_LIST_MERGED<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_DIR<span style=color:#e6db74>/china-list.conf&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义需要处理的国内域名列表源文件名数组</span>
</span></span><span style=display:flex><span>CHINA_LIST_SOURCE_FILES<span style=color:#f92672>=(</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;accelerated-domains.china.conf&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;apple.china.conf&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;google.china.conf&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 1/4: Updating gfwlist rules...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 检查 gfwlist2dnsmasq 工具目录是否存在。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> ! -d <span style=color:#e6db74>&#34;</span>$GFWLIST2DNSMASQ_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 如果目录不存在 (! -d)，说明是第一次运行，就从 GitHub 克隆 (clone) 整个项目到指定目录。</span>
</span></span><span style=display:flex><span>  git clone https://github.com/cokebar/gfwlist2dnsmasq.git <span style=color:#e6db74>&#34;</span>$GFWLIST2DNSMASQ_DIR<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用 cd 命令进入该工具的目录，并用 git pull 拉取最新的更新。</span>
</span></span><span style=display:flex><span>cd <span style=color:#e6db74>&#34;</span>$GFWLIST2DNSMASQ_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&amp;&amp;</span> git pull
</span></span><span style=display:flex><span><span style=color:#75715e># 执行 gfwlist2dnsmasq.sh 脚本，生成 Dnsmasq 配置文件。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -d 8.8.8.8: 指定解析这些域名时使用的DNS服务器。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -s gfwlist: 指定解析出的IP要加入名为 &#34;gfwlist&#34; 的 ipset 集合。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -o &#34;...&#34;: 指定输出配置文件的路径。</span>
</span></span><span style=display:flex><span>./gfwlist2dnsmasq.sh -d 8.8.8.8 -s gfwlist -o <span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_GFWLIST<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 2/4: Updating and processing domestic domain lists...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 检查 dnsmasq-china-list 的本地仓库目录是否存在。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> ! -d <span style=color:#e6db74>&#34;</span>$CHINA_LIST_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 如果不存在，就从 GitHub 克隆项目。</span>
</span></span><span style=display:flex><span>  git clone https://github.com/felixonmars/dnsmasq-china-list.git <span style=color:#e6db74>&#34;</span>$CHINA_LIST_DIR<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 进入该目录并拉取最新更新。</span>
</span></span><span style=display:flex><span>cd <span style=color:#e6db74>&#34;</span>$CHINA_LIST_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&amp;&amp;</span> git pull
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 自动化处理核心 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用 &gt; 操作符，清空或创建我们即将写入的合并配置文件。这可以确保每次运行时都是一个全新的文件。</span>
</span></span><span style=display:flex><span>&gt; <span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_CHINA_LIST_MERGED<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Processing china-list files to add ipset directive...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用 for 循环，遍历上面定义的国内域名列表源文件名数组。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> file in <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CHINA_LIST_SOURCE_FILES[@]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># sed 是一个强大的文本处理工具。这行命令是整个自动化方案的关键之一。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># &#39;s|...|...|&#39;: s 代表替换 (substitute)。我们用 | 作为分隔符，避免与路径中的 / 冲突。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># &#39;s|/\([^/]*\)$|/\1\nipset=/\1/directlist|&#39;:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#   - `/\([^/]*\)$`: 这是要查找的模式。它匹配以 &#34;/&#34; 开头，后面跟着一串不包含 &#34;/&#34; 的字符，直到行尾。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     例如，它会匹配 &#39;server=/qq.com/119.29.29.29&#39; 中的 &#39;/qq.com&#39;。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     `\(` 和 `\)` 用于创建一个“捕获组”，把匹配到的域名（如 &#39;qq.com&#39;）存起来。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#   - `/\1\nipset=/\1/directlist`: 这是替换后的内容。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     `\1` 代表第一个捕获组的内容（即域名）。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     `\n` 代表换行符。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     所以，这整段的意思是：在原始行（如 &#39;server=/qq.com/...&#39;）的后面，换一行，并插入 &#39;ipset=/qq.com/directlist&#39;。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># `&#34;${CHINA_LIST_DIR}/${file}&#34;`: 这是 sed 命令要处理的输入文件。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># `&gt;&gt; &#34;$DNSMASQ_CONF_CHINA_LIST_MERGED&#34;`: `&gt;&gt;` 是追加重定向，将 sed 处理后的结果追加到我们合并的配置文件中。</span>
</span></span><span style=display:flex><span>  sed <span style=color:#e6db74>&#39;s|/\([^/]*\)$|/\1\nipset=/\1/directlist|&#39;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CHINA_LIST_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> &gt;&gt; <span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_CHINA_LIST_MERGED<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 3/4: Cleaning up old china-list files...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 为了避免 Dnsmasq 加载我们处理前的原始文件，造成规则冲突或重复，这里将它们从配置目录中删除。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># rm -f: -f (force) 表示即使文件不存在也不报错。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> file in <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CHINA_LIST_SOURCE_FILES[@]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    rm -f <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>DNSMASQ_CONF_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 4/4: Restarting Dnsmasq...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 所有规则都已更新并处理完毕，现在重启 Dnsmasq 服务以加载所有新的配置文件。</span>
</span></span><span style=display:flex><span>sudo systemctl restart dnsmasq
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Update process finished.&#34;</span>
</span></span></code></pre></div></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash></code></pre></div><ul><li><p><strong>脚本1: 更新规则库 (<code>/usr/local/bin/update-lists.sh</code>)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nano /usr/local/bin/update-lists.sh
</span></span></code></pre></div><p>粘贴以下内容（<strong>已包含详细注释</strong>）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e># 脚本的开头，声明使用bash解释器来执行。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># set -e 是一个安全设置。它告诉脚本，如果任何命令执行后返回非零的退出状态（通常表示错误），</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 整个脚本将立即停止执行。这可以防止在某个步骤失败后，脚本继续执行错误或不完整的操作。</span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 变量定义 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义一些常用的路径和文件名，方便后续引用和修改。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># gfwlist2dnsmasq 工具的存放目录</span>
</span></span><span style=display:flex><span>GFWLIST2DNSMASQ_DIR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/opt/gfwlist2dnsmasq&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># dnsmasq-china-list 项目的存放目录</span>
</span></span><span style=display:flex><span>CHINA_LIST_DIR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/opt/dnsmasq-china-list&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Dnsmasq 加载额外配置文件的目录</span>
</span></span><span style=display:flex><span>DNSMASQ_CONF_DIR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/etc/dnsmasq.d&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 由 gfwlist 生成的 Dnsmasq 配置文件路径</span>
</span></span><span style=display:flex><span>DNSMASQ_CONF_GFWLIST<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_DIR<span style=color:#e6db74>/gfwlist.conf&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 我们自己处理并合并后的国内域名 Dnsmasq 配置文件路径</span>
</span></span><span style=display:flex><span>DNSMASQ_CONF_CHINA_LIST_MERGED<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_DIR<span style=color:#e6db74>/china-list.conf&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 定义需要处理的国内域名列表源文件名数组</span>
</span></span><span style=display:flex><span>CHINA_LIST_SOURCE_FILES<span style=color:#f92672>=(</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;accelerated-domains.china.conf&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;apple.china.conf&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;google.china.conf&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 1/4: Updating gfwlist rules...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 检查 gfwlist2dnsmasq 工具目录是否存在。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> ! -d <span style=color:#e6db74>&#34;</span>$GFWLIST2DNSMASQ_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 如果目录不存在 (! -d)，说明是第一次运行，就从 GitHub 克隆 (clone) 整个项目到指定目录。</span>
</span></span><span style=display:flex><span>  git clone https://github.com/cokebar/gfwlist2dnsmasq.git <span style=color:#e6db74>&#34;</span>$GFWLIST2DNSMASQ_DIR<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用 cd 命令进入该工具的目录，并用 git pull 拉取最新的更新。</span>
</span></span><span style=display:flex><span>cd <span style=color:#e6db74>&#34;</span>$GFWLIST2DNSMASQ_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&amp;&amp;</span> git pull
</span></span><span style=display:flex><span><span style=color:#75715e># 执行 gfwlist2dnsmasq.sh 脚本，生成 Dnsmasq 配置文件。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -d 8.8.8.8: 指定解析这些域名时使用的DNS服务器。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -s gfwlist: 指定解析出的IP要加入名为 &#34;gfwlist&#34; 的 ipset 集合。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -o &#34;...&#34;: 指定输出配置文件的路径。</span>
</span></span><span style=display:flex><span>./gfwlist2dnsmasq.sh -d 8.8.8.8 -s gfwlist -o <span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_GFWLIST<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 2/4: Updating and processing domestic domain lists...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 检查 dnsmasq-china-list 的本地仓库目录是否存在。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> ! -d <span style=color:#e6db74>&#34;</span>$CHINA_LIST_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># 如果不存在，就从 GitHub 克隆项目。</span>
</span></span><span style=display:flex><span>  git clone https://github.com/felixonmars/dnsmasq-china-list.git <span style=color:#e6db74>&#34;</span>$CHINA_LIST_DIR<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 进入该目录并拉取最新更新。</span>
</span></span><span style=display:flex><span>cd <span style=color:#e6db74>&#34;</span>$CHINA_LIST_DIR<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>&amp;&amp;</span> git pull
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 自动化处理核心 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用 &gt; 操作符，清空或创建我们即将写入的合并配置文件。这可以确保每次运行时都是一个全新的文件。</span>
</span></span><span style=display:flex><span>&gt; <span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_CHINA_LIST_MERGED<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Processing china-list files to add ipset directive...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用 for 循环，遍历上面定义的国内域名列表源文件名数组。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> file in <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CHINA_LIST_SOURCE_FILES[@]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># sed 是一个强大的文本处理工具。这行命令是整个自动化方案的关键之一。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># &#39;s|...|...|&#39;: s 代表替换 (substitute)。我们用 | 作为分隔符，避免与路径中的 / 冲突。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># &#39;s|/\([^/]*\)$|/\1\nipset=/\1/directlist|&#39;:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#   - `/\([^/]*\)$`: 这是要查找的模式。它匹配以 &#34;/&#34; 开头，后面跟着一串不包含 &#34;/&#34; 的字符，直到行尾。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     例如，它会匹配 &#39;server=/qq.com/119.29.29.29&#39; 中的 &#39;/qq.com&#39;。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     `\(` 和 `\)` 用于创建一个“捕获组”，把匹配到的域名（如 &#39;qq.com&#39;）存起来。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#   - `/\1\nipset=/\1/directlist`: 这是替换后的内容。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     `\1` 代表第一个捕获组的内容（即域名）。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     `\n` 代表换行符。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#     所以，这整段的意思是：在原始行（如 &#39;server=/qq.com/...&#39;）的后面，换一行，并插入 &#39;ipset=/\1/directlist&#39;。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># `&#34;${CHINA_LIST_DIR}/${file}&#34;`: 这是 sed 命令要处理的输入文件。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># `&gt;&gt; &#34;$DNSMASQ_CONF_CHINA_LIST_MERGED&#34;`: `&gt;&gt;` 是追加重定向，将 sed 处理后的结果追加到我们合并的配置文件中。</span>
</span></span><span style=display:flex><span>  sed <span style=color:#e6db74>&#39;s|/\([^/]*\)$|/\1\nipset=/\1/directlist|&#39;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CHINA_LIST_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> &gt;&gt; <span style=color:#e6db74>&#34;</span>$DNSMASQ_CONF_CHINA_LIST_MERGED<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 3/4: Cleaning up old china-list files...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 为了避免 Dnsmasq 加载我们处理前的原始文件，造成规则冲突或重复，这里将它们从配置目录中删除。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># rm -f: -f (force) 表示即使文件不存在也不报错。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> file in <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CHINA_LIST_SOURCE_FILES[@]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    rm -f <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>DNSMASQ_CONF_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>file<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 4/4: Restarting Dnsmasq...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 所有规则都已更新并处理完毕，现在重启 Dnsmasq 服务以加载所有新的配置文件。</span>
</span></span><span style=display:flex><span>sudo systemctl restart dnsmasq
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Update process finished.&#34;</span>
</span></span></code></pre></div></li><li><p><strong>脚本2: 应用防火墙和路由规则 (<code>/usr/local/bin/apply-routing-rules.sh</code>)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nano /usr/local/bin/apply-routing-rules.sh
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>    粘贴以下内容：
</span></span><span style=display:flex><span><span style=color:#e6db74>```</span>bash
</span></span><span style=display:flex><span><span style=color:#75715e>#!/bin/bash</span>
</span></span><span style=display:flex><span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 变量定义 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># FW_MARK: 防火墙标记，用于策略路由。可以任意，但通常用WireGuard端口号便于识别。</span>
</span></span><span style=display:flex><span>FW_MARK<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;51820&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># TABLE_ID: 自定义路由表的ID。避免与系统已使用的表冲突，100是一个安全的选择。</span>
</span></span><span style=display:flex><span>TABLE_ID<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;100&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># FOREIGN_DNS: 我们指定的国外/上游DNS服务器，用于DNS防泄漏。</span>
</span></span><span style=display:flex><span>FOREIGN_DNS<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;8.8.8.8&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 1/3: Initializing ipsets...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 初始化IP集合 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 销毁并创建 gfwlist 和新的 directlist 集合，确保每次应用都是干净的状态。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2&gt;/dev/null: 将可能出现的“集合不存在”的错误信息重定向到“黑洞”，避免在首次运行时报错。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># || true: 即使ipset destroy命令失败（比如集合不存在），也确保脚本继续执行。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># timeout 86400: 设置ipset中条目的默认超时时间为一天(86400秒)，之后会自动过期。</span>
</span></span><span style=display:flex><span>ipset destroy gfwlist 2&gt;/dev/null <span style=color:#f92672>||</span> true; ipset create gfwlist hash:ip,family inet,timeout <span style=color:#ae81ff>86400</span>
</span></span><span style=display:flex><span>ipset destroy directlist 2&gt;/dev/null <span style=color:#f92672>||</span> true; ipset create directlist hash:ip,family inet,timeout <span style=color:#ae81ff>86400</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 流量标记 (Mangle Table) ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># [策略反转]</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 规则1: 优先标记本机发往国外DNS的查询请求，确保DNS解析本身走隧道，防止被窥探。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -p udp --dport 53: 匹配协议为udp、目标端口为53（DNS）的数据包。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -d $FOREIGN_DNS: 匹配目标地址是8.8.8.8的数据包。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -j MARK --set-mark $FW_MARK: 对匹配的数据包打上标记。</span>
</span></span><span style=display:flex><span>iptables -t mangle -A OUTPUT -p udp --dport <span style=color:#ae81ff>53</span> -d $FOREIGN_DNS -j MARK --set-mark $FW_MARK
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 规则2: 白名单规则。如果流量的目标IP在直连白名单(directlist)中，则直接返回(RETURN)，</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 不进行后续任何标记。这意味着它将走系统默认路由（即本地网络出口）。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -m set --match-set directlist dst: 匹配目标IP(dst)在名为directlist的集合中的数据包。</span>
</span></span><span style=display:flex><span>iptables -t mangle -A PREROUTING -m set --match-set directlist dst -j RETURN
</span></span><span style=display:flex><span>iptables -t mangle -A OUTPUT -m set --match-set directlist dst -j RETURN
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 规则3: 默认标记规则。对于所有不满足上一条白名单规则的流量，全部无条件打上标记。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 这包括了gfwlist的流量和所有未知的互联网流量。</span>
</span></span><span style=display:flex><span>iptables -t mangle -A PREROUTING -j MARK --set-mark $FW_MARK
</span></span><span style=display:flex><span>iptables -t mangle -A OUTPUT -j MARK --set-mark $FW_MARK
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- Kill Switch (Filter Table) ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 在OUTPUT链顶部插入规则：如果数据包有标记但出口不是wg0，则丢弃(DROP)。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 这是防止VPN断开时，被标记的流量从本地出口泄露真实IP。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -I OUTPUT 1: 在OUTPUT链的第1个位置插入此规则，确保最先被匹配。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -m mark --mark $FW_MARK: 匹配带有我们设置的标记的数据包。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ! -o wg0: 匹配出口网卡 *不是* wg0 的数据包。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -j DROP: 丢弃数据包。</span>
</span></span><span style=display:flex><span>iptables -I OUTPUT <span style=color:#ae81ff>1</span> -m mark --mark $FW_MARK ! -o wg0 -j DROP
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 策略路由 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 删除可能存在的旧规则，然后添加新规则：所有带标记的包，去查询ID为100的路由表。</span>
</span></span><span style=display:flex><span>ip rule del fwmark $FW_MARK table $TABLE_ID 2&gt;/dev/null <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span>ip rule add fwmark $FW_MARK table $TABLE_ID
</span></span><span style=display:flex><span><span style=color:#75715e># 在路由表100中，设置默认路由为通过wg0接口发出。</span>
</span></span><span style=display:flex><span>ip route add default dev wg0 table $TABLE_ID
</span></span><span style=display:flex><span><span style=color:#75715e># 刷新路由缓存使规则立即生效。</span>
</span></span><span style=display:flex><span>ip route flush cache
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; 3/3: Routing rules applied.&#34;</span>
</span></span></code></pre></div></li><li><p><strong>脚本3: 清理所有规则 (<code>/usr/local/bin/cleanup-routing-rules.sh</code>)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo nano /usr/local/bin/cleanup-routing-rules.sh
</span></span></code></pre></div><p>粘贴以下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set -e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 变量定义 ---</span>
</span></span><span style=display:flex><span>FW_MARK<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;51820&#34;</span>
</span></span><span style=display:flex><span>TABLE_ID<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;100&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;--&gt; Cleaning up all firewall and routing rules...&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># --- 清理iptables规则 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 清空 Mangle 表和 Filter 表中我们可能添加过规则的链</span>
</span></span><span style=display:flex><span>iptables -t mangle -F PREROUTING; iptables -t mangle -F OUTPUT; iptables -t filter -F OUTPUT
</span></span><span style=display:flex><span><span style=color:#75715e># --- 清理策略路由 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 删除之前添加的策略路由规则</span>
</span></span><span style=display:flex><span>ip rule del fwmark $FW_MARK table $TABLE_ID 2&gt;/dev/null <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span><span style=color:#75715e># --- 清理ipset集合 ---</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 销毁 ipset 集合，释放内存</span>
</span></span><span style=display:flex><span>ipset destroy gfwlist 2&gt;/dev/null <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span>ipset destroy directlist 2&gt;/dev/null <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;Cleanup complete.&#34;</span>
</span></span></code></pre></div><pre><code>    ; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; www.baidu.com @192.168.1.1
    ;; global options: +cmd
    ;; Got answer:
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 54010
    ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1

    ;; OPT PSEUDOSECTION:
    ; EDNS: version: 0, flags:; udp: 65494
    ;; QUESTION SECTION:
    ;www.baidu.com.                 IN      A

    ;; ANSWER SECTION:
    www.baidu.com.          600     IN      CNAME   www.a.shifen.com.
    www.a.shifen.com.       60      IN      A       110.242.68.3
    www.a.shifen.com.       60      IN      A       110.242.68.4

    ;; Query time: 15 msec
    ;; SERVER: 192.168.1.1#53(192.168.1.1)  &lt;-- 关键看这里！
    ;; WHEN: Thu Oct 23 11:30:00 UTC 2025
    ;; MSG SIZE  rcvd: 107
    ```
    查询时间 (`Query time`) 通常会很短（例如 &lt; 50ms）。

*   **测试国外域名**:
    同样，在局域网客户端上执行：
    ```bash
    dig www.google.com @192.168.1.1
    ```
    **预期结果**:
    `SERVER` 行依然显示的是你**网关的IP地址**。这表明请求被网关Dnsmasq接收，然后Dnsmasq根据规则（未匹配国内域名列表），将查询转发给了默认的上游DNS `8.8.8.8`。由于这个转发过程是通过WireGuard隧道的，所以查询时间 (`Query time`) 可能会比国内域名稍长一些。
    ```
    ; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; www.google.com @192.168.1.1
    ;; global options: +cmd
    ;; Got answer:
    ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 37123
    ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

    ;; OPT PSEUDOSECTION:
    ; EDNS: version: 0, flags:; udp: 65494
    ;; QUESTION SECTION:
    ;www.google.com.                        IN      A

    ;; ANSWER SECTION:
    www.google.com.         242     IN      A       142.250.199.100

    ;; Query time: 120 msec   &lt;-- 时间可能因隧道延迟而变长
    ;; SERVER: 192.168.1.1#53(192.168.1.1)  &lt;-- 关键看这里！
    ;; WHEN: Thu Oct 23 11:32:15 UTC 2025
    ;; MSG SIZE  rcvd: 59
    ```            通过这两个 `dig` 测试，你可以百分之百确认Dnsmasq的分流策略已经按预期工作。
</code></pre></li></ul><hr><p><strong>文档结束</strong></p><hr><hr><h2 id=检查与改进建议>检查与改进建议<a hidden class=anchor aria-hidden=true href=#检查与改进建议>#</a></h2><h3 id=一-技术方案审查-technical-review>一、 技术方案审查 (Technical Review)<a hidden class=anchor aria-hidden=true href=#一-技术方案审查-technical-review>#</a></h3><p><strong>总体评价：方案设计非常出色，技术实现合理且正确。</strong></p><p>这是一个工业级的个人网关部署方案，逻辑环环相扣，考虑了自动化和安全性。我对方案中的命令和配置逐一进行了检查，结论如下：</p><ol><li><strong>VPS端配置</strong>：完全正确。<code>net.ipv4.ip_forward=1</code> 开启了路由功能，<code>iptables</code> 的 <code>MASQUERADE</code> 规则是实现NAT转换的标准做法，配置无误。</li><li><strong>网关端Dnsmasq配置</strong>：配置合理。通过 <code>conf-dir</code> 加载分流规则，通过 <code>resolv-file</code> 指定默认上游DNS，这是实现DNS分流的标准实践。</li><li><strong>核心脚本 <code>update-lists.sh</code></strong>：逻辑严谨，实现巧妙。<ul><li><code>git clone/pull</code> 的逻辑可以确保规则库始终是最新版本。</li><li><strong>核心命令</strong> <code>sed 's|/\([^/]*\)$|/\1\nipset=/\1/directlist|'</code> <strong>是整个自动化方案的精髓</strong>。它没有修改原始规则文件，而是在内存中处理每一行，动态地为每个国内域名规则追加一条 <code>ipset</code> 指令。这使得Dnsmasq在解析这些域名的同时，能自动将解析出的IP地址添加到名为 <code>directlist</code> 的IP集合中。这个实现非常优雅且高效。</li></ul></li><li><strong>核心脚本 <code>apply-routing-rules.sh</code></strong>：逻辑正确，实现了“白名单直连，默认代理”的反向策略。<ul><li><strong>IPset初始化</strong>：<code>ipset destroy ... || true</code> 的写法很规范，能避免脚本在首次运行时因集合不存在而报错中断。</li><li><strong>流量标记逻辑</strong>：这是典型的“策略反转”思路。它没有去标记“需要代理”的流量，而是先匹配“需要直连”的流量（<code>-m set --match-set directlist dst -j RETURN</code>）让其通过，然后将<strong>所有剩下</strong>的流量（<code>-j MARK</code>）无条件标记。这确保了任何未知流量都会默认走代理，增强了隐私性。</li><li><strong>Kill Switch</strong>：<code>iptables -I OUTPUT 1 -m mark --mark $FW_MARK ! -o wg0 -j DROP</code> 是一条非常关键和正确的安全规则。它为网关本机提供了强有力的防泄漏保障。对于局域网内的其他设备，当 <code>wg0</code> 接口关闭时，策略路由 <code>ip rule</code> 所指向的路由表 <code>100</code> 中的 <code>default dev wg0</code> 路由会失效，数据包同样无法发出，从而实现了对整个局域网的Kill Switch效果。</li></ul></li><li><strong>WireGuard客户端配置</strong>：配置正确，特别是 <code>Table = off</code> 的使用。<ul><li><code>Table = off</code> 是高级用法，它阻止了 <code>wg-quick</code> 工具修改系统默认的主路由表。这是本方案能正常工作的<strong>关键设置</strong>，因为它把路由控制权完全交给了我们的 <code>PostUp</code> 脚本和策略路由，避免了路由冲突。</li><li>通过 <code>PostUp</code> 和 <code>PreDown</code> 钩子来自动执行规则应用和清理脚本，是 <code>wg-quick</code> 的标准集成方式，实现了配置的自动化和原子性。</li></ul></li></ol><h3 id=二-总结与细微改进建议>二、 总结与细微改进建议<a hidden class=anchor aria-hidden=true href=#二-总结与细微改进建议>#</a></h3><p><strong>总结</strong></p><p>这篇部署方案从技术角度看是<strong>一份可以被直接采纳并部署的、高质量的生产级方案</strong>。它逻辑清晰、自动化程度高、安全性强，并且正确地运用了Linux网络栈的各项高级功能（策略路由、ipset、mangle标记等）。对于想要实现精细化流量控制的用户来说，这是一个极佳的模板和学习材料。</p><p><strong>细微改进建议（非错误修正）</strong></p><ol><li><strong>脚本注释增强</strong>：我已经根据您的要求，在上面的原文副本中，对 <code>apply-routing-rules.sh</code> 和其他脚本的部分关键命令增加了更详细的注释，以便于新手理解每个参数的意义。</li><li><strong>Crontab命令</strong>：在“设置自动化更新”部分，原命令 <code>crontab -e</code> 会编辑当前用户的定时任务。由于更新脚本和重启服务需要root权限，建议明确为 <code>sudo crontab -e</code>，以编辑root用户的定时任务。这一点我也在上面的副本中修正了。</li><li><strong>ipset持久化（可选）</strong>：当前的ipset规则是临时的，每次重启网关或重启 <code>wg-quick</code> 服务时，<code>apply-routing-rules.sh</code> 会重建它们。这是完全可行的。但如果追求更快的启动速度，可以研究 <code>ipset-persistent</code> 等工具，将ipset集合保存到磁盘，并在系统启动时自动加载。不过对于本方案来说，现有机制已经足够好，这并非必要项。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/%E7%BD%91%E7%BB%9C/>网络</a></li><li><a href=http://ljj1992.fun/tags/wireguard/>WireGuard</a></li><li><a href=http://ljj1992.fun/tags/ipset/>Ipset</a></li><li><a href=http://ljj1992.fun/tags/dns/>DNS</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>