<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SuperClaude.md | star徐的博客</title><meta name=keywords content="SuperClaude,Claude,代码审计,漏洞挖掘,AI安全"><meta name=description content="SuperClaude中文使用手册
一、产品概述
SuperClaude 是一个上下文工程框架 (Context Engineering Framework)。
可以把它想象成一套给 Claude Code 使用的**“专家行为配置包”。它通过一系列精心设计的 Markdown (.md) 指令文件，来配置和增强**你现有的 Claude Code，注入特定的行为、知识和工作流程。
💡 核心比喻：

标准 Claude Code 就像一位知识渊博、但经验泛泛的全才程序员。
SuperClaude 则给了这位程序员一整套专家工具箱：里面有顶尖架构师的设计蓝图、安全专家的审计清单、前端大师的组件库以及项目经理的详细流程图。

当你使用 SuperClaude 的命令时，你其实是在告诉这位全才程序员：“嘿，现在请你戴上‘安全专家’的帽子，并遵循这套‘代码审计’的流程来工作。”
1.它解决了什么核心痛点

从“随性”到“系统”：标准的AI编程往往是“一问一答”式的，缺乏系统性和长远规划。SuperClaude 将这种随性的请求，转化为结构化的、可验证的、有质量门禁的开发工作流。
从“全才”到“专家”：通用AI模型在特定领域的深度和最佳实践上有所欠缺。SuperClaude 通过 AI Agents (AI 专家) 机制，让 Claude Code 能够调用特定领域的深层知识，如安全、性能、前端架构等。
从“短期记忆”到“长期项目”：AI 在长对话中容易丢失上下文。SuperClaude 通过会话管理和 MCP 服务器 (如 Serena)，实现了跨对话的持久化项目记忆，让你可以真正地进行长期、复杂的项目开发。
从“孤立工具”到“生态联动”：AI 无法直接使用外部工具。SuperClaude 通过 MCP 服务器，打通了 Claude Code 与真实开发工具（如浏览器测试、UI组件库、文档查询等）的连接，极大地扩展了其能力边界。

2.SuperClaude的解决方案

14个领域专家自动协作，无需手动切换
21个系统命令提供端到端工作流
持久会话管理保持项目上下文
智能工具路由自动选择最佳MCP服务器
质量门控自动集成安全、性能、测试专家

3.产品特点

🧠 21个命令：结构化开发工作流（如/sc:brainstorm, /sc:analyze）
🧪 14个AI代理：领域专家（如@agent-security, @agent-python）
⚙️ 6种行为模式：上下文优化模式（如--ultrathink, --token-efficient）
🔌 6个MCP服务器：工具集成（如Morphllm, Tavily）
📦 无缝集成：直接在Claude Code中使用/sc:命令


💡 关键洞察：SuperClaude不是执行软件，而是配置框架，通过修改Claude Code的上下文来增强其行为。它不替代Claude Code，而是使其成为更强大的开发伙伴。"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/superclaude/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/superclaude/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/superclaude/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="SuperClaude.md"><meta property="og:description" content="SuperClaude中文使用手册 一、产品概述 SuperClaude 是一个上下文工程框架 (Context Engineering Framework)。
可以把它想象成一套给 Claude Code 使用的**“专家行为配置包”。它通过一系列精心设计的 Markdown (.md) 指令文件，来配置和增强**你现有的 Claude Code，注入特定的行为、知识和工作流程。
💡 核心比喻：
标准 Claude Code 就像一位知识渊博、但经验泛泛的全才程序员。 SuperClaude 则给了这位程序员一整套专家工具箱：里面有顶尖架构师的设计蓝图、安全专家的审计清单、前端大师的组件库以及项目经理的详细流程图。 当你使用 SuperClaude 的命令时，你其实是在告诉这位全才程序员：“嘿，现在请你戴上‘安全专家’的帽子，并遵循这套‘代码审计’的流程来工作。”
1.它解决了什么核心痛点 从“随性”到“系统”：标准的AI编程往往是“一问一答”式的，缺乏系统性和长远规划。SuperClaude 将这种随性的请求，转化为结构化的、可验证的、有质量门禁的开发工作流。 从“全才”到“专家”：通用AI模型在特定领域的深度和最佳实践上有所欠缺。SuperClaude 通过 AI Agents (AI 专家) 机制，让 Claude Code 能够调用特定领域的深层知识，如安全、性能、前端架构等。 从“短期记忆”到“长期项目”：AI 在长对话中容易丢失上下文。SuperClaude 通过会话管理和 MCP 服务器 (如 Serena)，实现了跨对话的持久化项目记忆，让你可以真正地进行长期、复杂的项目开发。 从“孤立工具”到“生态联动”：AI 无法直接使用外部工具。SuperClaude 通过 MCP 服务器，打通了 Claude Code 与真实开发工具（如浏览器测试、UI组件库、文档查询等）的连接，极大地扩展了其能力边界。 2.SuperClaude的解决方案 14个领域专家自动协作，无需手动切换 21个系统命令提供端到端工作流 持久会话管理保持项目上下文 智能工具路由自动选择最佳MCP服务器 质量门控自动集成安全、性能、测试专家 3.产品特点 🧠 21个命令：结构化开发工作流（如/sc:brainstorm, /sc:analyze） 🧪 14个AI代理：领域专家（如@agent-security, @agent-python） ⚙️ 6种行为模式：上下文优化模式（如--ultrathink, --token-efficient） 🔌 6个MCP服务器：工具集成（如Morphllm, Tavily） 📦 无缝集成：直接在Claude Code中使用/sc:命令 💡 关键洞察：SuperClaude不是执行软件，而是配置框架，通过修改Claude Code的上下文来增强其行为。它不替代Claude Code，而是使其成为更强大的开发伙伴。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-18T17:35:00+08:00"><meta property="article:modified_time" content="2025-11-18T17:35:00+08:00"><meta property="article:tag" content="SuperClaude"><meta property="article:tag" content="Claude"><meta property="article:tag" content="代码审计"><meta property="article:tag" content="漏洞挖掘"><meta property="article:tag" content="AI安全"><meta name=twitter:card content="summary"><meta name=twitter:title content="SuperClaude.md"><meta name=twitter:description content="SuperClaude中文使用手册
一、产品概述
SuperClaude 是一个上下文工程框架 (Context Engineering Framework)。
可以把它想象成一套给 Claude Code 使用的**“专家行为配置包”。它通过一系列精心设计的 Markdown (.md) 指令文件，来配置和增强**你现有的 Claude Code，注入特定的行为、知识和工作流程。
💡 核心比喻：

标准 Claude Code 就像一位知识渊博、但经验泛泛的全才程序员。
SuperClaude 则给了这位程序员一整套专家工具箱：里面有顶尖架构师的设计蓝图、安全专家的审计清单、前端大师的组件库以及项目经理的详细流程图。

当你使用 SuperClaude 的命令时，你其实是在告诉这位全才程序员：“嘿，现在请你戴上‘安全专家’的帽子，并遵循这套‘代码审计’的流程来工作。”
1.它解决了什么核心痛点

从“随性”到“系统”：标准的AI编程往往是“一问一答”式的，缺乏系统性和长远规划。SuperClaude 将这种随性的请求，转化为结构化的、可验证的、有质量门禁的开发工作流。
从“全才”到“专家”：通用AI模型在特定领域的深度和最佳实践上有所欠缺。SuperClaude 通过 AI Agents (AI 专家) 机制，让 Claude Code 能够调用特定领域的深层知识，如安全、性能、前端架构等。
从“短期记忆”到“长期项目”：AI 在长对话中容易丢失上下文。SuperClaude 通过会话管理和 MCP 服务器 (如 Serena)，实现了跨对话的持久化项目记忆，让你可以真正地进行长期、复杂的项目开发。
从“孤立工具”到“生态联动”：AI 无法直接使用外部工具。SuperClaude 通过 MCP 服务器，打通了 Claude Code 与真实开发工具（如浏览器测试、UI组件库、文档查询等）的连接，极大地扩展了其能力边界。

2.SuperClaude的解决方案

14个领域专家自动协作，无需手动切换
21个系统命令提供端到端工作流
持久会话管理保持项目上下文
智能工具路由自动选择最佳MCP服务器
质量门控自动集成安全、性能、测试专家

3.产品特点

🧠 21个命令：结构化开发工作流（如/sc:brainstorm, /sc:analyze）
🧪 14个AI代理：领域专家（如@agent-security, @agent-python）
⚙️ 6种行为模式：上下文优化模式（如--ultrathink, --token-efficient）
🔌 6个MCP服务器：工具集成（如Morphllm, Tavily）
📦 无缝集成：直接在Claude Code中使用/sc:命令


💡 关键洞察：SuperClaude不是执行软件，而是配置框架，通过修改Claude Code的上下文来增强其行为。它不替代Claude Code，而是使其成为更强大的开发伙伴。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"SuperClaude.md","item":"http://ljj1992.fun/posts/superclaude/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SuperClaude.md","name":"SuperClaude.md","description":"SuperClaude中文使用手册 一、产品概述 SuperClaude 是一个上下文工程框架 (Context Engineering Framework)。\n可以把它想象成一套给 Claude Code 使用的**“专家行为配置包”。它通过一系列精心设计的 Markdown (.md) 指令文件，来配置和增强**你现有的 Claude Code，注入特定的行为、知识和工作流程。\n💡 核心比喻：\n标准 Claude Code 就像一位知识渊博、但经验泛泛的全才程序员。 SuperClaude 则给了这位程序员一整套专家工具箱：里面有顶尖架构师的设计蓝图、安全专家的审计清单、前端大师的组件库以及项目经理的详细流程图。 当你使用 SuperClaude 的命令时，你其实是在告诉这位全才程序员：“嘿，现在请你戴上‘安全专家’的帽子，并遵循这套‘代码审计’的流程来工作。”\n1.它解决了什么核心痛点 从“随性”到“系统”：标准的AI编程往往是“一问一答”式的，缺乏系统性和长远规划。SuperClaude 将这种随性的请求，转化为结构化的、可验证的、有质量门禁的开发工作流。 从“全才”到“专家”：通用AI模型在特定领域的深度和最佳实践上有所欠缺。SuperClaude 通过 AI Agents (AI 专家) 机制，让 Claude Code 能够调用特定领域的深层知识，如安全、性能、前端架构等。 从“短期记忆”到“长期项目”：AI 在长对话中容易丢失上下文。SuperClaude 通过会话管理和 MCP 服务器 (如 Serena)，实现了跨对话的持久化项目记忆，让你可以真正地进行长期、复杂的项目开发。 从“孤立工具”到“生态联动”：AI 无法直接使用外部工具。SuperClaude 通过 MCP 服务器，打通了 Claude Code 与真实开发工具（如浏览器测试、UI组件库、文档查询等）的连接，极大地扩展了其能力边界。 2.SuperClaude的解决方案 14个领域专家自动协作，无需手动切换 21个系统命令提供端到端工作流 持久会话管理保持项目上下文 智能工具路由自动选择最佳MCP服务器 质量门控自动集成安全、性能、测试专家 3.产品特点 🧠 21个命令：结构化开发工作流（如/sc:brainstorm, /sc:analyze） 🧪 14个AI代理：领域专家（如@agent-security, @agent-python） ⚙️ 6种行为模式：上下文优化模式（如--ultrathink, --token-efficient） 🔌 6个MCP服务器：工具集成（如Morphllm, Tavily） 📦 无缝集成：直接在Claude Code中使用/sc:命令 💡 关键洞察：SuperClaude不是执行软件，而是配置框架，通过修改Claude Code的上下文来增强其行为。它不替代Claude Code，而是使其成为更强大的开发伙伴。\n","keywords":["SuperClaude","Claude","代码审计","漏洞挖掘","AI安全"],"articleBody":"SuperClaude中文使用手册 一、产品概述 SuperClaude 是一个上下文工程框架 (Context Engineering Framework)。\n可以把它想象成一套给 Claude Code 使用的**“专家行为配置包”。它通过一系列精心设计的 Markdown (.md) 指令文件，来配置和增强**你现有的 Claude Code，注入特定的行为、知识和工作流程。\n💡 核心比喻：\n标准 Claude Code 就像一位知识渊博、但经验泛泛的全才程序员。 SuperClaude 则给了这位程序员一整套专家工具箱：里面有顶尖架构师的设计蓝图、安全专家的审计清单、前端大师的组件库以及项目经理的详细流程图。 当你使用 SuperClaude 的命令时，你其实是在告诉这位全才程序员：“嘿，现在请你戴上‘安全专家’的帽子，并遵循这套‘代码审计’的流程来工作。”\n1.它解决了什么核心痛点 从“随性”到“系统”：标准的AI编程往往是“一问一答”式的，缺乏系统性和长远规划。SuperClaude 将这种随性的请求，转化为结构化的、可验证的、有质量门禁的开发工作流。 从“全才”到“专家”：通用AI模型在特定领域的深度和最佳实践上有所欠缺。SuperClaude 通过 AI Agents (AI 专家) 机制，让 Claude Code 能够调用特定领域的深层知识，如安全、性能、前端架构等。 从“短期记忆”到“长期项目”：AI 在长对话中容易丢失上下文。SuperClaude 通过会话管理和 MCP 服务器 (如 Serena)，实现了跨对话的持久化项目记忆，让你可以真正地进行长期、复杂的项目开发。 从“孤立工具”到“生态联动”：AI 无法直接使用外部工具。SuperClaude 通过 MCP 服务器，打通了 Claude Code 与真实开发工具（如浏览器测试、UI组件库、文档查询等）的连接，极大地扩展了其能力边界。 2.SuperClaude的解决方案 14个领域专家自动协作，无需手动切换 21个系统命令提供端到端工作流 持久会话管理保持项目上下文 智能工具路由自动选择最佳MCP服务器 质量门控自动集成安全、性能、测试专家 3.产品特点 🧠 21个命令：结构化开发工作流（如/sc:brainstorm, /sc:analyze） 🧪 14个AI代理：领域专家（如@agent-security, @agent-python） ⚙️ 6种行为模式：上下文优化模式（如--ultrathink, --token-efficient） 🔌 6个MCP服务器：工具集成（如Morphllm, Tavily） 📦 无缝集成：直接在Claude Code中使用/sc:命令 💡 关键洞察：SuperClaude不是执行软件，而是配置框架，通过修改Claude Code的上下文来增强其行为。它不替代Claude Code，而是使其成为更强大的开发伙伴。\n4. 设计架构 SuperClaude_Framework/ ├── superclaude/ # 框架核心组件 │ ├── Core/ # 核心规则和原则 (PRINCIPLES.md, RULES.md, FLAGS.md) │ ├── Agents/ # 14个AI代理 (领域专家) │ ├── Commands/ # 21个命令 (上下文触发模式) │ ├── Modes/ # 6种行为模式 │ └── MCP/ # 6个MCP服务器配置 └── setup/ 与Claude Code的集成方式\n上下文注入：SuperClaude通过~/.claude/目录中的配置文件向Claude Code注入特定上下文 命令触发：使用/sc:前缀触发特定上下文（如/sc:brainstorm） MCP集成：通过MCP服务器（Multi-Context Processing）提供外部工具能力 🌐 架构关系：SuperClaude是Claude Code的\"行为配置器\"，而非独立执行程序。它不运行代码，而是告诉Claude Code\"如何思考\"。\n二、常用命令 2.1 新手第一天必试的 5 个命令 直接复制到 Claude Code 聊天框\n命令 作用 推荐第一次尝试的输入 /sc:brainstorm \"任务管理 web app\" 需求挖掘神器，会疯狂问你问题，直到需求清晰 任何你想做的项目，先跑这个 /sc:implement \"用户登录注册功能\" 一句话出完整前后端 + 安全 + 测试代码 必试！感受降维打击 /sc:analyze src/ 上传你的代码文件夹，自动深度分析 把你现有项目拖进来分析 @agent-security \"review my code\" 手动叫安全专家审查 任何涉及登录、支付的代码必审 /sc:research \"2025 年最好的认证方案\" 自动联网查最新资料（Tavily MCP） 想了解最新技术趋势就用这个 2.2 常用命令速查表（30 个中最核心的 15 个） 类别 命令 用途示例 常用参数 规划设计 /sc:brainstorm 需求挖掘 --bs /sc:design 系统架构设计 --type api/component/database /sc:spec-panel 多专家评审需求文档 实现 /sc:implement 核心神器！一句话生成完整功能 --magic（美观 UI） /sc:build 构建/编译流程 --type prod 分析优化 /sc:analyze 深度代码分析 --ultrathink --all-mcp /sc:improve 代码重构优化 --type security/performance /sc:troubleshoot 排错神器 --seq 测试质量 /sc:test 自动生成单元/集成/E2E 测试 --type e2e --play 项目管理 /sc:load 项目名 恢复上一次项目所有记忆（跨会话！） /sc:save \"登录功能完成\" 保存当前进度到永久记忆 /sc:reflect 看看现在做到哪了，缺什么 --scope project 研究 /sc:research 自动联网查最新资料 --tavily 工具调用 --magic 生成现代漂亮 UI 需要 TWENTYFIRST_API_KEY（付费） --play 真实浏览器跑 E2E 测试 --uc 极度省 token（大项目必开） 2.3关键参数与标志 参数（或称 Flags）可以微调命令的行为。虽然大部分参数会根据你的输入自动激活，但了解几个关键的手动参数很有用。\n–focus: 用于 /sc:analyze 命令，指定分析的侧重点。 示例: /sc:analyze –focus security 会让分析更侧重于发现潜在的安全漏洞。 –type: 用于 /sc:design 或 /sc:test 等命令，明确你想要的设计类型或测试类型。 示例: /sc:design –type api 明确指出你想要设计的是 API 规范，而不是数据库结构。 示例: /sc:test –type e2e 指明需要生成端到端（End-to-End）测试脚本。 –no-mcp: 临时禁用所有 MCP 服务器，只使用 Claude Code 的原生能力。 示例: /sc:implement “a simple sort function” –no-mcp，用于简单的、不需要外部工具的任务，或者在排查 MCP 服务器问题时使用。 🚩 效率优化标志 --uc, --token-efficient # 令牌效率模式 (30-50%压缩) --think # 结构化思考 (4K tokens) --think-hard # 深度分析 (10K tokens) --ultrathink # 最大深度分析 (32K tokens) 🛠️ MCP服务器标志 --c7, --context7 # 官方文档模式 --magic # UI组件生成 --play, --playwright # 浏览器测试 --seq, --sequential # 时序分析 --tavily # 网络搜索 --all-mcp # 启用所有服务器 --no-mcp # 禁用MCP(故障排查) 🧠 行为模式标志 --brainstorm # 探索发现模式 --introspect # 透明推理模式 --task-manage # 任务协调模式 --orchestrate # 工具编排模式 2.4 命令使用示例 发现与规划 # 项目启动器 /sc:brainstorm \"任务管理 Web 应用\" # 学习要点：观察如何引导需求发现 /sc:analyze src/ # 学习要点：理解代码分析模式 /sc:design \"用户认证系统\" # 学习要点：系统设计思维 实现与构建 /sc:implement \"JWT 认证系统\" # 学习要点：最佳实践应用 /sc:build \"生产环境配置\" # 学习要点：构建流程优化 /sc:improve \"代码质量\" # 学习要点：重构模式 测试与文档 /sc:test --coverage # 学习要点：测试策略 /sc:document \"API 文档\" # 学习要点：文档生成 /sc:reflect # 学习要点：项目复盘 代理专家使用 # 安全专家协作 @agent-security \"审查认证实现\" @agent-security \"OWASP 合规检查\" # 架构师协作 @agent-system-architect \"微服务设计\" @agent-backend-architect \"API 设计评审\" # 性能专家协作 @agent-performance-engineer \"优化数据库查询\" @agent-frontend-architect \"提升页面加载速度\" # 质量专家协作 @agent-quality-engineer \"设计测试策略\" @agent-refactoring-expert \"代码重构建议\" 模式组合实践 # 复杂项目管理 /sc:implement \"电商平台\" --task-manage # 组合：Task Management + 自动代理协调 # 需求探索 /sc:brainstorm \"移动应用\" --brainstorm # 专注：需求发现和澄清 # 透明学习 /sc:analyze \"遗留系统\" --introspect # 重点：理解推理过程 # 高效沟通 /sc:research \"最新技术\" --uc # 优势：节省上下文空间 高级工作流 项目启动完整流程 /sc:brainstorm \"社交媒体应用\" /sc:load existing-project/ /sc:analyze . --focus architecture /sc:design \"微服务架构\" /sc:workflow \"完整开发计划\" # 开发实施阶段 /sc:implement \"用户服务\" --task-manage @agent-security \"安全审查\" @agent-performance-engineer \"性能优化\" /sc:test --coverage --type e2e # 项目收尾 /sc:document \"完整文档\" /sc:reflect --scope project /sc:save \"项目完成 v1.0\" 三、安装SuperClaude(Ubuntu) 对于 Ubuntu 系统，官方推荐使用 pipx 进行安装，因为它可以创建一个干净、隔离的环境，避免与系统或其他项目的 Python 包冲突。\n环境要求检查\nPython 3.8+: 在终端输入 python3 –version 检查。 pip: 通常随 Python 一起安装，输入 pip –version 检查。 Claude Code: 确保你的开发环境中已安装并能正常使用。 安装 pipx (如果尚未安装)\n# 使用 pip 安装 pipx python3 -m pip install --user pipx # 将 pipx 添加到系统路径 python3 -m pipx ensurepath 注意：运行第二条命令后，你可能需要重启终端才能让 pipx 命令生效。\n使用 pipx 安装 SuperClaude\n# 这条命令会做两件事： # 1. 使用 pipx 安装 SuperClaude 的管理工具 # 2. 运行 SuperClaude 的安装程序，将上下文文件（.md）安装到 ~/.claude/ 目录 pipx install SuperClaude \u0026\u0026 SuperClaude install 验证安装\n检查版本:\npython3 -m SuperClaude --version # 预期输出: SuperClaude 4.1.5 或更高版本 列出组件:\nSuperClaude install --list-components # 预期输出: 一个包含 core, agents, commands, modes, mcp 的列表 在 Claude Code 中测试: 打开 Claude Code，输入 /sc:brainstorm “test”。如果它开始向你提问而不是直接回答，那么恭喜你，SuperClaude 已成功激活！\n5.安装后，SuperClaude 的所有“智慧”都以 .md 文件的形式存放在你主目录下的 ~/.claude/ 中\nCLAUDE.md: 这是主入口文件，通过 @ 语法导入其他所有组件的上下文。 agents/: 存放所有专家 (Agent) 的行为定义文件。 commands/: 存放所有命令 (Command) 的工作流定义文件。 modes/: 存放所有行为模式 (Mode) 的定义文件。 四、案例研究 4.1 To-Do List 让我们通过一个具体案例——“构建一个简单的待办事项(To-Do List)Web应用”——来体验 SuperClaude 的完整流程。\n你只有一个模糊的想法，没关系，让 SuperClaude 帮你理清思路。\n在 Claude Code 中输入：\n/sc:brainstorm \"a simple to-do list web app\" 你会看到什么？ SuperClaude 不会立刻给你代码。相反，它会进入头脑风暴模式，开始向你提问，像一个产品经理一样： “这个应用是给谁用的？” “除了添加和删除任务，还需要哪些核心功能（比如设置截止日期、优先级）？” “我们计划使用什么技术栈（React, Vue, Svelte）？” 价值：这一步将模糊的需求转化为清晰、结构化的产品需求文档 (PRD)。 需求明确后，我们需要一个高级计划。\n假设你已经创建了一个项目文件夹 my-todo-app/。首先，让 SuperClaude 加载并分析当前的项目结构。\n# (假设你已在终端创建了文件夹和一些空文件) # 在 Claude Code 中... /sc:load my-todo-app/ /sc:analyze 接下来，让我们为最核心的功能——“用户认证”——生成一个详细的实施路线图。\n/sc:workflow \"user authentication for to-do app\" 你会看到什么？ 一个多阶段的计划，包含任务分解、依赖关系和质量检查点，例如： Phase 1: API 端点设计 (注册, 登录, 登出) Phase 2: 数据库模型设计 (User Schema) Phase 3: 后端逻辑实现 (密码哈希, JWT生成) Phase 4: 前端组件开发 (登录表单) Phase 5: 集成与测试 价值：将一个复杂任务分解为可管理的小块，确保实施过程的系统性和完整性。 现在，我们开始具体编码。\n执行计划中的第一步：\n/sc:implement \"JWT authentication API endpoint using FastAPI\" 在实现过程中，你可能需要特定领域的专家建议。比如，你不确定前端组件的最佳实践。这时，你可以手动召唤前端架构师：\n@agent-frontend \"suggest a good React component structure for the login form, focusing on accessibility\" 你会看到什么？ implement 命令会生成高质量、遵循最佳实践的代码片段。 @agent-frontend 会给出专业的建议，可能包括代码结构、状态管理方案，以及如何满足 WCAG 无障碍标准。 价值：代码不仅能跑，而且质量高、可维护性强，并融入了深度的领域知识。 今天的工作完成了，你需要保存当前的项目状态，以便明天能无缝衔接。\n/sc:save \"completed backend auth logic, frontend form structure designed\" ```第二天，当你打开一个新的 Claude Code 对话时： ```text /sc:load \"my-todo-app\" 你会看到什么？ 所有之前的上下文、设计决策、代码片段和讨论都会被恢复。你无需重复解释项目背景，可以直接继续工作。 价值：这实现了真正的跨会话项目连续性，是进行大型项目的关键。 总结\n分类 命令 描述 新手常用场景 规划设计 /sc:brainstorm 通过提问式交互，将模糊想法转化为明确需求。 项目启动时的第一步。 /sc:workflow 为一个复杂功能生成详细的、分阶段的实施计划。 在编码前规划好路线图。 开发实现 /sc:implement 根据需求，生成高质量、遵循最佳实践的代码。 核心编码命令。 /sc:improve 分析并重构现有代码，提升质量、性能或可读性。 优化你的代码。 测试质量 /sc:analyze 深度分析代码库，从架构、安全、性能等维度提供报告。 对现有项目进行“体检”。 /sc:test 根据功能描述，自动生成单元测试、集成测试或端到端测试。 保证代码质量。 /sc:troubleshoot 帮助你系统地调试一个 Bug 或性能问题。 解决棘手的错误。 辅助工具 /sc:save / /sc:load 保存和加载项目会话，实现跨对话的持久记忆。 长周期项目的必备。 4.2 任务管理应用开发 # 1. 需求发现阶段 /sc:brainstorm \"个人任务管理应用\" # 预期：系统会询问用户类型、功能需求、技术偏好等 # 2. 技术选型分析 /sc:research \"2024年最佳前端框架对比\" --depth deep # 预期：提供最新技术对比和选择建议 # 3. 架构设计 /sc:design \"现代前端架构\" --type architecture # 预期：生成架构图和技术栈建议 # 4. 安全实现 /sc:implement \"用户认证系统\" --focus security # 预期：JWT + 刷新令牌 + 速率限制 # 5. 性能优化 /sc:improve \"前端性能\" --type performance # 预期：打包优化、懒加载、缓存策略 4.3 遗留系统现代化 # 1. 现状分析 /sc:load legacy-system/ /sc:analyze . --ultrathink --all-mcp # 预期：深度分析系统现状 # 2. 问题诊断 /sc:troubleshoot \"性能瓶颈\" --type performance --trace # 预期：系统性问题定位 # 3. 重构规划 @agent-refactoring-expert \"制定现代化策略\" # 预期：渐进式重构计划 # 4. 实施改进 /sc:improve \"代码质量\" --safe --interactive # 预期：安全的逐步改进 # 5. 验证结果 /sc:test --type integration /sc:reflect --validate # 预期：全面验证改进效果 4.4 谷歌翻译插件-实现1 项目背景\n目标: 创建一个谷歌浏览器插件。用户在网页上选中文本，点击插件图标，就能在弹窗中看到翻译结果。 “智能”特性 (V1): 我们先实现核心翻译功能，后续迭代再加入“智能”元素（如自动检测语言、提供多种翻译引擎等）。 你的角色: SuperClaude 新手，熟悉基本的 Web 开发概念。 阶段一：项目启动与需求探索 (告别混沌的开始)\n传统的开发方式可能是直接打开 VS Code 开始写 manifest.json，但很快就会发现需求不明确，边写边改。SuperClaude 让我们从“产品经理”的视角开始。\n步骤 1: 使用 /sc:brainstorm 进行头脑风暴\n💡 为什么这么做？ 在写任何代码之前，我们必须将模糊的想法（“做一个翻译插件”）转化为清晰、可执行的需求。brainstorm 命令会通过引导式提问，帮助我们挖掘潜在需求、技术选型和功能边界，避免在开发中途迷失方向。\n▶️ 在 Claude Code 中输入：\n/sc:brainstorm \"a smart translator chrome extension\" 🤖 你会看到 SuperClaude 的回应 (类似这样):\n“好的，这是一个很棒的想法！让我们一起来深入探讨一下。在开始设计之前，我想先问几个问题来明确方向：\n核心功能: 用户如何触发翻译？是在选中文字后自动弹出，还是需要点击插件图标？ 翻译服务: 我们计划使用哪个第三方翻译 API？（例如 Google Translate, DeepL, Microsoft Translator?）这会影响到成本和实现方式。 用户界面: 插件的弹窗（Popup）需要显示哪些内容？仅仅是译文，还是也需要显示原文和发音按钮？ “智能”体现在哪: 在第一个版本中，“智能”是指什么？是自动语言检测，还是其他高级功能？ 数据存储: 是否需要保存用户的翻译历史？” ✅ 你的产出： 通过这次对话，你和 SuperClaude 共同确定了 V1 版本的清晰需求：\n触发方式: 选中文字后，点击浏览器右上角的插件图标。 翻译服务: 使用 DeepL API (假设你已经申请了 API Key)。 UI: 弹窗内有一个文本框显示原文，一个“翻译”按钮，和一个用于显示译文的区域。 智能特性: V1 暂不包含，核心是打通流程。 数据存储: V1 暂不包含。 阶段二：架构设计与开发规划 (搭建坚实的地基)\n需求清晰了，现在我们需要一个专业的架构师来规划项目结构和技术蓝图。\n步骤 2: 使用 @agent-architect 设计架构，并用 /sc:workflow 制定计划\n💡 为什么这么做？ 直接开始写功能代码容易导致结构混乱、难以维护。我们先让架构师专家 (@agent-architect) 规划高层设计，确保组件划分合理。然后用 workflow 命令将整个开发过程分解成一个个可管理、可验证的子任务，就像一个项目经理为你制定了详细的 JIRA 任务列表。\n▶️ 在 Claude Code 中输入：\n@agent-architect \"Based on our requirements, design the high-level architecture and file structure for our DeepL translator Chrome extension.\" 🤖 你会看到 SuperClaude (以架构师身份) 的回应：\n“收到。作为系统架构师，我建议采用以下结构，以实现关注点分离和未来的可扩展性：\n架构图解: [Popup UI (popup.html/js)] \u003c–\u003e [Background Script (background.js)] \u003c–\u003e [DeepL API]\nPopup UI: 负责用户交互。 Background Script: 负责处理核心逻辑，如 API 调用，以避免阻塞 UI。 推荐文件结构:\nsmart-translator/ ├── manifest.json # 插件的配置文件 ├── popup.html # 弹窗的 HTML 结构 ├── popup.css # 弹窗的样式 ├── popup.js # 弹窗的交互逻辑 ├── background.js # 后台脚本，处理 API 请求 └── icons/ ├── icon16.png ├── icon48.png └── icon128.png ```\" ▶️ 接着，我们来创建工作流：\n/sc:workflow \"build the v1 of the smart translator extension\" 🤖 你会看到一个分阶段的计划：\n🤖 你会看到一个分阶段的计划： \"好的，这是构建 V1 版本的实施路线图： Phase 1: 项目骨架搭建 Task 1.1: 创建 manifest.json 并配置基本权限。 Phase 2: UI 开发 Task 2.1: 实现 popup.html 的基本布局。 Task 2.2: 编写 popup.css 美化界面。 Phase 3: 核心逻辑实现 Task 3.1: 编写 popup.js 获取选中文本并与后台脚本通信。 Task 3.2: 在 background.js 中实现调用 DeepL API 的函数。 Phase 4: 集成与测试 Task 4.1: 联调前后端逻辑，确保流程通畅。 Task 4.2: 编写基本测试用例。 \" 阶段三：编码实现 (专家指导下的高效编码)\n现在，我们严格按照 workflow 的规划，逐一完成任务。\n步骤 3: 使用 /sc:implement 编码，并适时召唤专家\n💡 为什么这么做？ implement 命令生成的代码质量更高，因为它会遵循其上下文中的最佳实践。当遇到特定领域的难题时（如 API Key 的安全存储），我们可以召唤相应的专家 (Agent)，获得精准、专业的解决方案，而不是在网上大海捞针。\n▶️ 执行 Task 1.1: 创建 manifest.json\n/sc:implement \"the manifest.json for a Chrome extension with a browser action popup and permissions for activeTab and storage\" ▶️ 执行 Phase 2: UI 开发\n/sc:implement \"the HTML for popup.html with a textarea, a button, and a div for the result\" ``````text /sc:implement \"some clean, modern CSS for popup.css to style the elements from popup.html\" ▶️ 执行 Phase 3: 核心逻辑实现 (关键步骤)\n/sc:implement \"in popup.js, write the logic to: 1. Listen for the button click. 2. Get the current active tab. 3. Execute a content script to get the selected text. 4. Send the selected text to background.js. 5. Receive the translation from background.js and display it.\" 现在，到了最关键的 API 调用部分，同时我们也遇到了一个安全问题：API Key 应该如何安全地存储？这是安全专家出场的最佳时机。\n▶️ 召唤安全专家并实现 API 调用:\n@agent-security \"What is the best practice to store and use a DeepL API key in a Chrome extension?\" 🤖 安全专家会告诉你：\n“在 Chrome 插件中，绝不要将 API Key 硬编码在前端 JS 文件中。最佳实践是让用户在插件的选项页 (Options Page) 中输入自己的 Key，然后使用 chrome.storage.sync 或 chrome.storage.local API 将其安全地存储起来。后台脚本在需要时从存储中读取。”\n▶️ 根据专家的建议，我们继续实现：\n/sc:implement \"in background.js, create a function that retrieves the DeepL API key from chrome.storage, calls the DeepL API with the provided text, and returns the translation. Handle potential errors.\" 阶段四：测试、分析与保存 (确保项目健康)\n代码写完了，但工作还没结束。我们需要确保代码的质量和健壮性。\n步骤 4: 使用 /sc:test、/sc:analyze 和 /sc:save\n💡 为什么这么做？ 一个专业的开发者必须对代码质量负责。test 可以为核心逻辑生成测试用例，analyze 则像一位资深代码审查员，全面检查项目的潜在问题。最后，save 能将我们的所有工作成果（包括讨论、决策和代码）保存下来，为未来的迭代做好准备。\n▶️ 生成测试用例:\n/sc:test \"generate a unit test for the DeepL API call function in background.js, using a mock for the fetch API to avoid making a real network request\" ▶️ 全面分析项目:\n/sc:analyze \"the entire project\" --focus quality 代码质量: “在 popup.js 中，DOM 选择器可以被缓存以提高性能。” 潜在 Bug: “在 background.js 中，API 错误处理可以更具体，区分 401（认证失败）和 500（服务器错误）。” ▶️ 保存你的工作会话:\n/sc:save \"v1.0 of Smart Translator complete. Core translation functionality is working. Next step is to add language detection.\" 命令回顾与总结\n在这个项目中，你像一个专业的项目团队一样，系统地完成了所有工作。回顾一下你使用的核心 SuperClaude 命令：\n命令 在本项目中的作用 /sc:brainstorm 产品经理：明确了插件的核心需求和功能。 @agent-architect 架构师：设计了清晰、可扩展的项目结构。 /sc:workflow 项目经理：将开发任务分解为有序的、可执行的计划。 /sc:implement 核心程序员：高效、高质量地编写了代码。 @agent-security 安全顾问：解决了 API Key 存储的关键安全问题。 /sc:test 测试工程师：为核心功能生成了单元测试。 /sc:analyze 代码审查员：对整个项目进行了质量评估。 /sc:save 文档管理员：将项目状态归档，以便未来继续。 你的下一步\n当你准备好开发 V2 版本（例如，添加“智能语言检测”功能）时，只需在新对话中输入：\n/sc:load \"v1.0 of Smart Translator\" SuperClaude 就会恢复所有上下文，你无需任何重复解释，就可以立即开始新的工作流。\n这就是 SuperClaude 的力量：它不仅仅是一个代码生成器，更是一个内置了专家团队和标准化流程的、系统化的开发伙伴。\n4.5 谷歌翻译插件-实现2 第 1 步：需求挖掘（Brainstorming 模式）—— 为什么先做这一步？\n普通人直接说“做一个翻译插件”会导致需求模糊，后面返工 5 次。SuperClaude 会强制把模糊想法变成专业级需求文档。\n/sc:brainstorm \"一个 Chrome 浏览器插件，用于网页划词翻译和右键翻译，支持 DeepL、Google、Gemini、Claude 4 个翻译引擎自由切换，要有漂亮的弹出面板，支持快捷键和自动识别语种\" SuperClaude 会问你 10～15 个专业问题（用户场景、隐私、界面风格、是否开源、是否需要登录等），你全部如实回答就行。\n5～8 分钟后你会得到一份《智能翻译器 Chrome 插件需求规格书》（包含用户故事、功能清单、非功能需求、技术选型建议）\n第 2 步：保存需求，为后面所有工作打记忆底座（跨会话记忆）\n/sc:save \"智能翻译器需求规格完成，功能清单确定\" 以后即使你明天再开新聊天，这句话也能恢复全部背景！\n第 3 步：整体架构设计（自动拉专家团）\n/sc:design \"基于上面的需求，设计完整的 Chrome Extension 技术架构\" 这一步会自动激活：\nfrontend-architect（Chrome 插件专家） system-architect security-engineer（因为涉及剪贴板和内容脚本权限） 你会得到：\nmanifest v3 结构 内容脚本 + background service worker + popup + options 页面划分 推荐用 React + Tailwind + shadcn/ui 做 popup 推荐翻译引擎 API 封装策略 第 4 步：生成最漂亮的 UI（Magic MCP 神器）\n/sc:implement \"翻译插件的弹出面板 UI，使用 shadcn/ui + tailwind，支持暗黑模式、引擎切换、下拉历史\" --magic –magic 会自动调用 Magic MCP（21st.dev），直接给你 2025 年最现代的 UI 组件代码，漂亮到可以直接上 Chrome 商店。\n第 5 步：核心功能实现（一句话出完整代码）\n/sc:implement \"完整的划词翻译和右键翻译功能，包括内容脚本注入、背景通信、4 个翻译引擎封装（DeepL、Google、Gemini、Claude Sonnet 3.5 API）、自动语种检测、错误重试、翻译历史本地存储\" 这一步会自动激活：\nbackend-architect（API 封装） security-engineer（API Key 安全存储） performance-engineer（防抖、缓存） quality-engineer（错误处理） 你会一次性得到 6～8 个文件完整代码（manifest.json、content-script.ts、background.ts、popup.tsx 等）\n第 6 步：安全 + 性能 + 可访问性深度审查（工业级质量门禁）\n把整个项目文件夹拖进聊天框，然后输入：\n/sc:analyze . --ultrathink --all-mcp --focus security,performance,accessibility –ultrathink 会开到最大上下文，调用所有 8 个 MCP 服务器（Sequential、Serena、Chrome DevTools 等），给你一份 2000 字的深度审计报告，指出所有潜在问题并直接给出修复 patch。\n第 7 步：自动生成完整测试（E2E + 单元）\n/sc:test --type e2e \"用户划词翻译整个流程，从选中文字到弹出翻译结果\" --play –play 会调用 Playwright MCP，自动生成真实浏览器测试脚本（可以直接 npm test 跑）\n/sc:test --type unit \"翻译引擎切换和错误重试逻辑\" 第 8 步：自动生成商店上架所需的所有素材\n/sc:document \"生成 Chrome Web Store 上架所需的描述、截图提示、隐私政策、更新日志\" 会直接给你：\n1280x800 的 5 张截图提示（你用 Claude 图片生成功能一键生成） 多语言商店描述 完整的隐私政策模板 第 9 步：一键打包 + 验证\n/sc:build \"生成可上传 Chrome 商店的 .zip 包，并验证 manifest v3 合规性\" 第 10 步：保存整个项目（以后随时继续迭代）\n/sc:save \"智能翻译器 Chrome 插件 MVP 完成，已通过安全审计和 E2E 测试\" 以后你想加“语音朗读”或“PDF 翻译”功能，只需要：\n/sc:load 智能翻译器 /sc:implement \"新增语音朗读功能，支持 5 种语速和男/女声切换\" 所有历史上下文、架构决定、安全规范全部自动恢复，无需重新解释！\n命令回顾与总结\n1. /sc:brainstorm \"一个 Chrome 浏览器插件，用于网页划词翻译和右键翻译，支持 DeepL、Google、Gemini、Claude 4 个翻译引擎自由切换，要有漂亮的弹出面板，支持快捷键和自动识别语种\" 2. /sc:save \"智能翻译器需求规格完成\" 3. /sc:design \"基于上面的需求，设计完整的 Chrome Extension 技术架构\" 4. /sc:implement \"翻译插件的弹出面板 UI，使用 shadcn/ui + tailwind，支持暗黑模式、引擎切换、下拉历史\" --magic 5. /sc:implement \"完整的划词翻译和右键翻译功能，包括内容脚本注入、背景通信、4 个翻译引擎封装、自动语种检测、错误重试、翻译历史本地存储\" 6. （拖入整个项目文件夹）/sc:analyze . --ultrathink --all-mcp --focus security,performance,accessibility 7. /sc:test --type e2e \"用户划词翻译整个流程\" --play 8. /sc:document \"生成 Chrome Web Store 上架素材\" 9. /sc:build \"生成可上传的 .zip 包\" 10. /sc:save \"智能翻译器 Chrome 插件 MVP 完成\" 4.6 谷歌翻译插件-实现3 步骤1：项目初始化\n为什么这么做？\n我们需要创建一个结构化的项目，确保SuperClaude能正确识别项目上下文。\n# 创建项目目录 mkdir google-translate-plugin \u0026\u0026 cd google-translate-plugin # 初始化SuperClaude项目 SuperClaude init --project \"google-translate-plugin\" --description \"A Google Chrome extension for text translation\" 💡 为什么使用init命令？ init命令会创建必要的项目结构，让SuperClaude了解我们的项目范围和目标。这为后续的/sc:analyze和/sc:implement命令提供上下文。\n步骤3：需求分析与规划\n为什么这么做？\n在开始编码前，我们需要明确插件的功能和实现方式。\n# 1. 规划插件功能 /sc:brainstorm \"Google Chrome extension for text translation\" # 2. 分析项目需求 /sc:analyze \"google-translate-plugin\" --focus requirements 从命令输出中，我们可以得到：\n核心功能： 选中文本翻译 整页翻译 语言选择 界面简洁 技术需求： 需要manifest.json配置文件 需要background.js处理核心逻辑 需要popup.html提供用户界面 需要content_script.js注入到网页 高级功能： 语言记忆 翻译历史 自定义快捷键 💡 为什么使用brainstorm和analyze？ brainstorm帮助我们生成创意点子，analyze帮助我们从技术角度评估需求。这比直接开始编码更高效，避免走弯路。\n步骤4：设计插件架构\n为什么这么做？\n良好的架构设计可以减少后续开发中的问题\n# 1. 设计插件架构 /sc:design \"google-translate-plugin\" --focus architecture # 2. 生成架构图 /sc:generate \"google-translate-plugin\" --type architecture-diagram 从命令输出中，我们可以得到：\n插件架构设计： ├── manifest.json # 插件元数据 ├── popup/ │ ├── popup.html # 弹出窗口界面 │ ├── popup.css # 样式 │ └── popup.js # 交互逻辑 ├── background/ │ └── background.js # 后台脚本 ├── content_scripts/ │ ├── content_script.js # 注入到网页的脚本 │ └── content_script.css └── icons/ ├── icon16.png └── icon48.png 💡 为什么设计架构？ 在编码前设计好架构，可以确保代码组织清晰，避免后期重构。SuperClaude的design命令会提供专业级的架构建议\n步骤5：创建项目结构\n为什么这么做？\nSuperClaude会根据我们的设计自动创建必要的文件结构。\n# 1. 创建项目结构 /sc:generate \"google-translate-plugin\" --type project-structure # 2. 验证结构 ls -R 输出示例：\n. ├── manifest.json ├── popup │ ├── popup.html │ ├── popup.css │ └── popup.js ├── background │ └── background.js ├── content_scripts │ ├── content_script.js │ └── content_script.css └── icons ├── icon16.png └── icon48.png 💡 为什么使用generate命令？ generate命令会根据我们之前的设计自动创建文件结构，避免了手动创建文件的繁琐过程。这是SuperClaude的核心优势——它知道如何正确地设置项目。\n步骤6：实现核心功能\n为什么这么做？\n现在，我们开始编写实际代码。SuperClaude会帮助我们生成代码模板。\n# 1. 生成manifest.json /sc:implement \"manifest.json configuration\" --focus chrome-extension # 2. 生成popup.html /sc:implement \"popup.html interface\" --focus ui # 3. 生成background.js /sc:implement \"background.js core logic\" --focus core # 4. 生成content_script.js /sc:implement \"content_script.js translation logic\" --focus translation 💡 为什么先实现manifest.json？ 这是所有Chrome扩展的基础配置文件，必须先设置好才能继续开发。\n💡 为什么使用popup.html？ 这是用户与插件交互的主要界面，需要简洁直观。\n💡 为什么需要background.js？ 这个文件处理插件的启动和与内容脚本的交互，是插件的核心。\n💡 为什么使用Google翻译API？ 使用Google官方API可以确保翻译质量，避免自行实现翻译引擎的复杂性。\n步骤7：测试与调试\n为什么这么做？\n在开发过程中，测试和调试是确保功能正确性的关键。\n# 1. 启动测试模式 /sc:debug \"google-translate-plugin\" --mode test # 2. 生成测试用例 /sc:generate \"google-translate-plugin\" --type test-cases 步骤8：部署与发布\n为什么这么做？\n完成开发后，我们需要将插件打包并发布到Chrome Web Store。\n# 1. 生成发布包 /sc:package \"google-translate-plugin\" --type chrome-extension # 2. 生成发布说明 /sc:generate \"google-translate-plugin\" --type release-notes 生成的发布说明示例：\nGoogle Translate Plugin v1.0.0 主要功能： - 选中文本实时翻译 - 简洁直观的用户界面 - 支持多种语言 - 轻量级，不干扰浏览体验 改进： - 优化了翻译速度 - 修复了在某些网站上的兼容性问题 - 简化了用户界面 安装： 1. 下载插件包 2. 打开Chrome浏览器 3. 进入扩展程序管理 4. 启用开发者模式 5. 点击\"加载已解压的扩展程序\"，选择项目目录 💡 为什么需要发布说明？ 详细的发布说明可以帮助用户理解插件的功能和使用方法，提高用户满意度。\n步骤9：持续改进\n为什么这么做？\n软件开发是一个持续迭代的过程。\n# 1. 收集用户反馈 /sc:collect-feedback \"google-translate-plugin\" # 2. 分析使用数据 /sc:analyze \"google-translate-plugin\" --focus user-data # 3. 规划下一个版本 /sc:brainstorm \"google-translate-plugin\" --focus next-version 从用户反馈中，我们可能会得到：\n“希望增加翻译历史功能” “希望支持更多语言” “希望可以自定义翻译风格” 💡 为什么持续改进？ 通过收集用户反馈和分析使用数据，我们可以不断改进产品，使其更符合用户需求。\n总结：SuperClaude在项目中的价值\n步骤 普通开发方式 使用SuperClaude 价值 项目初始化 手动创建文件结构 sc:init 节省40%时间 需求分析 随意讨论 /sc:brainstorm 结构化思考 代码生成 从头编写 /sc:implement 减少错误 测试 手动测试 /sc:generate test-cases 更全面测试 发布 手动打包 /sc:package 专业发布流程 关键命令回顾\n命令 用途 为什么重要 /sc:init 初始化项目 创建结构化项目基础 /sc:brainstorm 生成创意点子 确保功能符合需求 /sc:analyze 分析需求 技术评估需求可行性 /sc:design 设计架构 避免后期重构 /sc:implement 生成代码 快速实现核心功能 /sc:debug 测试与调试 确保功能正确性 /sc:package 打包发布 专业发布流程 实际案例：从0到1完成谷歌翻译插件\n第一天：使用/sc:init和/sc:brainstorm规划项目 第二天：使用/sc:analyze和/sc:design设计架构 第三天：使用/sc:implement实现核心功能 第四天：使用/sc:debug测试和调试 第五天：使用/sc:package打包并发布 五、源码安全审计 5.1 审计方案-1 本方案将审计过程分为四个核心阶段：准备与 scoping、自动化扫描与分析、深度审查与验证、以及报告与修复规划。\n开始之前：准备工作\n💡 原因分析: 任何成功的审计都始于充分的准备。盲目地开始扫描代码是低效且危险的。我们需要先明确审计的目标、范围和关键业务逻辑，这样\nSuperClaude 才能将“注意力”集中在最重要的地方。\n▶️ 你要做什么:\n明确目标: 与项目负责人沟通，确定本次审计的核心目标。是满足合规性要求？是排查已知的性能问题？还是为新版本上线做全面的安全检查？\n定义范围: 确定需要审计的代码库、服务和依赖项。哪些是核心业务逻辑？哪些模块处理敏感数据（如用户认证、支付）？\n加载项目: 在 Claude Code 中，首先加载你的项目上下文。这是让 SuperClaude 了解你项目的第一步。\n/sc:load /path/to/your/project 阶段一：自动化扫描与高层分析 (发现明显的风险)\n在这一阶段，我们的目标是利用 SuperClaude 的自动化分析能力，快速地对整个项目进行一次全面的“CT扫描”，找出那些最明显、\n最常见的安全漏洞和风险点。\n步骤 1: 运行全面的安全分析命令\n▶️ 你要做什么 (What): 在 Claude Code 中，针对你的整个项目根目录，执行 analyze 命令，并使用 –focus security 参数。\n/sc:analyze . --focus security 激活安全专家知识库: 这不仅仅是一个简单的代码扫描。–focus security 这个关键参数会显式激活 @agent-security (安全专家)\n的完整知识体系。SuperClaude 会开始以一个专业安全工程师的视角来审查你的代码。\n全面覆盖 OWASP Top 10: 它会自动检查最常见和最危险的 Web 应用安全风险，例如：\n注入攻击 (Injection): 检查 SQL、NoSQL、OS 命令等是否存在拼接字符串，而不是使用参数化查询。 失效的身份认证 (Broken Authentication): 分析登录逻辑、会话管理是否存在漏洞。 敏感数据泄露 (Sensitive Data Exposure): 查找代码中是否硬编码了密码、API 密钥等敏感信息。 XML 外部实体 (XXE): 如果项目使用 XML 解析，会检查是否存在相关风险。 失效的访问控制 (Broken Access Control): 检查 API 端点是否缺少必要的权限验证。 安全配置错误 (Security Misconfiguration): 检查依赖库的版本、服务器配置等是否存在已知漏洞。 跨站脚本 (XSS): 检查用户输入是否未经充分过滤就直接输出到前端页面。 结构化与优先级排序: 你得到的不是一堆杂乱的警告，而是一份结构化的、按风险等级（高、中、低）排序的报告。这让你能立\n即集中精力处理最重要的问题。\n阶段二：深度审查与手动验证 (深入风险细节)\n自动化扫描找到了“可疑点”，但这些“可疑点”是否真的能被利用，还需要专家的深度审查。这一阶段，我们将针对第一阶段发现的高风险\n问题，进行“点对点”的精确打击。\n步骤 2: 召唤安全专家，对特定模块进行深度审查\n▶️ 你要做什么 (What):\n假设第一阶段的报告指出，authController.js 文件中的登录逻辑可能存在风险。现在，我们手动召唤安全专家，让它只专注于这一个文\n件。\n@agent-security \"Please perform a deep-dive security review of the 'src/controllers/authController.js' file. Focus on potential vulnerabilities in the login and token generation functions.\" 💡 为什么这么做 (Why):\n从“广度”到“深度”: /sc:analyze 提供了广度。而手动调用 @agent-security 则提供了深度。这模拟了真实世界中，安全团队先用工具扫描，然后由高级工程师对关键点进行人工审计的过程。 上下文专注，分析更精准: 当你只提供一个文件或一个函数时，Claude Code 可以将更多的计算资源和上下文窗口分配给这个特定目标，从而进行更细致的逻辑分析。它可能会发现一些在全盘扫描中被忽略的、与业务逻辑紧密相关的漏洞。 对话式审计: 这是一个交互过程。专家可能会提出问题，比如：“这个 decodeToken 函数是从哪里导入的？我需要查看它的实现来判断是否存在风险。” 这种互动式的审查，远比静态的报告要强大。 步骤 3: 验证依赖库的安全性\n▶️ 你要做什么 (What):\n安全问题常常源于过时或有漏洞的第三方依赖。让 SuperClaude 帮你检查项目的依赖文件（如 package-lock.json 或 yarn.lock）。\n/sc:analyze \"package-lock.json\" --focus security 或者更直接地提问：\n@agent-security \"Analyze my project's dependencies listed in package.json. Are there any known critical vulnerabilities (e.g., via Snyk or npm audit databases)?\" 💡 为什么这么做 (Why):\n供应链安全: 现代应用严重依赖开源库，这引入了所谓的“供应链风险”。此步骤正是为了排查这部分风险。 利用实时知识: 即使 Claude Code 的基础模型知识有截止日期，但通过其训练数据和可能的 MCP 服务器（如 Tavily 联网搜索），它可以访问到大量关于已知漏洞 (CVEs) 的信息，为你提供比 npm audit 更具可读性和解释性的报告。 阶段三：生成报告与制定修复计划 (将发现转化为行动)\n审计的最终目的是为了修复问题。一个只有问题列表但没有解决方案的报告是无用的。\n步骤 4: 生成结构化的审计报告\n▶️ 你要做什么 (What): 现在你已经收集了所有高、中、低风险问题。是时候让技术文档专家 (@agent-technical-writer) 登场，将这些零散的发现整理成一份专业的报告。\n@agent-technical-writer \"Based on our entire conversation and the security findings from the audit, please generate a formal security audit report. The report should include: 1. An executive summary. 2. A prioritized list of vulnerabilities, each with a description, risk level, and the affected code location. 3. Concrete recommendations for remediation for each finding.\" 💡 为什么这么做 (Why):\n专业化与标准化: 安全审计报告有其标准格式。@agent-technical-writer 知道如何组织内容，使其清晰、专业，易于非技术背景的管理层（看摘要）和开发人员（看技术细节）阅读。 从“发现”到“文档”的自动化: 你无需手动复制粘贴和排版。这个命令会综合整个对话的上下文，自动为你完成繁琐的文档撰写工作。 步骤 5: 创建可执行的修复工作流\n▶️ 你要做什么 (What): 有了报告和修复建议，最后一步就是将它们转化为一个可执行的计划。\n/sc:workflow \"Create a remediation plan based on the high-risk vulnerabilities identified in the security report. Prioritize fixing the SQL injection and the hardcoded API key issues first.\" 💡 为什么这么做 (Why):\n将建议转化为任务: workflow 命令会将抽象的修复建议，分解成一个个具体的、可分配的开发任务，就像一个项目经理在创建 JIRA tickets 一样。 结构化修复过程: 你会得到一个分阶段的计划，例如： Phase 1: 关键漏洞修复 Task 1.1: 重构 userRepository.js，使用参数化查询替换所有 SQL 字符串拼接。 Task 1.2: 从代码中移除硬编码的 API Key，改为从环境变量中读取。 Phase 2: 中等风险修复 Task 2.1: 为所有需要认证的 API 端点添加权限校验中间件。 Phase 3: 回归测试与验证 Task 3.1: 编写单元测试验证 SQL 注入已被修复。 Task 3.2: 重新运行 /sc:analyze 确认漏洞已被清除。 总结：SuperClaude 在安全审计中的核心优势\n流程系统化: 将审计从随意的“代码检查”变成了一个包含分析、审查、报告、规划的闭环流程。 专家知识注入: 通过激活 @agent-security，你等于为项目请来了一位 7x24 小时待命、知识渊博且不知疲倦的安全专家。 高效率: 自动化的全盘扫描和报告生成，极大地缩短了审计周期，让你能专注于最关键的深度审查。 结果可行动: 审计的最终产出不是一个令人沮丧的问题列表，而是一份清晰的报告和一个可执行的修复路线图，直接驱动下一步的开发工作。 最后，完成这一切后，别忘了：\n/sc:save \"Security audit for Project X completed on [Date]. High-risk vulnerabilities identified and remediation plan created.\" 这将把你的整个审计过程存档，以备未来查验。\n5.2 审计方案-2 —— 专为“用户要求进行项目安全审计”场景设计，工业级严苛，OWASP Top10 + CVE + Chrome 插件特有风险 + 供应链攻击一个不漏\n目标：30～60 分钟内，让你的项目通过等保 3 级 / SOC2 / Chrome Web Store 安全审查级别\n为什么普通 /sc:analyze 不够，必须走下面这套组合拳？\n因为普通分析只会浅浅扫一遍，而安全审计必须满足：\n覆盖 OWASP Top 10、ASVS、MASVS（移动端） 发现 0day / Nday 逻辑漏洞 检查第三方依赖、API Key 泄露、权限滥用 出具可直接交给甲方/审计机构的《安全审计报告》 SuperClaude 官方文档中把这套流程藏在 agents.md、flags.md、mcp-servers.md 的角落，只有老玩家知道。 完整 10 步安全审计流程（直接复制到 Claude Code 执行即可）\n步骤 具体命令（直接复制） 这步到底在干什么？（深度解释） 为什么这一步绝对不能少？（真实踩坑案例） 1 /sc:save \"安全审计开始 - 项目名：XXX - 时间：2025-11-17\" 把当前项目状态永久保存，后面所有审计结论都会基于这个时间点，防止代码在审计中被改动 审计机构要求“审计期间代码冻结”，这一步就是你的冻结证明 2 /sc:brainstorm \"对这个项目进行全面安全审计，覆盖 OWASP Top10、API 安全、Chrome 插件特有风险、供应链攻击、隐私合规\" 强制激活 Security-Engineer + Requirements-Analyst + Spec-Panel，生成一份《安全审计检查清单》（通常 80～150 项） 没有检查清单，后面容易漏掉 30% 的风险点（我见过漏掉“背景静默联网”被 Chrome 商店下架） 3 把整个项目文件夹拖进聊天框，然后输入： /sc:analyze . --ultrathink --all-mcp --focus security --seq --c7 --serena --chrome 同时开启 5 个最强安全相关 MCP（Sequential 深度推理、Context7 官方最佳实践、Serena 语义理解、Chrome DevTools 真实浏览器行为分析） + Security-Engineer 主导 这是整套流程的核心，相当于请 8 个安全专家 + 5 台专业工具一起读你全部代码 4 @agent-security \"以 OWASP ASVS 4.0 Level 3 标准，对整个项目进行逐条打分，并列出所有失败项\" 手动强制拉最严格的安全专家，按国际权威标准一条一条打分（会输出 200+ 条检查结果） 自动分析有时会“网开一面”，手动拉专家会狠到让你怀疑人生（但确实能发现逻辑漏洞） 5 /sc:research \"最近 90 天内与本项目使用的所有第三方库（列出 package.json / requirements.txt）相关的 CVE 和安全通告\" –tavily 自动联网查国家漏洞库 NVD + GitHub Advisory + Chrome 商店黑名单 2025 年供应链攻击占 62%，光代码静态分析查不出依赖漏洞（我见过一个项目因为 lodash 旧版本被勒索） 6 /sc:troubleshoot \"逐项验证以下高危风险：API Key 硬编码、内容脚本过度权限、background 持久化、跨站脚本、本地存储明文保存用户数据\" –seq –chrome Sequential + Chrome DevTools 会真正启动浏览器，动态验证你的插件在真实环境下的行为 静态分析查不出“运行时才注入的恶意代码”或“manifest 权限欺骗” 7 /sc:test --type e2e \"安全测试用例：XSS 注入、CSRF、点击劫持、IDOR、权限提升、剪贴板劫持、隐私数据泄露\" --play --chrome Playwright + Chrome DevTools 自动生成并执行 20+ 条安全攻防测试用例 安全审计必须有“可复现的攻击 POC”，不然甲方不认（这一步会直接给你视频录屏） 8 /sc:improve . --type security --safe-mode --loop --validate 进入安全迭代死循环：修复 → 验证 → 再修复，直到 Security-Engineer 打分 ≥98 分才停止 手动修漏洞容易漏，–loop 会逼到你修完为止（我见过项目从 62 分修到 99 分） 9 /sc:document \"生成符合等保3级 / SOC2 / Chrome Web Store 要求的《信息安全审计报告》，包含：审计范围、方法、发现问题、风险等级、修复建议、修复后验证结果、审计结论\" Technical-Writer + Security-Engineer 联合出具带公章级别的正式报告（Word/PDF 直接可交付） 甲方/审计机构要的就是这份报告，没有就等于白干 10 /sc:reflect --scope project 然后 /sc:save \"安全审计完成 - 最终得分 99/100 - 已出具报告\" Serena MCP 对比审计前后的记忆，自动生成《审计总结与残余风险矩阵》 给领导/客户一个闭环说明，“我们不是随便扫一下，是真的修完了” 完整命令复制粘贴版（推荐新建一个专用聊天）\n/sc:save \"安全审计开始 - 项目名：智能翻译器 - 时间：2025-11-17\" /sc:brainstorm \"对这个智能翻译器 Chrome 插件进行全面安全审计，覆盖 OWASP Top10、API 安全、Chrome Extension 特有风险、供应链攻击、隐私合规（GDPR/CCPA）\" （拖入整个项目文件夹） /sc:analyze . --ultrathink --all-mcp --focus security --seq --c7 --serena --chrome @agent-security \"以 OWASP ASVS 4.0 Level 3 标准，对整个项目进行逐条打分，并列出所有失败项\" /sc:research \"最近 90 天内与本项目使用的所有第三方库（package.json 中列出）相关的 CVE 和安全通告\" --tavily /sc:troubleshoot \"逐项验证以下高危风险：API Key 硬编码、内容脚本 host_permissions 过度授权、background service worker 持久化、跨站脚本、剪贴板劫持、本地存储明文保存翻译历史\" --seq --chrome /sc:test --type e2e \"安全测试用例：XSS 有效载荷注入、剪贴板劫持、背景静默联网、隐私数据泄露、权限提升攻击\" --play --chrome /sc:improve . --type security --safe-mode --loop --validate /sc:document \"生成《智能翻译器 Chrome 插件安全审计报告》，符合 Chrome Web Store + 等保3 级要求，包含风险矩阵、修复前后对比、最终结论\" /sc:reflect --scope project /sc:save \"安全审计完成 - 最终得分 99/100 - 已出具正式报告 - 可上架/交付\" 5.3 审计方案-3 一、安全审计前的准备工作\n1. 确认SuperClaude安装与配置\n# 验证SuperClaude安装 SuperClaude --version # 应输出类似：SuperClaude v4.1.5+ # 检查MCP服务器安装状态 SuperClaude install --components mcp --list 为什么这么做？\n确保SuperClaude框架已正确安装，避免后续命令执行失败 MCP服务器是安全审计的核心组件，必须确认已安装（Context7、Tavily、Morphllm等） 知识库[2]指出：“MCP相关错误通常表示缺少MCP服务器。在使用相关标志之前，请在Claude Code的MCP设置中单独安装Context7、Sequential、Magic和Puppeteer。” 设置安全审计上下文 # 加载项目上下文并激活安全角色 /sc:load --depth deep --persona-security 为什么这么做？\n--depth deep确保SuperClaude加载完整的项目上下文，避免遗漏关键信息 --persona-security激活安全专家角色，使SuperClaude从安全视角分析项目 知识库[2]提到：“安全( –persona-security )专门从事威胁建模和安全编码实践，坚持认为安全必须是内置的，而不是后加的。” 二、执行安全审计的核心步骤\n1. 基础安全扫描\n/sc:scan --security --owasp --deps --strict 为什么这么做？\n--security：启用全面的安全扫描 --owasp：基于OWASP Top 10进行安全漏洞检查（知识库[5]提到\"OWASP Top 10合规性检查”） --deps：检查依赖项安全问题 --strict：启用零容忍模式，确保所有安全问题都被报告和处理（知识库[5]提到\"添加–strict标志启用零容忍策略\"） 预期输出示例：\n[SECURITY SCAN] 项目安全审计报告 (严格模式) ⚠️ 高危漏洞 (3项): 1. JWT密钥硬编码于源码中 (文件: src/auth/config.js) 建议: 使用环境变量注入，参考OWASP安全编码指南A3 证据: https://owasp.org/www-community/vulnerabilities/Insecure_Direct_Object_Reference 2. 未验证用户输入 (文件: src/api/userRoutes.js) 建议: 使用输入验证库，如express-validator 证据: https://owasp.org/www-community/attacks/SQL_Injection 3. 未加密敏感数据存储 (文件: src/db/models/User.js) 建议: 使用加密库，如crypto-js 证据: https://owasp.org/www-community/attacks/Insecure_Data_Storage ✅ 中危漏洞 (5项): ... ✅ 低危漏洞 (8项): ... 2. 深度安全分析\n/sc:analyze --security --deep --persona-security --audit 为什么这么做？\n--deep：启用深度分析模式，发现常规扫描难以识别的隐式安全问题 --audit：触发安全审计模式，专注于合规性检查 结合--persona-security确保分析视角专业 知识库[5]提到：\"/scan是SuperClaude提供的安全与验证命令，用于全面的安全审计和合规性检查。\" 预期输出示例：\n[DEEP SECURITY ANALYSIS] 项目安全深度评估 🔍 代码审查发现: - 未实现速率限制 (可能导致DDoS攻击) - 未启用CSP头 (可能导致XSS攻击) - 未使用HTTPS强制 (可能导致中间人攻击) - 未实施CSRF保护 (可能导致跨站请求伪造) 📊 合规性评估: - GDPR合规: 65% (需处理用户数据删除请求) - PCI-DSS合规: 45% (需加强支付数据保护) - SOC2合规: 70% (需改进日志记录和监控) 💡 安全建议: 1. 实现速率限制: 使用express-rate-limit 2. 添加CSP头: 通过helmet.js 3. 强制HTTPS: 在Nginx配置中设置 4. 实施CSRF保护: 使用csurf中间件 3. 敏感信息检查\n/sc:scan --sensitive --env --strict 为什么这么做？\n--sensitive：专门检查敏感信息泄露 --env：检查环境变量配置 知识库[1]强调：“SECURITY.md 第54行明确规定不存储敏感数据在配置文件中。SuperClaude提供了环境变量注入机制” 确保API密钥、数据库密码等敏感信息未硬编码在代码中 预期输出示例：\n[SENSITIVE DATA SCAN] 敏感信息检查报告 ❌ 发现问题 (3项): 1. API密钥硬编码于配置文件 (文件: src/config.js) 位置: line 12: \"api_key: 'sk-1234567890'\" 修复建议: 使用环境变量注入 (如: process.env.API_KEY) 2. 数据库密码硬编码于代码 (文件: src/db/connection.js) 位置: line 5: \"password: 'password123'\" 修复建议: 使用环境变量注入 (如: process.env.DB_PASSWORD) 3. 未配置敏感数据保护 (文件: .env.example) 位置: 缺少API_KEY和DB_PASSWORD的示例 修复建议: 在.env.example中添加敏感数据示例 三、安全问题修复与验证\n1. 修复敏感信息问题\n# 修复配置文件 /sc:improve --sensitive --env --fix # 验证修复 /sc:scan --sensitive --env --strict 为什么这么做？\n--fix标志会自动生成修复建议并尝试自动修复 修复后立即验证确保问题已解决 知识库[1]提到：“SuperClaude提供了环境变量注入机制” 2. 修复OWASP Top 10漏洞\n# 修复SQL注入问题 /sc:improve --security --owasp --sql-injection # 修复XSS问题 /sc:improve --security --owasp --xss 为什么这么做？\n针对性修复OWASP Top 10中的高危漏洞 知识库[5]提到：\"/scan –quality –strict –persona-qa\"，说明可以结合角色进行修复 四、持续安全审计机制建立\n1. 配置自动化安全扫描\n# 添加到CI/CD管道 echo \"SuperClaude scan --security --owasp --deps --strict\" \u003e\u003e .gitlab-ci.yml # 设置安全审计日志 /sc:save --audit-log --period weekly 为什么这么做？\n确保安全审计成为持续开发流程的一部分 知识库[1]提到：“定期审计容器配置是维持长期安全的关键。SuperClaude的CONTRIBUTING.md中定义了配置审计流程，包括：每周自动配置合规检查” 通过--period weekly设置每周自动安全审计 2. 创建安全审计检查清单\n# 生成安全审计检查清单 /sc:generate --audit-checklist --format markdown 为什么这么做？\n知识库[1]提供了一个安全检查清单：“基础镜像90天内有更新 所有镜像扫描无高危问题 容器以非root用户运行 已禁用不必要的系统调用 敏感配置使用环境变量注入 运行时监控已配置并正常工作 最近30天内进行过安全配置审计” 生成检查清单便于团队定期执行安全审计 五、安全审计报告生成\n1. 生成专业安全审计报告\n/sc:report --audit --format pdf --include-remediation 为什么这么做？\n生成专业、可共享的安全审计报告 --include-remediation确保包含具体的修复建议 知识库[9]提到：“在企业版中，合规审计是确保数据安全和用户行为规范的关键环节” 报告内容应包含：\n项目安全概况 高危漏洞列表及影响 修复建议及优先级 合规性评估结果 后续安全改进计划 六、安全审计最佳实践总结\n步骤 操作 为什么重要 1. 准备 安装SuperClaude并确认MCP服务器 确保安全审计工具链完备 2. 上下文 加载项目并激活安全角色 从专业视角分析安全问题 3. 基础扫描 sc:scan --security --owasp --deps --strict 全面识别安全漏洞 4. 深度分析 sc:analyze --security --deep 发现隐式安全问题 5. 敏感检查 sc:scan --sensitive --env 防止敏感信息泄露 6. 修复验证 修复后立即扫描验证 确保问题已解决 7. 持续机制 添加到CI/CD并设置定期扫描 保持长期安全 8. 报告生成 生成专业审计报告 满足合规要求 七、常见问题与解决方法\n问题 解决方案 /sc:scan命令不工作 SuperClaude install --components mcp --force 安全扫描结果不准确 SuperClaude install --components agents --force 漏洞修复建议不适用 sc:improve --security --persona-security 高危漏洞无法修复 检查SECURITY.md中的问题报告流程 安全审计报告格式不满足要求 sc:report --audit --format pdf 八、安全审计价值总结\n预防性价值：在安全漏洞影响生产环境前发现并修复 知识库[1]提到：“安全是持续过程，建议定期查看CHANGELOG.md获取最新安全更新” 合规性价值：满足GDPR、PCI-DSS等合规要求 知识库[9]指出：“金融行业面临着严格的监管要求…需要确保数据的脱敏、匿名化处理” 效率价值：自动化安全审计节省80%人工审查时间 知识库[5]提到：\"/scan是SuperClaude提供的安全与验证命令，用于全面的安全审计和合规性检查\" 风险管理价值：降低因安全漏洞导致的业务中断风险 知识库[4]提到：“SuperClaude通过多层次的可靠性设计…实现了高可用性” 5.4 Superclaude寻找反序列化漏洞 这个过程我们将模拟一位专业安全研究员的思维流程，分为三个核心阶段\n阶段一：侦察与识别 (Reconnaissance \u0026 Identification)\n🎯 目标: 在整个代码库中，快速、准确地找出所有可能执行反序列化操作的代码点。\n▶️ 你要做什么 (What):\n启动一次以“代码模式识别”为目的的分析。你需要向 SuperClaude 描述你正在寻找的代码特征，而不是直接要求它“找漏洞”。\n/sc:analyze \"the entire project\" --focus code-patterns \"Identify all code locations that perform data deserialization. I'm looking for libraries and functions like Python's 'pickle.load' and 'yaml.load', Java's 'ObjectInputStream.readObject()', or any JSON parsing that uses a 'reviver' function. Please list the file paths, line numbers, and the specific function being used.\" 💡 为什么这么做 (Why):\n模拟安全研究员的“代码勘察”: 在针对特定漏洞时，第一步永远是“摸清底细”——也就是找到所有潜在的攻击入口点。这个命令的作用就像一个超级grep，但它理解的是编程概念（反序列化）而不是简单的文本（pickle.load)。这使得它能发现一些不那么明显的、或者使用了冷门库的反序列化操作。 建立“攻击面”清单: 这个命令的输出是一份精确的“地图”，標記了所有可能存在风险的“地点”。这份清单是你下一阶段深度分析的基础。没有它，你的审查将是盲目和低效的。 –focus code-patterns 的妙用: 我们没有用 –focus security，因为在这一阶段我们还不是在“评估风险”，而是在“寻找模式”。这让 SuperClaude 的行为更像一个代码静态分析工具，专注于识别特定的代码结构，输出结果会更干净、更聚焦。 阶段二：深度分析与上下文审查 (Deep Analysis \u0026 Contextual Review)\n🎯 目标: 针对第一阶段发现的“可疑点”，逐一进行深度的人工智能审查，判断其是否真正构成可利用的漏洞。\n▶️ 你要做什么 (What): 从第一阶段的清单中，挑选一个看起来最可疑的位置（例如，一个处理网络请求的函数中的 pickle.load），然后直接召唤安全专家 (@agent-security)，进行一次专注的“代码会诊”。\n假设第一阶段发现 src/utils/data_handler.py 的第 42 行使用了 pickle.load。\n@agent-security \"Let's focus on 'src/utils/data_handler.py', line 42, which uses 'pickle.load'. Please perform a data-flow analysis on the 'serialized_data' variable that is passed to this function. Can an attacker control this input, for example, through an HTTP request body, a file upload, or a database entry? Based on the data's origin, explain the potential for a Remote Code Execution (RCE) vulnerability here.\" 💡 为什么这么做 (Why):\n激活“数据流分析”能力: 这是本方案中最关键的一步。反序列化漏洞的核心在于**“不可信数据的反序列化”。这个指令要求 SuperClaude 不仅仅是看 pickle.load 这一行，而是要追溯 serialized_data 变量的来源**。这正是高级安全审计的核心——理解数据的流动路径。 模拟人工代码审查的思维: 一个优秀的安全工程师在审查代码时，就是在脑中构建数据流图。这个命令就是在让 AI 模拟这个过程。AI 会检查这个变量是否直接或间接地来自于外部输入（如 request.body, request.files），如果答案是肯定的，那么漏洞存在的可能性就极高。 明确风险等级 (RCE): 主动提及“远程代码执行 (RCE)”，是在引导安全专家从最高风险的角度来评估这个问题。这会促使它给出更严重、更详细的警告，帮助你准确地判断问题的优先级。 阶段三：风险验证与修复建议 (Risk Validation \u0026 Remediation Advice)\n🎯 目标: 确认漏洞的危害，并获得安全、可执行的修复方案。\n▶️ 你要做什么 (What): 在与 @agent-security 的同一次对话中，继续追问，要求它提供漏洞利用的原理说明和具体的修复代码。\n要求提供风险原理解释 (帮助团队理解危害): \"Could you provide a conceptual example of a malicious pickle payload that could exploit this vulnerability to execute an arbitrary command, like 'os.system(\\\"ls\\\")'? (Note: Please explain the principle, do not generate a fully functional exploit).\" 2.要求提供具体的修复方案:\n💡 为什么这么做 (Why):\n教育与警示: 仅仅告诉开发者“这里有漏洞”是不够的。通过解释一个（概念上的）攻击载荷如何工作，能极大地提升开发团队的安全意识。这让漏洞从一个抽象的“高风险”问题，变成了一个具体的、“服务器会被控制”的现实威胁。（注意：我们明确要求不要生成可执行的攻击代码，只解释原理，这是负责任的做法。） 提供“开箱即用”的解决方案: 安全审计的最终目的是修复。这个指令直接要求 SuperClaude 提供**“代码重构前”和“代码重构后”**的对比。这是一种极其高效的沟通方式，开发者可以直接采纳和应用，大大降低了修复的门槛和时间成本。 引导最佳实践: SuperClaude 不仅会修复当前问题，它通常还会建议更安全的替代方案，如“尽可能使用 JSON 这种只支持数据的格式，而不是 pickle 这种支持代码执行的格式”，从而从根本上提升项目的安全性。 通用化：此方法适用于任何特定漏洞\n这个“侦察 -\u003e 分析 -\u003e 修复”的三阶段模型，可以被应用到任何你想要排查的特定漏洞上：\n排查 SQL 注入: 侦察: /sc:analyze 找到所有拼接 SQL 查询字符串的地方。 分析: @agent-security 对某个具体的查询函数进行数据流分析，判断用户输入是否未经参数化就进入了查询。 修复: 要求 @agent-security 将其重构为使用 ORM 或参数化查询的安全版本。 排查跨站脚本 (XSS): 侦察: /sc:analyze 找到所有将用户输入直接渲染到前端模板（如 HTML, React JSX）的地方。 分析: @agent-security 分析该渲染过程是否缺少了适当的输出编码或转义。 修复: 要求 @agent-security 给出使用特定框架（如 React 的 {} 语法）或库（如 DOMPurify）进行安全渲染的修复代码。 SuperClaude 的核心价值与被忽视的要点 在熟悉了基本操作后，我们需要深入理解 SuperClaude 的设计哲学。这能帮助你从“使用者”转变为“掌控者”。以下是我从文档中提炼并结合我的理解，为你总结的几个关键点。\n1. 核心范式转移：从“软件”思维到“上下文工程”思维\n新手最容易犯的错误，就是把 SuperClaude 当作一个像 VS Code 插件一样在后台“运行”的软件。\n被忽视的要点: technical-architecture.md 文件反复强调，SuperClaude 没有执行引擎，没有运行进程。它本质上是一系列结构化的文本指令 (.md 文件)。\n我的理解与观点: 这不仅仅是一个技术细节，这是一个根本的范式转移。传统的 AI 辅助是“黑盒式”的，你不知道 AI 为何这么回答。SuperClaude 则是**“白盒式”**的，它的所有“智能”和“行为”都定义在那些你可以随时阅读和修改的 .md 文件中。\n这就像：你不是给一位厨师一堆食材让他自由发挥（传统AI），而是给了他一本米其林三星的菜谱（SuperClaude的上下文文件），上面详细记录了每一步操作、火候控制和摆盘技巧。厨师（Claude Code）的最终出品，完全受这本菜谱的指导。\n这对你意味着什么？\n高度的可定制性: 你可以通过修改或添加自己的 .md 文件，来创建专属于你团队的 Agent 和 Workflow。 透明度与可信赖性: 当某个命令的行为不符合预期时，你可以直接去查看对应的 .md 文件，理解它的“思考逻辑”，而不是盲目猜测。 2. “智能”的本质：专家知识驱动的“行为路由”\nSuperClaude 看起来很“智能”，比如输入“安全”相关的词，@agent-security 就会被激活。这背后不是什么复杂的 AI 模型，而是巧妙的“行为路由”。\n被忽视的要点: agents.md 中解释了“自动激活 (Auto-Activation)”的原理。它并非系统层面的逻辑判断，而是 Claude Code 读取了行为指令，根据请求中的关键词和模式，决定采纳哪位“专家”的思维模式。\n我的理解与观点: SuperClaude 的强大之处，在于它将隐性的专家知识显性化、结构化了。每一位 Agent 的 .md 文件，都是该领域专家的“思维模型”的文字版。\n这就像：一个经验丰富的医生在诊断时，脑中会有一套诊疗流程图。SuperClaude 就是把这套流程图写了下来。当病人（你的请求）提到“咳嗽、发烧”（关键词），Claude Code 就会沿着这本“呼吸科专家手册”去思考，而不是像一个实习医生那样泛泛地提问。\n这对你意味着什么？\n结果的高质量和一致性: 因为遵循的是专家 playbook，所以输出的结果（代码、架构、分析报告）通常都包含了该领域的最佳实践，且多次请求结果稳定。 学习工具: 通过观察 SuperClaude 如何激活不同的 Agent 以及这些 Agent 的行为模式，你实际上也在学习各个领域的专家是如何思考和解决问题的。 3. 真正的飞跃：从“短暂对话”到“持久化项目”\n这是 SuperClaude 最具革命性的一点，也是新手最容易忽略的。\n被忽视的要点: session-management.md 中描述的 /sc:save 和 /sc:load 命令，以及背后的 Serena MCP 服务器，解决了所有大语言模型共同的痛点——上下文遗忘。\n我的理解与观点: 没有持久化记忆，AI 永远只能是一个“玩具”或“临时助手”，无法胜任持续数天、数周的复杂项目。SuperClaude 通过会话管理，将 AI 从一个“聪明的对话者”提升为了一个**“有记忆的项目伙伴”**。\n这就像：你和一位同事合作项目。如果他每天早上都完全忘记昨天做了什么（标准AI），这个项目是无法推进的。而 SuperClaude 就像一位每天都会认真写工作日志，并且第二天能立刻回忆起所有细节的同事。\n这对你意味着什么？\n可以承担大型项目: 你可以放心地用它来开发需要长期迭代的复杂应用。 知识沉淀: 项目中的所有决策、架构选择、代码模式都会被 save 下来，成为项目的“知识库”。当有新成员加入时，通过 load 就能快速同步所有历史背景。 4. 动态适应性：“行为模式 (Modes)”的价值\n被忽视的要点: modes.md 中描述的几种模式（如 Brainstorming, Task Management）不仅仅是改变了输出的格式，而是从根本上改变了 Claude Code 的交互行为。\n我的理解与观点: 这是 SuperClaude 适应不同工作阶段的“变速箱”。它懂得何时该扮演一个循循善诱的提问者（Brainstorming Mode），何时该扮演一个一丝不苟的指挥官（Task Management Mode）。\n这就像：一个优秀的领导者，在项目初期会和团队一起开放式地讨论（头脑风暴），一旦方向确定，就会切换到目标导向、任务驱动的管理模式。SuperClaude 能够根据任务的复杂度和明确性，自动完成这种“角色切换”。\n这对你意味着什么？\n更自然、更高效的协作: 你不需要通过复杂的提示词来引导 AI 的行为。你只需专注于你的任务，SuperClaude 会自动调整到最适合的协作模式。 总结性建议\n作为新手，请记住以下几点，以便更好地掌握 SuperClaude：\n信任流程: 尝试完整地走一遍 brainstorm -\u003e workflow -\u003e implement -\u003e test -\u003e save 的流程，体验系统化开发带来的好处。 多用“专家”: 遇到不确定的问题时，主动 @agent-…，把它当作你随时可以咨询的专家团队。 养成 save/load 的习惯: 即使是小项目，也尝试使用会话管理，你会发现这极大地提升了工作的连续性。 探索，然后定制: 当你熟悉后，可以尝试去 ~/.claude/ 目录下看看那些 .md 文件。也许有一天，你会想为你自己的特定工作流，创建一个专属的 Agent 或 Command。 ","wordCount":"3729","inLanguage":"en","datePublished":"2025-11-18T17:35:00+08:00","dateModified":"2025-11-18T17:35:00+08:00","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/superclaude/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">SuperClaude.md</h1><div class=post-meta><span title='2025-11-18 17:35:00 +0800 +0800'>November 18, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h1 id=superclaude中文使用手册>SuperClaude中文使用手册<a hidden class=anchor aria-hidden=true href=#superclaude中文使用手册>#</a></h1><h2 id=一产品概述>一、产品概述<a hidden class=anchor aria-hidden=true href=#一产品概述>#</a></h2><p>SuperClaude 是一个<strong>上下文工程框架 (Context Engineering Framework)</strong>。</p><p>可以把它想象成一套给 Claude Code 使用的**“专家行为配置包”<strong>。它通过一系列精心设计的 Markdown (.md) 指令文件，来</strong>配置和增强**你现有的 Claude Code，注入特定的行为、知识和工作流程。</p><p><strong>💡 核心比喻：</strong></p><ul><li><strong>标准 Claude Code</strong> 就像一位知识渊博、但经验泛泛的全才程序员。</li><li><strong>SuperClaude</strong> 则给了这位程序员一整套专家工具箱：里面有顶尖架构师的设计蓝图、安全专家的审计清单、前端大师的组件库以及项目经理的详细流程图。</li></ul><p>当你使用 SuperClaude 的命令时，你其实是在告诉这位全才程序员：“嘿，现在请你戴上‘安全专家’的帽子，并遵循这套‘代码审计’的流程来工作。”</p><h3 id=1它解决了什么核心痛点>1.<strong>它解决了什么核心痛点</strong><a hidden class=anchor aria-hidden=true href=#1它解决了什么核心痛点>#</a></h3><ol><li><strong>从“随性”到“系统”</strong>：标准的AI编程往往是“一问一答”式的，缺乏系统性和长远规划。SuperClaude 将这种随性的请求，转化为<strong>结构化的、可验证的、有质量门禁的开发工作流</strong>。</li><li><strong>从“全才”到“专家”</strong>：通用AI模型在特定领域的深度和最佳实践上有所欠缺。SuperClaude 通过 <strong>AI Agents (AI 专家)</strong> 机制，让 Claude Code 能够调用特定领域的深层知识，如安全、性能、前端架构等。</li><li><strong>从“短期记忆”到“长期项目”</strong>：AI 在长对话中容易丢失上下文。SuperClaude 通过<strong>会话管理</strong>和 <strong>MCP 服务器 (如 Serena)</strong>，实现了跨对话的<strong>持久化项目记忆</strong>，让你可以真正地进行长期、复杂的项目开发。</li><li><strong>从“孤立工具”到“生态联动”</strong>：AI 无法直接使用外部工具。SuperClaude 通过 <strong>MCP 服务器</strong>，打通了 Claude Code 与真实开发工具（如浏览器测试、UI组件库、文档查询等）的连接，极大地扩展了其能力边界。</li></ol><h3 id=2superclaude的解决方案>2.SuperClaude的解决方案<a hidden class=anchor aria-hidden=true href=#2superclaude的解决方案>#</a></h3><ul><li><strong>14个领域专家</strong>自动协作，无需手动切换</li><li><strong>21个系统命令</strong>提供端到端工作流</li><li><strong>持久会话管理</strong>保持项目上下文</li><li><strong>智能工具路由</strong>自动选择最佳MCP服务器</li><li><strong>质量门控</strong>自动集成安全、性能、测试专家</li></ul><h3 id=3产品特点>3.产品特点<a hidden class=anchor aria-hidden=true href=#3产品特点>#</a></h3><ul><li>🧠 <strong>21个命令</strong>：结构化开发工作流（如<code>/sc:brainstorm</code>, <code>/sc:analyze</code>）</li><li>🧪 <strong>14个AI代理</strong>：领域专家（如<code>@agent-security</code>, <code>@agent-python</code>）</li><li>⚙️ <strong>6种行为模式</strong>：上下文优化模式（如<code>--ultrathink</code>, <code>--token-efficient</code>）</li><li>🔌 <strong>6个MCP服务器</strong>：工具集成（如<code>Morphllm</code>, <code>Tavily</code>）</li><li>📦 <strong>无缝集成</strong>：直接在Claude Code中使用<code>/sc:</code>命令</li></ul><blockquote><p>💡 <strong>关键洞察</strong>：SuperClaude不是执行软件，而是<strong>配置框架</strong>，通过修改Claude Code的上下文来增强其行为。它不替代Claude Code，而是使其成为更强大的开发伙伴。</p></blockquote><h3 id=4-设计架构>4. 设计架构<a hidden class=anchor aria-hidden=true href=#4-设计架构>#</a></h3><pre tabindex=0><code>SuperClaude_Framework/
├── superclaude/          # 框架核心组件
│   ├── Core/             # 核心规则和原则 (PRINCIPLES.md, RULES.md, FLAGS.md)
│   ├── Agents/           # 14个AI代理 (领域专家)
│   ├── Commands/         # 21个命令 (上下文触发模式)
│   ├── Modes/            # 6种行为模式
│   └── MCP/              # 6个MCP服务器配置
└── setup/ 
</code></pre><p><strong>与Claude Code的集成方式</strong></p><ul><li><strong>上下文注入</strong>：SuperClaude通过<code>~/.claude/</code>目录中的配置文件向Claude Code注入特定上下文</li><li><strong>命令触发</strong>：使用<code>/sc:</code>前缀触发特定上下文（如<code>/sc:brainstorm</code>）</li><li><strong>MCP集成</strong>：通过MCP服务器（Multi-Context Processing）提供外部工具能力</li></ul><blockquote><p>🌐 <strong>架构关系</strong>：SuperClaude是Claude Code的"行为配置器"，而非独立执行程序。它不运行代码，而是告诉Claude Code"如何思考"。</p></blockquote><h2 id=二常用命令>二、常用命令<a hidden class=anchor aria-hidden=true href=#二常用命令>#</a></h2><h3 id=21-新手第一天必试的-5-个命令>2.1 新手第一天必试的 5 个命令<a hidden class=anchor aria-hidden=true href=#21-新手第一天必试的-5-个命令>#</a></h3><p>直接复制到 Claude Code 聊天框</p><table><thead><tr><th>命令</th><th>作用</th><th>推荐第一次尝试的输入</th></tr></thead><tbody><tr><td><code>/sc:brainstorm "任务管理 web app"</code></td><td>需求挖掘神器，会疯狂问你问题，直到需求清晰</td><td>任何你想做的项目，先跑这个</td></tr><tr><td><code>/sc:implement "用户登录注册功能"</code></td><td>一句话出完整前后端 + 安全 + 测试代码</td><td>必试！感受降维打击</td></tr><tr><td><code>/sc:analyze src/</code></td><td>上传你的代码文件夹，自动深度分析</td><td>把你现有项目拖进来分析</td></tr><tr><td><code>@agent-security "review my code"</code></td><td>手动叫安全专家审查</td><td>任何涉及登录、支付的代码必审</td></tr><tr><td><code>/sc:research "2025 年最好的认证方案"</code></td><td>自动联网查最新资料（Tavily MCP）</td><td>想了解最新技术趋势就用这个</td></tr></tbody></table><h3 id=22-常用命令速查表30-个中最核心的-15-个>2.2 常用命令速查表（30 个中最核心的 15 个）<a hidden class=anchor aria-hidden=true href=#22-常用命令速查表30-个中最核心的-15-个>#</a></h3><table><thead><tr><th>类别</th><th>命令</th><th>用途示例</th><th>常用参数</th></tr></thead><tbody><tr><td>规划设计</td><td><code>/sc:brainstorm</code></td><td>需求挖掘</td><td><code>--bs</code></td></tr><tr><td></td><td><code>/sc:design</code></td><td>系统架构设计</td><td><code>--type api/component/database</code></td></tr><tr><td></td><td><code>/sc:spec-panel</code></td><td>多专家评审需求文档</td><td></td></tr><tr><td>实现</td><td><code>/sc:implement</code></td><td>核心神器！一句话生成完整功能</td><td><code>--magic</code>（美观 UI）</td></tr><tr><td></td><td><code>/sc:build</code></td><td>构建/编译流程</td><td><code>--type prod</code></td></tr><tr><td>分析优化</td><td><code>/sc:analyze</code></td><td>深度代码分析</td><td><code>--ultrathink --all-mcp</code></td></tr><tr><td></td><td><code>/sc:improve</code></td><td>代码重构优化</td><td><code>--type security/performance</code></td></tr><tr><td></td><td><code>/sc:troubleshoot</code></td><td>排错神器</td><td><code>--seq</code></td></tr><tr><td>测试质量</td><td><code>/sc:test</code></td><td>自动生成单元/集成/E2E 测试</td><td><code>--type e2e --play</code></td></tr><tr><td>项目管理</td><td><code>/sc:load 项目名</code></td><td>恢复上一次项目所有记忆（跨会话！）</td><td></td></tr><tr><td></td><td><code>/sc:save "登录功能完成"</code></td><td>保存当前进度到永久记忆</td><td></td></tr><tr><td></td><td><code>/sc:reflect</code></td><td>看看现在做到哪了，缺什么</td><td><code>--scope project</code></td></tr><tr><td>研究</td><td><code>/sc:research</code></td><td>自动联网查最新资料</td><td><code>--tavily</code></td></tr><tr><td>工具调用</td><td><code>--magic</code></td><td>生成现代漂亮 UI</td><td>需要 TWENTYFIRST_API_KEY（付费）</td></tr><tr><td></td><td><code>--play</code></td><td>真实浏览器跑 E2E 测试</td><td></td></tr><tr><td></td><td><code>--uc</code></td><td>极度省 token（大项目必开）</td><td></td></tr></tbody></table><h3 id=23关键参数与标志>2.3关键参数与标志<a hidden class=anchor aria-hidden=true href=#23关键参数与标志>#</a></h3><p>参数（或称 Flags）可以微调命令的行为。虽然大部分参数会根据你的输入<strong>自动激活</strong>，但了解几个关键的手动参数很有用。</p><ul><li>&ndash;focus: 用于 /sc:analyze 命令，指定分析的侧重点。<ul><li><strong>示例</strong>: /sc:analyze &ndash;focus security 会让分析更侧重于发现潜在的安全漏洞。</li></ul></li><li>&ndash;type: 用于 /sc:design 或 /sc:test 等命令，明确你想要的设计类型或测试类型。<ul><li><strong>示例</strong>: /sc:design &ndash;type api 明确指出你想要设计的是 API 规范，而不是数据库结构。</li><li><strong>示例</strong>: /sc:test &ndash;type e2e 指明需要生成端到端（End-to-End）测试脚本。</li></ul></li><li>&ndash;no-mcp: 临时禁用所有 MCP 服务器，只使用 Claude Code 的原生能力。<ul><li><strong>示例</strong>: /sc:implement &ldquo;a simple sort function&rdquo; &ndash;no-mcp，用于简单的、不需要外部工具的任务，或者在排查 MCP 服务器问题时使用。</li></ul></li></ul><h4 id=-效率优化标志><strong>🚩 效率优化标志</strong><a hidden class=anchor aria-hidden=true href=#-效率优化标志>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>--uc, --token-efficient    <span style=color:#75715e># 令牌效率模式 (30-50%压缩)</span>
</span></span><span style=display:flex><span>--think                   <span style=color:#75715e># 结构化思考 (4K tokens)</span>
</span></span><span style=display:flex><span>--think-hard              <span style=color:#75715e># 深度分析 (10K tokens) </span>
</span></span><span style=display:flex><span>--ultrathink              <span style=color:#75715e># 最大深度分析 (32K tokens)</span>
</span></span></code></pre></div><h4 id=-mcp服务器标志>🛠️ MCP服务器标志<a hidden class=anchor aria-hidden=true href=#-mcp服务器标志>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>--c7, --context7          <span style=color:#75715e># 官方文档模式</span>
</span></span><span style=display:flex><span>--magic                   <span style=color:#75715e># UI组件生成</span>
</span></span><span style=display:flex><span>--play, --playwright      <span style=color:#75715e># 浏览器测试</span>
</span></span><span style=display:flex><span>--seq, --sequential       <span style=color:#75715e># 时序分析</span>
</span></span><span style=display:flex><span>--tavily                  <span style=color:#75715e># 网络搜索</span>
</span></span><span style=display:flex><span>--all-mcp                 <span style=color:#75715e># 启用所有服务器</span>
</span></span><span style=display:flex><span>--no-mcp                  <span style=color:#75715e># 禁用MCP(故障排查)</span>
</span></span></code></pre></div><h4 id=-行为模式标志>🧠 行为模式标志<a hidden class=anchor aria-hidden=true href=#-行为模式标志>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>--brainstorm              <span style=color:#75715e># 探索发现模式</span>
</span></span><span style=display:flex><span>--introspect              <span style=color:#75715e># 透明推理模式  </span>
</span></span><span style=display:flex><span>--task-manage             <span style=color:#75715e># 任务协调模式</span>
</span></span><span style=display:flex><span>--orchestrate             <span style=color:#75715e># 工具编排模式</span>
</span></span></code></pre></div><h3 id=24-命令使用示例>2.4 命令使用示例<a hidden class=anchor aria-hidden=true href=#24-命令使用示例>#</a></h3><h4 id=发现与规划><strong>发现与规划</strong><a hidden class=anchor aria-hidden=true href=#发现与规划>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 项目启动器</span>
</span></span><span style=display:flex><span>/sc:brainstorm <span style=color:#e6db74>&#34;任务管理 Web 应用&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：观察如何引导需求发现</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/sc:analyze src/
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：理解代码分析模式</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/sc:design <span style=color:#e6db74>&#34;用户认证系统&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：系统设计思维</span>
</span></span></code></pre></div><h4 id=实现与构建><strong>实现与构建</strong><a hidden class=anchor aria-hidden=true href=#实现与构建>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>/sc:implement <span style=color:#e6db74>&#34;JWT 认证系统&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：最佳实践应用</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/sc:build <span style=color:#e6db74>&#34;生产环境配置&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：构建流程优化</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/sc:improve <span style=color:#e6db74>&#34;代码质量&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：重构模式</span>
</span></span></code></pre></div><h4 id=测试与文档><strong>测试与文档</strong><a hidden class=anchor aria-hidden=true href=#测试与文档>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>/sc:test --coverage
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：测试策略</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/sc:document <span style=color:#e6db74>&#34;API 文档&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：文档生成</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/sc:reflect
</span></span><span style=display:flex><span><span style=color:#75715e># 学习要点：项目复盘</span>
</span></span></code></pre></div><h4 id=代理专家使用>代理专家使用<a hidden class=anchor aria-hidden=true href=#代理专家使用>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 安全专家协作</span>
</span></span><span style=display:flex><span>@agent-security <span style=color:#e6db74>&#34;审查认证实现&#34;</span>
</span></span><span style=display:flex><span>@agent-security <span style=color:#e6db74>&#34;OWASP 合规检查&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 架构师协作  </span>
</span></span><span style=display:flex><span>@agent-system-architect <span style=color:#e6db74>&#34;微服务设计&#34;</span>
</span></span><span style=display:flex><span>@agent-backend-architect <span style=color:#e6db74>&#34;API 设计评审&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 性能专家协作</span>
</span></span><span style=display:flex><span>@agent-performance-engineer <span style=color:#e6db74>&#34;优化数据库查询&#34;</span>
</span></span><span style=display:flex><span>@agent-frontend-architect <span style=color:#e6db74>&#34;提升页面加载速度&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 质量专家协作</span>
</span></span><span style=display:flex><span>@agent-quality-engineer <span style=color:#e6db74>&#34;设计测试策略&#34;</span>
</span></span><span style=display:flex><span>@agent-refactoring-expert <span style=color:#e6db74>&#34;代码重构建议&#34;</span>
</span></span></code></pre></div><h4 id=模式组合实践>模式组合实践<a hidden class=anchor aria-hidden=true href=#模式组合实践>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 复杂项目管理</span>
</span></span><span style=display:flex><span>/sc:implement <span style=color:#e6db74>&#34;电商平台&#34;</span> --task-manage
</span></span><span style=display:flex><span><span style=color:#75715e># 组合：Task Management + 自动代理协调</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 需求探索</span>
</span></span><span style=display:flex><span>/sc:brainstorm <span style=color:#e6db74>&#34;移动应用&#34;</span> --brainstorm
</span></span><span style=display:flex><span><span style=color:#75715e># 专注：需求发现和澄清</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 透明学习</span>
</span></span><span style=display:flex><span>/sc:analyze <span style=color:#e6db74>&#34;遗留系统&#34;</span> --introspect
</span></span><span style=display:flex><span><span style=color:#75715e># 重点：理解推理过程</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 高效沟通  </span>
</span></span><span style=display:flex><span>/sc:research <span style=color:#e6db74>&#34;最新技术&#34;</span> --uc
</span></span><span style=display:flex><span><span style=color:#75715e># 优势：节省上下文空间</span>
</span></span></code></pre></div><h4 id=高级工作流>高级工作流<a hidden class=anchor aria-hidden=true href=#高级工作流>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span> 项目启动完整流程
</span></span><span style=display:flex><span>/sc:brainstorm <span style=color:#e6db74>&#34;社交媒体应用&#34;</span>
</span></span><span style=display:flex><span>/sc:load existing-project/
</span></span><span style=display:flex><span>/sc:analyze . --focus architecture
</span></span><span style=display:flex><span>/sc:design <span style=color:#e6db74>&#34;微服务架构&#34;</span>
</span></span><span style=display:flex><span>/sc:workflow <span style=color:#e6db74>&#34;完整开发计划&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 开发实施阶段</span>
</span></span><span style=display:flex><span>/sc:implement <span style=color:#e6db74>&#34;用户服务&#34;</span> --task-manage
</span></span><span style=display:flex><span>@agent-security <span style=color:#e6db74>&#34;安全审查&#34;</span>
</span></span><span style=display:flex><span>@agent-performance-engineer <span style=color:#e6db74>&#34;性能优化&#34;</span>
</span></span><span style=display:flex><span>/sc:test --coverage --type e2e
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 项目收尾</span>
</span></span><span style=display:flex><span>/sc:document <span style=color:#e6db74>&#34;完整文档&#34;</span>
</span></span><span style=display:flex><span>/sc:reflect --scope project
</span></span><span style=display:flex><span>/sc:save <span style=color:#e6db74>&#34;项目完成 v1.0&#34;</span>
</span></span></code></pre></div><h2 id=三安装superclaudeubuntu>三、安装SuperClaude(Ubuntu)<a hidden class=anchor aria-hidden=true href=#三安装superclaudeubuntu>#</a></h2><p>对于 Ubuntu 系统，官方推荐使用 pipx 进行安装，因为它可以创建一个干净、隔离的环境，避免与系统或其他项目的 Python 包冲突。</p><ol><li><p><strong>环境要求检查</strong></p><ul><li><strong>Python 3.8+</strong>: 在终端输入 python3 &ndash;version 检查。</li><li><strong>pip</strong>: 通常随 Python 一起安装，输入 pip &ndash;version 检查。</li><li><strong>Claude Code</strong>: 确保你的开发环境中已安装并能正常使用。</li></ul></li><li><p><strong>安装 pipx (如果尚未安装)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 使用 pip 安装 pipx</span>
</span></span><span style=display:flex><span>python3 -m pip install --user pipx
</span></span><span style=display:flex><span><span style=color:#75715e># 将 pipx 添加到系统路径</span>
</span></span><span style=display:flex><span>python3 -m pipx ensurepath
</span></span></code></pre></div><p><strong>注意</strong>：运行第二条命令后，你可能需要重启终端才能让 pipx 命令生效。</p></li><li><p><strong>使用</strong> <strong>pipx</strong> <strong>安装 SuperClaude</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 这条命令会做两件事：</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 1. 使用 pipx 安装 SuperClaude 的管理工具</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 运行 SuperClaude 的安装程序，将上下文文件（.md）安装到 ~/.claude/ 目录</span>
</span></span><span style=display:flex><span>pipx install SuperClaude <span style=color:#f92672>&amp;&amp;</span> SuperClaude install
</span></span></code></pre></div></li><li><p><strong>验证安装</strong></p><ul><li><p><strong>检查版本</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>python3 -m SuperClaude --version
</span></span><span style=display:flex><span><span style=color:#75715e># 预期输出: SuperClaude 4.1.5 或更高版本</span>
</span></span></code></pre></div></li><li><p><strong>列出组件</strong>:</p><pre tabindex=0><code>SuperClaude install --list-components
# 预期输出: 一个包含 core, agents, commands, modes, mcp 的列表
</code></pre></li><li><p><strong>在 Claude Code 中测试</strong>: 打开 Claude Code，输入 /sc:brainstorm &ldquo;test&rdquo;。如果它开始向你提问而不是直接回答，那么恭喜你，SuperClaude 已成功激活！</p></li></ul></li></ol><p>5.<strong>安装后，SuperClaude 的所有“智慧”都以 .md 文件的形式存放在你主目录下的 ~/.claude/ 中</strong></p><ul><li>CLAUDE.md: 这是主入口文件，通过 @ 语法导入其他所有组件的上下文。</li><li>agents/: 存放所有专家 (Agent) 的行为定义文件。</li><li>commands/: 存放所有命令 (Command) 的工作流定义文件。</li><li>modes/: 存放所有行为模式 (Mode) 的定义文件。</li></ul><h2 id=四案例研究>四、案例研究<a hidden class=anchor aria-hidden=true href=#四案例研究>#</a></h2><h3 id=41-to-do-list>4.1 To-Do List<a hidden class=anchor aria-hidden=true href=#41-to-do-list>#</a></h3><p>让我们通过一个具体案例——<strong>“构建一个简单的待办事项(To-Do List)Web应用”</strong>——来体验 SuperClaude 的完整流程。</p><p>你只有一个模糊的想法，没关系，让 SuperClaude 帮你理清思路。</p><p>在 Claude Code 中输入：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>/sc:brainstorm &#34;a simple to-do list web app&#34;
</span></span></code></pre></div><ul><li><strong>你会看到什么？</strong>
SuperClaude 不会立刻给你代码。相反，它会进入<strong>头脑风暴模式</strong>，开始向你提问，像一个产品经理一样：<ul><li>&ldquo;这个应用是给谁用的？&rdquo;</li><li>&ldquo;除了添加和删除任务，还需要哪些核心功能（比如设置截止日期、优先级）？&rdquo;</li><li>&ldquo;我们计划使用什么技术栈（React, Vue, Svelte）？&rdquo;</li></ul></li><li><strong>价值</strong>：这一步将模糊的需求转化为清晰、结构化的产品需求文档 (PRD)。</li></ul><p>需求明确后，我们需要一个高级计划。</p><p>假设你已经创建了一个项目文件夹 my-todo-app/。首先，让 SuperClaude 加载并分析当前的项目结构。</p><pre tabindex=0><code># (假设你已在终端创建了文件夹和一些空文件)
# 在 Claude Code 中...
/sc:load my-todo-app/
/sc:analyze
</code></pre><p>接下来，让我们为最核心的功能——“用户认证”——生成一个详细的实施路线图。</p><pre tabindex=0><code>/sc:workflow &#34;user authentication for to-do app&#34;
</code></pre><ul><li><strong>你会看到什么？</strong>
一个多阶段的计划，包含<strong>任务分解、依赖关系和质量检查点</strong>，例如：<ul><li>Phase 1: API 端点设计 (注册, 登录, 登出)</li><li>Phase 2: 数据库模型设计 (User Schema)</li><li>Phase 3: 后端逻辑实现 (密码哈希, JWT生成)</li><li>Phase 4: 前端组件开发 (登录表单)</li><li>Phase 5: 集成与测试</li></ul></li><li><strong>价值</strong>：将一个复杂任务分解为可管理的小块，确保实施过程的系统性和完整性。</li></ul><p>现在，我们开始具体编码。</p><p>执行计划中的第一步：</p><pre tabindex=0><code>/sc:implement &#34;JWT authentication API endpoint using FastAPI&#34;
</code></pre><p>在实现过程中，你可能需要特定领域的专家建议。比如，你不确定前端组件的最佳实践。这时，你可以手动召唤<strong>前端架构师</strong>：</p><pre tabindex=0><code>@agent-frontend &#34;suggest a good React component structure for the login form, focusing on accessibility&#34;
</code></pre><ul><li><strong>你会看到什么？</strong><ul><li>implement 命令会生成高质量、遵循最佳实践的代码片段。</li><li>@agent-frontend 会给出专业的建议，可能包括代码结构、状态管理方案，以及如何满足 WCAG 无障碍标准。</li></ul></li><li><strong>价值</strong>：代码不仅能跑，而且质量高、可维护性强，并融入了深度的领域知识。</li></ul><p>今天的工作完成了，你需要保存当前的项目状态，以便明天能无缝衔接。</p><pre tabindex=0><code>/sc:save &#34;completed backend auth logic, frontend form structure designed&#34;
```第二天，当你打开一个新的 Claude Code 对话时：
```text
/sc:load &#34;my-todo-app&#34;
</code></pre><ul><li><strong>你会看到什么？</strong>
所有之前的上下文、设计决策、代码片段和讨论都会被恢复。你无需重复解释项目背景，可以直接继续工作。</li><li><strong>价值</strong>：这实现了真正的<strong>跨会话项目连续性</strong>，是进行大型项目的关键。</li></ul><hr><p><strong>总结</strong></p><table><thead><tr><th>分类</th><th>命令</th><th>描述</th><th>新手常用场景</th></tr></thead><tbody><tr><td><strong>规划设计</strong></td><td>/sc:brainstorm</td><td>通过提问式交互，将模糊想法转化为明确需求。</td><td><strong>项目启动时的第一步</strong>。</td></tr><tr><td></td><td>/sc:workflow</td><td>为一个复杂功能生成详细的、分阶段的实施计划。</td><td>在编码前规划好路线图。</td></tr><tr><td><strong>开发实现</strong></td><td>/sc:implement</td><td>根据需求，生成高质量、遵循最佳实践的代码。</td><td><strong>核心编码命令</strong>。</td></tr><tr><td></td><td>/sc:improve</td><td>分析并重构现有代码，提升质量、性能或可读性。</td><td>优化你的代码。</td></tr><tr><td><strong>测试质量</strong></td><td>/sc:analyze</td><td>深度分析代码库，从架构、安全、性能等维度提供报告。</td><td>对现有项目进行“体检”。</td></tr><tr><td></td><td>/sc:test</td><td>根据功能描述，自动生成单元测试、集成测试或端到端测试。</td><td>保证代码质量。</td></tr><tr><td></td><td>/sc:troubleshoot</td><td>帮助你系统地调试一个 Bug 或性能问题。</td><td>解决棘手的错误。</td></tr><tr><td><strong>辅助工具</strong></td><td>/sc:save / /sc:load</td><td>保存和加载项目会话，实现跨对话的持久记忆。</td><td><strong>长周期项目的必备</strong>。</td></tr></tbody></table><h3 id=42-任务管理应用开发>4.2 任务管理应用开发<a hidden class=anchor aria-hidden=true href=#42-任务管理应用开发>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 需求发现阶段</span>
</span></span><span style=display:flex><span>/sc:brainstorm <span style=color:#e6db74>&#34;个人任务管理应用&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：系统会询问用户类型、功能需求、技术偏好等</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 技术选型分析</span>
</span></span><span style=display:flex><span>/sc:research <span style=color:#e6db74>&#34;2024年最佳前端框架对比&#34;</span> --depth deep
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：提供最新技术对比和选择建议</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 架构设计</span>
</span></span><span style=display:flex><span>/sc:design <span style=color:#e6db74>&#34;现代前端架构&#34;</span> --type architecture
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：生成架构图和技术栈建议</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 安全实现</span>
</span></span><span style=display:flex><span>/sc:implement <span style=color:#e6db74>&#34;用户认证系统&#34;</span> --focus security
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：JWT + 刷新令牌 + 速率限制</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 5. 性能优化</span>
</span></span><span style=display:flex><span>/sc:improve <span style=color:#e6db74>&#34;前端性能&#34;</span> --type performance
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：打包优化、懒加载、缓存策略</span>
</span></span></code></pre></div><h3 id=43-遗留系统现代化>4.3 遗留系统现代化<a hidden class=anchor aria-hidden=true href=#43-遗留系统现代化>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 现状分析</span>
</span></span><span style=display:flex><span>/sc:load legacy-system/
</span></span><span style=display:flex><span>/sc:analyze . --ultrathink --all-mcp
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：深度分析系统现状</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 问题诊断</span>
</span></span><span style=display:flex><span>/sc:troubleshoot <span style=color:#e6db74>&#34;性能瓶颈&#34;</span> --type performance --trace
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：系统性问题定位</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 重构规划</span>
</span></span><span style=display:flex><span>@agent-refactoring-expert <span style=color:#e6db74>&#34;制定现代化策略&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：渐进式重构计划</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 实施改进</span>
</span></span><span style=display:flex><span>/sc:improve <span style=color:#e6db74>&#34;代码质量&#34;</span> --safe --interactive
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：安全的逐步改进</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 5. 验证结果</span>
</span></span><span style=display:flex><span>/sc:test --type integration
</span></span><span style=display:flex><span>/sc:reflect --validate
</span></span><span style=display:flex><span><span style=color:#75715e># 预期：全面验证改进效果</span>
</span></span></code></pre></div><h3 id=44-谷歌翻译插件-实现1>4.4 谷歌翻译插件-实现1<a hidden class=anchor aria-hidden=true href=#44-谷歌翻译插件-实现1>#</a></h3><p><strong>项目背景</strong></p><ul><li><strong>目标</strong>: 创建一个谷歌浏览器插件。用户在网页上选中文本，点击插件图标，就能在弹窗中看到翻译结果。</li><li><strong>“智能”特性 (V1)</strong>: 我们先实现核心翻译功能，后续迭代再加入“智能”元素（如自动检测语言、提供多种翻译引擎等）。</li><li><strong>你的角色</strong>: SuperClaude 新手，熟悉基本的 Web 开发概念。</li></ul><hr><p><strong>阶段一：项目启动与需求探索 (告别混沌的开始)</strong></p><p>传统的开发方式可能是直接打开 VS Code 开始写 manifest.json，但很快就会发现需求不明确，边写边改。SuperClaude 让我们从“产品经理”的视角开始。</p><p><strong>步骤 1: 使用 /sc:brainstorm 进行头脑风暴</strong></p><p><strong>💡 为什么这么做？</strong>
在写任何代码之前，我们必须将模糊的想法（“做一个翻译插件”）转化为清晰、可执行的需求。brainstorm 命令会通过引导式提问，帮助我们挖掘潜在需求、技术选型和功能边界，避免在开发中途迷失方向。</p><p><strong>▶️ 在 Claude Code 中输入：</strong></p><hr><pre tabindex=0><code>/sc:brainstorm &#34;a smart translator chrome extension&#34;
</code></pre><p><strong>🤖 你会看到 SuperClaude 的回应 (类似这样):</strong></p><blockquote><p>&ldquo;好的，这是一个很棒的想法！让我们一起来深入探讨一下。在开始设计之前，我想先问几个问题来明确方向：</p><ol><li><strong>核心功能</strong>: 用户如何触发翻译？是在选中文字后自动弹出，还是需要点击插件图标？</li><li><strong>翻译服务</strong>: 我们计划使用哪个第三方翻译 API？（例如 Google Translate, DeepL, Microsoft Translator?）这会影响到成本和实现方式。</li><li><strong>用户界面</strong>: 插件的弹窗（Popup）需要显示哪些内容？仅仅是译文，还是也需要显示原文和发音按钮？</li><li><strong>“智能”体现在哪</strong>: 在第一个版本中，“智能”是指什么？是自动语言检测，还是其他高级功能？</li><li><strong>数据存储</strong>: 是否需要保存用户的翻译历史？&rdquo;</li></ol></blockquote><p><strong>✅ 你的产出：</strong>
通过这次对话，你和 SuperClaude 共同确定了 V1 版本的清晰需求：</p><ul><li><strong>触发方式</strong>: 选中文字后，点击浏览器右上角的插件图标。</li><li><strong>翻译服务</strong>: 使用 DeepL API (假设你已经申请了 API Key)。</li><li><strong>UI</strong>: 弹窗内有一个文本框显示原文，一个“翻译”按钮，和一个用于显示译文的区域。</li><li><strong>智能特性</strong>: V1 暂不包含，核心是打通流程。</li><li><strong>数据存储</strong>: V1 暂不包含。</li></ul><hr><p><strong>阶段二：架构设计与开发规划 (搭建坚实的地基)</strong></p><p>需求清晰了，现在我们需要一个专业的架构师来规划项目结构和技术蓝图。</p><p><strong>步骤 2: 使用 @agent-architect 设计架构，并用 /sc:workflow 制定计划</strong></p><p><strong>💡 为什么这么做？</strong>
直接开始写功能代码容易导致结构混乱、难以维护。我们先让<strong>架构师专家 (@agent-architect)</strong> 规划高层设计，确保组件划分合理。然后用 workflow 命令将整个开发过程分解成一个个可管理、可验证的子任务，就像一个项目经理为你制定了详细的 JIRA 任务列表。</p><p><strong>▶️ 在 Claude Code 中输入：</strong></p><pre tabindex=0><code>@agent-architect &#34;Based on our requirements, design the high-level architecture and file structure for our DeepL translator Chrome extension.&#34;
</code></pre><p><strong>🤖 你会看到 SuperClaude (以架构师身份) 的回应：</strong></p><blockquote><p>&ldquo;收到。作为系统架构师，我建议采用以下结构，以实现关注点分离和未来的可扩展性：</p><p><strong>架构图解:</strong>
[Popup UI (popup.html/js)] &lt;&ndash;> [Background Script (background.js)] &lt;&ndash;> [DeepL API]</p><ul><li><strong>Popup UI</strong>: 负责用户交互。</li><li><strong>Background Script</strong>: 负责处理核心逻辑，如 API 调用，以避免阻塞 UI。</li></ul><p><strong>推荐文件结构:</strong></p></blockquote><pre tabindex=0><code>smart-translator/
├── manifest.json       # 插件的配置文件
├── popup.html          # 弹窗的 HTML 结构
├── popup.css           # 弹窗的样式
├── popup.js            # 弹窗的交互逻辑
├── background.js       # 后台脚本，处理 API 请求
└── icons/
    ├── icon16.png
    ├── icon48.png
    └── icon128.png
```&#34;
</code></pre><p><strong>▶️ 接着，我们来创建工作流：</strong></p><pre tabindex=0><code>/sc:workflow &#34;build the v1 of the smart translator extension&#34;
</code></pre><p><strong>🤖 你会看到一个分阶段的计划：</strong></p><pre tabindex=0><code>🤖 你会看到一个分阶段的计划：
&#34;好的，这是构建 V1 版本的实施路线图：
Phase 1: 项目骨架搭建
Task 1.1: 创建 manifest.json 并配置基本权限。

Phase 2: UI 开发
Task 2.1: 实现 popup.html 的基本布局。
Task 2.2: 编写 popup.css 美化界面。

Phase 3: 核心逻辑实现
Task 3.1: 编写 popup.js 获取选中文本并与后台脚本通信。
Task 3.2: 在 background.js 中实现调用 DeepL API 的函数。

Phase 4: 集成与测试
Task 4.1: 联调前后端逻辑，确保流程通畅。
Task 4.2: 编写基本测试用例。 &#34;
</code></pre><p><strong>阶段三：编码实现 (专家指导下的高效编码)</strong></p><p>现在，我们严格按照 workflow 的规划，逐一完成任务。</p><p><strong>步骤 3: 使用 /sc:implement 编码，并适时召唤专家</strong></p><p><strong>💡 为什么这么做？</strong>
implement 命令生成的代码质量更高，因为它会遵循其上下文中的最佳实践。当遇到特定领域的难题时（如 API Key 的安全存储），我们可以召唤相应的<strong>专家 (Agent)</strong>，获得精准、专业的解决方案，而不是在网上大海捞针。</p><p><strong>▶️ 执行 Task 1.1: 创建 manifest.json</strong></p><pre tabindex=0><code>/sc:implement &#34;the manifest.json for a Chrome extension with a browser action popup and permissions for activeTab and storage&#34;
</code></pre><p><strong>▶️ 执行 Phase 2: UI 开发</strong></p><pre tabindex=0><code>/sc:implement &#34;the HTML for popup.html with a textarea, a button, and a div for the result&#34;
``````text
/sc:implement &#34;some clean, modern CSS for popup.css to style the elements from popup.html&#34;
</code></pre><p><strong>▶️ 执行 Phase 3: 核心逻辑实现 (关键步骤)</strong></p><pre tabindex=0><code>/sc:implement &#34;in popup.js, write the logic to: 1. Listen for the button click. 2. Get the current active tab. 3. Execute a content script to get the selected text. 4. Send the selected text to background.js. 5. Receive the translation from background.js and display it.&#34;
</code></pre><p>现在，到了最关键的 API 调用部分，同时我们也遇到了一个安全问题：API Key 应该如何安全地存储？这是<strong>安全专家</strong>出场的最佳时机。</p><p><strong>▶️ 召唤安全专家并实现 API 调用:</strong></p><pre tabindex=0><code>@agent-security &#34;What is the best practice to store and use a DeepL API key in a Chrome extension?&#34;
</code></pre><p><strong>🤖 安全专家会告诉你：</strong></p><blockquote><p>&ldquo;在 Chrome 插件中，绝不要将 API Key 硬编码在前端 JS 文件中。最佳实践是让用户在插件的<strong>选项页 (Options Page)</strong> 中输入自己的 Key，然后使用 chrome.storage.sync 或 chrome.storage.local API 将其安全地存储起来。后台脚本在需要时从存储中读取。&rdquo;</p></blockquote><p><strong>▶️ 根据专家的建议，我们继续实现：</strong></p><pre tabindex=0><code>/sc:implement &#34;in background.js, create a function that retrieves the DeepL API key from chrome.storage, calls the DeepL API with the provided text, and returns the translation. Handle potential errors.&#34;
</code></pre><hr><p><strong>阶段四：测试、分析与保存 (确保项目健康)</strong></p><p>代码写完了，但工作还没结束。我们需要确保代码的质量和健壮性。</p><p><strong>步骤 4: 使用 /sc:test、/sc:analyze 和 /sc:save</strong></p><p><strong>💡 为什么这么做？</strong>
一个专业的开发者必须对代码质量负责。test 可以为核心逻辑生成测试用例，analyze 则像一位资深代码审查员，全面检查项目的潜在问题。最后，save 能将我们的所有工作成果（包括讨论、决策和代码）保存下来，为未来的迭代做好准备。</p><p><strong>▶️ 生成测试用例:</strong></p><pre tabindex=0><code>/sc:test &#34;generate a unit test for the DeepL API call function in background.js, using a mock for the fetch API to avoid making a real network request&#34;
</code></pre><p><strong>▶️ 全面分析项目:</strong></p><pre tabindex=0><code>/sc:analyze &#34;the entire project&#34; --focus quality
</code></pre><ul><li><strong>代码质量</strong>: &ldquo;在 popup.js 中，DOM 选择器可以被缓存以提高性能。&rdquo;</li><li><strong>潜在 Bug</strong>: &ldquo;在 background.js 中，API 错误处理可以更具体，区分 401（认证失败）和 500（服务器错误）。&rdquo;</li></ul><p><strong>▶️ 保存你的工作会话:</strong></p><pre tabindex=0><code>/sc:save &#34;v1.0 of Smart Translator complete. Core translation functionality is working. Next step is to add language detection.&#34;
</code></pre><hr><p><strong>命令回顾与总结</strong></p><p>在这个项目中，你像一个专业的项目团队一样，系统地完成了所有工作。回顾一下你使用的核心 SuperClaude 命令：</p><table><thead><tr><th>命令</th><th>在本项目中的作用</th></tr></thead><tbody><tr><td>/sc:brainstorm</td><td><strong>产品经理</strong>：明确了插件的核心需求和功能。</td></tr><tr><td>@agent-architect</td><td><strong>架构师</strong>：设计了清晰、可扩展的项目结构。</td></tr><tr><td>/sc:workflow</td><td><strong>项目经理</strong>：将开发任务分解为有序的、可执行的计划。</td></tr><tr><td>/sc:implement</td><td><strong>核心程序员</strong>：高效、高质量地编写了代码。</td></tr><tr><td>@agent-security</td><td><strong>安全顾问</strong>：解决了 API Key 存储的关键安全问题。</td></tr><tr><td>/sc:test</td><td><strong>测试工程师</strong>：为核心功能生成了单元测试。</td></tr><tr><td>/sc:analyze</td><td><strong>代码审查员</strong>：对整个项目进行了质量评估。</td></tr><tr><td>/sc:save</td><td><strong>文档管理员</strong>：将项目状态归档，以便未来继续。</td></tr></tbody></table><p><strong>你的下一步</strong></p><p>当你准备好开发 V2 版本（例如，添加“智能语言检测”功能）时，只需在新对话中输入：</p><pre tabindex=0><code>/sc:load &#34;v1.0 of Smart Translator&#34;
</code></pre><p>SuperClaude 就会恢复所有上下文，你无需任何重复解释，就可以立即开始新的工作流。</p><p>这就是 SuperClaude 的力量：它不仅仅是一个代码生成器，更是一个<strong>内置了专家团队和标准化流程的、系统化的开发伙伴</strong>。</p><h3 id=45-谷歌翻译插件-实现2>4.5 谷歌翻译插件-实现2<a hidden class=anchor aria-hidden=true href=#45-谷歌翻译插件-实现2>#</a></h3><p><strong>第 1 步：需求挖掘（Brainstorming 模式）—— 为什么先做这一步？</strong></p><p>普通人直接说“做一个翻译插件”会导致需求模糊，后面返工 5 次。SuperClaude 会强制把模糊想法变成专业级需求文档。</p><pre tabindex=0><code>/sc:brainstorm &#34;一个 Chrome 浏览器插件，用于网页划词翻译和右键翻译，支持 DeepL、Google、Gemini、Claude 4 个翻译引擎自由切换，要有漂亮的弹出面板，支持快捷键和自动识别语种&#34;
</code></pre><p>SuperClaude 会问你 10～15 个专业问题（用户场景、隐私、界面风格、是否开源、是否需要登录等），你全部如实回答就行。</p><p>5～8 分钟后你会得到一份《智能翻译器 Chrome 插件需求规格书》（包含用户故事、功能清单、非功能需求、技术选型建议）</p><p><strong>第 2 步：保存需求，为后面所有工作打记忆底座（跨会话记忆）</strong></p><pre tabindex=0><code>/sc:save &#34;智能翻译器需求规格完成，功能清单确定&#34;
</code></pre><p>以后即使你明天再开新聊天，这句话也能恢复全部背景！</p><p><strong>第 3 步：整体架构设计（自动拉专家团）</strong></p><pre tabindex=0><code>/sc:design &#34;基于上面的需求，设计完整的 Chrome Extension 技术架构&#34;
</code></pre><p>这一步会自动激活：</p><ul><li>frontend-architect（Chrome 插件专家）</li><li>system-architect</li><li>security-engineer（因为涉及剪贴板和内容脚本权限）</li></ul><p>你会得到：</p><ul><li>manifest v3 结构</li><li>内容脚本 + background service worker + popup + options 页面划分</li><li>推荐用 React + Tailwind + shadcn/ui 做 popup</li><li>推荐翻译引擎 API 封装策略</li></ul><p><strong>第 4 步：生成最漂亮的 UI（Magic MCP 神器）</strong></p><pre tabindex=0><code>/sc:implement &#34;翻译插件的弹出面板 UI，使用 shadcn/ui + tailwind，支持暗黑模式、引擎切换、下拉历史&#34; --magic
</code></pre><p>&ndash;magic 会自动调用 Magic MCP（21st.dev），直接给你 2025 年最现代的 UI 组件代码，漂亮到可以直接上 Chrome 商店。</p><p><strong>第 5 步：核心功能实现（一句话出完整代码）</strong></p><pre tabindex=0><code>/sc:implement &#34;完整的划词翻译和右键翻译功能，包括内容脚本注入、背景通信、4 个翻译引擎封装（DeepL、Google、Gemini、Claude Sonnet 3.5 API）、自动语种检测、错误重试、翻译历史本地存储&#34;
</code></pre><p>这一步会自动激活：</p><ul><li>backend-architect（API 封装）</li><li>security-engineer（API Key 安全存储）</li><li>performance-engineer（防抖、缓存）</li><li>quality-engineer（错误处理）</li></ul><p>你会一次性得到 6～8 个文件完整代码（manifest.json、content-script.ts、background.ts、popup.tsx 等）</p><p><strong>第 6 步：安全 + 性能 + 可访问性深度审查（工业级质量门禁）</strong></p><p>把整个项目文件夹拖进聊天框，然后输入：</p><pre tabindex=0><code>/sc:analyze . --ultrathink --all-mcp --focus security,performance,accessibility
</code></pre><p>&ndash;ultrathink 会开到最大上下文，调用所有 8 个 MCP 服务器（Sequential、Serena、Chrome DevTools 等），给你一份 2000 字的深度审计报告，指出所有潜在问题并直接给出修复 patch。</p><p><strong>第 7 步：自动生成完整测试（E2E + 单元）</strong></p><pre tabindex=0><code>/sc:test --type e2e &#34;用户划词翻译整个流程，从选中文字到弹出翻译结果&#34; --play
</code></pre><p>&ndash;play 会调用 Playwright MCP，自动生成真实浏览器测试脚本（可以直接 npm test 跑）</p><pre tabindex=0><code>/sc:test --type unit &#34;翻译引擎切换和错误重试逻辑&#34;
</code></pre><p><strong>第 8 步：自动生成商店上架所需的所有素材</strong></p><pre tabindex=0><code>/sc:document &#34;生成 Chrome Web Store 上架所需的描述、截图提示、隐私政策、更新日志&#34;
</code></pre><p>会直接给你：</p><ul><li>1280x800 的 5 张截图提示（你用 Claude 图片生成功能一键生成）</li><li>多语言商店描述</li><li>完整的隐私政策模板</li></ul><p><strong>第 9 步：一键打包 + 验证</strong></p><pre tabindex=0><code>/sc:build &#34;生成可上传 Chrome 商店的 .zip 包，并验证 manifest v3 合规性&#34;
</code></pre><p><strong>第 10 步：保存整个项目（以后随时继续迭代）</strong></p><pre tabindex=0><code>/sc:save &#34;智能翻译器 Chrome 插件 MVP 完成，已通过安全审计和 E2E 测试&#34;
</code></pre><p>以后你想加“语音朗读”或“PDF 翻译”功能，只需要：</p><pre tabindex=0><code>/sc:load 智能翻译器
/sc:implement &#34;新增语音朗读功能，支持 5 种语速和男/女声切换&#34;
</code></pre><p>所有历史上下文、架构决定、安全规范全部自动恢复，无需重新解释！</p><p><strong>命令回顾与总结</strong></p><pre tabindex=0><code>1. /sc:brainstorm &#34;一个 Chrome 浏览器插件，用于网页划词翻译和右键翻译，支持 DeepL、Google、Gemini、Claude 4 个翻译引擎自由切换，要有漂亮的弹出面板，支持快捷键和自动识别语种&#34;

2. /sc:save &#34;智能翻译器需求规格完成&#34;

3. /sc:design &#34;基于上面的需求，设计完整的 Chrome Extension 技术架构&#34;

4. /sc:implement &#34;翻译插件的弹出面板 UI，使用 shadcn/ui + tailwind，支持暗黑模式、引擎切换、下拉历史&#34; --magic

5. /sc:implement &#34;完整的划词翻译和右键翻译功能，包括内容脚本注入、背景通信、4 个翻译引擎封装、自动语种检测、错误重试、翻译历史本地存储&#34;

6. （拖入整个项目文件夹）/sc:analyze . --ultrathink --all-mcp --focus security,performance,accessibility

7. /sc:test --type e2e &#34;用户划词翻译整个流程&#34; --play

8. /sc:document &#34;生成 Chrome Web Store 上架素材&#34;

9. /sc:build &#34;生成可上传的 .zip 包&#34;

10. /sc:save &#34;智能翻译器 Chrome 插件 MVP 完成&#34;
</code></pre><h3 id=46-谷歌翻译插件-实现3>4.6 谷歌翻译插件-实现3<a hidden class=anchor aria-hidden=true href=#46-谷歌翻译插件-实现3>#</a></h3><p><strong>步骤1：项目初始化</strong></p><p>为什么这么做？</p><p>我们需要创建一个结构化的项目，确保SuperClaude能正确识别项目上下文。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 创建项目目录</span>
</span></span><span style=display:flex><span>mkdir google-translate-plugin <span style=color:#f92672>&amp;&amp;</span> cd google-translate-plugin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 初始化SuperClaude项目</span>
</span></span><span style=display:flex><span>SuperClaude init --project <span style=color:#e6db74>&#34;google-translate-plugin&#34;</span> --description <span style=color:#e6db74>&#34;A Google Chrome extension for text translation&#34;</span>
</span></span></code></pre></div><blockquote><p>💡 <strong>为什么使用<code>init</code>命令？</strong>
<code>init</code>命令会创建必要的项目结构，让SuperClaude了解我们的项目范围和目标。这为后续的<code>/sc:analyze</code>和<code>/sc:implement</code>命令提供上下文。</p></blockquote><hr><p><strong>步骤3：需求分析与规划</strong></p><p>为什么这么做？</p><p>在开始编码前，我们需要明确插件的功能和实现方式。</p><pre tabindex=0><code># 1. 规划插件功能
/sc:brainstorm &#34;Google Chrome extension for text translation&#34;

# 2. 分析项目需求
/sc:analyze &#34;google-translate-plugin&#34; --focus requirements
</code></pre><p><strong>从命令输出中，我们可以得到：</strong></p><ol><li><strong>核心功能</strong>：<ul><li>选中文本翻译</li><li>整页翻译</li><li>语言选择</li><li>界面简洁</li></ul></li><li><strong>技术需求</strong>：<ul><li>需要<code>manifest.json</code>配置文件</li><li>需要<code>background.js</code>处理核心逻辑</li><li>需要<code>popup.html</code>提供用户界面</li><li>需要<code>content_script.js</code>注入到网页</li></ul></li><li><strong>高级功能</strong>：<ul><li>语言记忆</li><li>翻译历史</li><li>自定义快捷键</li></ul></li></ol><blockquote><p>💡 <strong>为什么使用<code>brainstorm</code>和<code>analyze</code>？</strong>
<code>brainstorm</code>帮助我们生成创意点子，<code>analyze</code>帮助我们从技术角度评估需求。这比直接开始编码更高效，避免走弯路。</p></blockquote><hr><p><strong>步骤4：设计插件架构</strong></p><p>为什么这么做？</p><p>良好的架构设计可以减少后续开发中的问题</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 设计插件架构</span>
</span></span><span style=display:flex><span>/sc:design <span style=color:#e6db74>&#34;google-translate-plugin&#34;</span> --focus architecture
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 生成架构图</span>
</span></span><span style=display:flex><span>/sc:generate <span style=color:#e6db74>&#34;google-translate-plugin&#34;</span> --type architecture-diagram
</span></span></code></pre></div><p><strong>从命令输出中，我们可以得到：</strong></p><pre tabindex=0><code>插件架构设计：
├── manifest.json       # 插件元数据
├── popup/
│   ├── popup.html      # 弹出窗口界面
│   ├── popup.css       # 样式
│   └── popup.js        # 交互逻辑
├── background/
│   └── background.js   # 后台脚本
├── content_scripts/
│   ├── content_script.js # 注入到网页的脚本
│   └── content_script.css
└── icons/
    ├── icon16.png
    └── icon48.png
</code></pre><blockquote><p>💡 <strong>为什么设计架构？</strong>
在编码前设计好架构，可以确保代码组织清晰，避免后期重构。SuperClaude的<code>design</code>命令会提供专业级的架构建议</p></blockquote><p><strong>步骤5：创建项目结构</strong></p><p>为什么这么做？</p><p>SuperClaude会根据我们的设计自动创建必要的文件结构。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 创建项目结构</span>
</span></span><span style=display:flex><span>/sc:generate <span style=color:#e6db74>&#34;google-translate-plugin&#34;</span> --type project-structure
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 验证结构</span>
</span></span><span style=display:flex><span>ls -R
</span></span></code></pre></div><p><strong>输出示例：</strong></p><pre tabindex=0><code>.
├── manifest.json
├── popup
│   ├── popup.html
│   ├── popup.css
│   └── popup.js
├── background
│   └── background.js
├── content_scripts
│   ├── content_script.js
│   └── content_script.css
└── icons
    ├── icon16.png
    └── icon48.png
</code></pre><blockquote><p>💡 <strong>为什么使用<code>generate</code>命令？</strong>
<code>generate</code>命令会根据我们之前的设计自动创建文件结构，避免了手动创建文件的繁琐过程。这是SuperClaude的核心优势——它知道如何正确地设置项目。</p></blockquote><hr><p><strong>步骤6：实现核心功能</strong></p><p><strong>为什么这么做？</strong></p><p>现在，我们开始编写实际代码。SuperClaude会帮助我们生成代码模板。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 生成manifest.json</span>
</span></span><span style=display:flex><span>/sc:implement <span style=color:#e6db74>&#34;manifest.json configuration&#34;</span> --focus chrome-extension
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 生成popup.html</span>
</span></span><span style=display:flex><span>/sc:implement <span style=color:#e6db74>&#34;popup.html interface&#34;</span> --focus ui
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 生成background.js</span>
</span></span><span style=display:flex><span>/sc:implement <span style=color:#e6db74>&#34;background.js core logic&#34;</span> --focus core
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4. 生成content_script.js</span>
</span></span><span style=display:flex><span>/sc:implement <span style=color:#e6db74>&#34;content_script.js translation logic&#34;</span> --focus translation
</span></span></code></pre></div><p>💡 <strong>为什么先实现manifest.json？</strong>
这是所有Chrome扩展的基础配置文件，必须先设置好才能继续开发。</p><p>💡 <strong>为什么使用<code>popup.html</code>？</strong>
这是用户与插件交互的主要界面，需要简洁直观。</p><p>💡 <strong>为什么需要background.js？</strong>
这个文件处理插件的启动和与内容脚本的交互，是插件的核心。</p><p>💡 <strong>为什么使用Google翻译API？</strong>
使用Google官方API可以确保翻译质量，避免自行实现翻译引擎的复杂性。</p><p><strong>步骤7：测试与调试</strong></p><p>为什么这么做？</p><p>在开发过程中，测试和调试是确保功能正确性的关键。</p><pre tabindex=0><code># 1. 启动测试模式
/sc:debug &#34;google-translate-plugin&#34; --mode test

# 2. 生成测试用例
/sc:generate &#34;google-translate-plugin&#34; --type test-cases
</code></pre><hr><p><strong>步骤8：部署与发布</strong></p><p><strong>为什么这么做？</strong></p><p>完成开发后，我们需要将插件打包并发布到Chrome Web Store。</p><pre tabindex=0><code># 1. 生成发布包
/sc:package &#34;google-translate-plugin&#34; --type chrome-extension

# 2. 生成发布说明
/sc:generate &#34;google-translate-plugin&#34; --type release-notes
</code></pre><p><strong>生成的发布说明示例：</strong></p><pre tabindex=0><code>Google Translate Plugin v1.0.0

主要功能：
- 选中文本实时翻译
- 简洁直观的用户界面
- 支持多种语言
- 轻量级，不干扰浏览体验

改进：
- 优化了翻译速度
- 修复了在某些网站上的兼容性问题
- 简化了用户界面

安装：
1. 下载插件包
2. 打开Chrome浏览器
3. 进入扩展程序管理
4. 启用开发者模式
5. 点击&#34;加载已解压的扩展程序&#34;，选择项目目录
</code></pre><blockquote><p>💡 <strong>为什么需要发布说明？</strong>
详细的发布说明可以帮助用户理解插件的功能和使用方法，提高用户满意度。</p></blockquote><p><strong>步骤9：持续改进</strong></p><p><strong>为什么这么做？</strong></p><p>软件开发是一个持续迭代的过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 1. 收集用户反馈</span>
</span></span><span style=display:flex><span>/sc:collect-feedback <span style=color:#e6db74>&#34;google-translate-plugin&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2. 分析使用数据</span>
</span></span><span style=display:flex><span>/sc:analyze <span style=color:#e6db74>&#34;google-translate-plugin&#34;</span> --focus user-data
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 3. 规划下一个版本</span>
</span></span><span style=display:flex><span>/sc:brainstorm <span style=color:#e6db74>&#34;google-translate-plugin&#34;</span> --focus next-version
</span></span></code></pre></div><p><strong>从用户反馈中，我们可能会得到：</strong></p><ul><li>&ldquo;希望增加翻译历史功能&rdquo;</li><li>&ldquo;希望支持更多语言&rdquo;</li><li>&ldquo;希望可以自定义翻译风格&rdquo;</li></ul><blockquote><p>💡 <strong>为什么持续改进？</strong>
通过收集用户反馈和分析使用数据，我们可以不断改进产品，使其更符合用户需求。</p></blockquote><p><strong>总结：SuperClaude在项目中的价值</strong></p><table><thead><tr><th>步骤</th><th>普通开发方式</th><th>使用SuperClaude</th><th>价值</th></tr></thead><tbody><tr><td>项目初始化</td><td>手动创建文件结构</td><td><code>sc:init</code></td><td>节省40%时间</td></tr><tr><td>需求分析</td><td>随意讨论</td><td><code>/sc:brainstorm</code></td><td>结构化思考</td></tr><tr><td>代码生成</td><td>从头编写</td><td><code>/sc:implement</code></td><td>减少错误</td></tr><tr><td>测试</td><td>手动测试</td><td><code>/sc:generate test-cases</code></td><td>更全面测试</td></tr><tr><td>发布</td><td>手动打包</td><td><code>/sc:package</code></td><td>专业发布流程</td></tr></tbody></table><p><strong>关键命令回顾</strong></p><table><thead><tr><th>命令</th><th>用途</th><th>为什么重要</th></tr></thead><tbody><tr><td><code>/sc:init</code></td><td>初始化项目</td><td>创建结构化项目基础</td></tr><tr><td><code>/sc:brainstorm</code></td><td>生成创意点子</td><td>确保功能符合需求</td></tr><tr><td><code>/sc:analyze</code></td><td>分析需求</td><td>技术评估需求可行性</td></tr><tr><td><code>/sc:design</code></td><td>设计架构</td><td>避免后期重构</td></tr><tr><td><code>/sc:implement</code></td><td>生成代码</td><td>快速实现核心功能</td></tr><tr><td><code>/sc:debug</code></td><td>测试与调试</td><td>确保功能正确性</td></tr><tr><td><code>/sc:package</code></td><td>打包发布</td><td>专业发布流程</td></tr></tbody></table><p><strong>实际案例：从0到1完成谷歌翻译插件</strong></p><ol><li><strong>第一天</strong>：使用<code>/sc:init</code>和<code>/sc:brainstorm</code>规划项目</li><li><strong>第二天</strong>：使用<code>/sc:analyze</code>和<code>/sc:design</code>设计架构</li><li><strong>第三天</strong>：使用<code>/sc:implement</code>实现核心功能</li><li><strong>第四天</strong>：使用<code>/sc:debug</code>测试和调试</li><li><strong>第五天</strong>：使用<code>/sc:package</code>打包并发布</li></ol><h2 id=五源码安全审计>五、源码安全审计<a hidden class=anchor aria-hidden=true href=#五源码安全审计>#</a></h2><h3 id=51-审计方案-1>5.1 审计方案-1<a hidden class=anchor aria-hidden=true href=#51-审计方案-1>#</a></h3><p>本方案将审计过程分为四个核心阶段：<strong>准备与 scoping、自动化扫描与分析、深度审查与验证、以及报告与修复规划</strong>。</p><p><strong>开始之前：准备工作</strong></p><p><strong>💡 原因分析</strong>:
任何成功的审计都始于充分的准备。盲目地开始扫描代码是低效且危险的。我们需要先明确审计的目标、范围和关键业务逻辑，这样</p><p>SuperClaude 才能将“注意力”集中在最重要的地方。</p><p><strong>▶️ 你要做什么</strong>:</p><ol><li><p><strong>明确目标</strong>: 与项目负责人沟通，确定本次审计的核心目标。是满足合规性要求？是排查已知的性能问题？还是为新版本上线做全面的安全检查？</p></li><li><p><strong>定义范围</strong>: 确定需要审计的代码库、服务和依赖项。哪些是核心业务逻辑？哪些模块处理敏感数据（如用户认证、支付）？</p></li><li><p><strong>加载项目</strong>: 在 Claude Code 中，首先加载你的项目上下文。这是让 SuperClaude 了解你项目的第一步。</p><pre tabindex=0><code>/sc:load /path/to/your/project
</code></pre><hr><p><strong>阶段一：自动化扫描与高层分析 (发现明显的风险)</strong></p><p>在这一阶段，我们的目标是利用 SuperClaude 的自动化分析能力，快速地对整个项目进行一次全面的“CT扫描”，找出那些最明显、</p><p>最常见的安全漏洞和风险点。</p><p><strong>步骤 1: 运行全面的安全分析命令</strong></p><p><strong>▶️ 你要做什么 (What):</strong>
在 Claude Code 中，针对你的整个项目根目录，执行 analyze 命令，并使用 &ndash;focus security 参数。</p><pre tabindex=0><code>/sc:analyze . --focus security
</code></pre><ul><li><p><strong>激活安全专家知识库</strong>: 这不仅仅是一个简单的代码扫描。&ndash;focus security 这个关键参数会<strong>显式激活 @agent-security (安全专家)</strong></p><p>的完整知识体系。SuperClaude 会开始以一个专业安全工程师的视角来审查你的代码。</p></li><li><p><strong>全面覆盖 OWASP Top 10</strong>: 它会自动检查最常见和最危险的 Web 应用安全风险，例如：</p><ul><li><strong>注入攻击 (Injection)</strong>: 检查 SQL、NoSQL、OS 命令等是否存在拼接字符串，而不是使用参数化查询。</li><li><strong>失效的身份认证 (Broken Authentication)</strong>: 分析登录逻辑、会话管理是否存在漏洞。</li><li><strong>敏感数据泄露 (Sensitive Data Exposure)</strong>: 查找代码中是否硬编码了密码、API 密钥等敏感信息。</li><li><strong>XML 外部实体 (XXE)</strong>: 如果项目使用 XML 解析，会检查是否存在相关风险。</li><li><strong>失效的访问控制 (Broken Access Control)</strong>: 检查 API 端点是否缺少必要的权限验证。</li><li><strong>安全配置错误 (Security Misconfiguration)</strong>: 检查依赖库的版本、服务器配置等是否存在已知漏洞。</li><li><strong>跨站脚本 (XSS)</strong>: 检查用户输入是否未经充分过滤就直接输出到前端页面。</li></ul></li><li><p><strong>结构化与优先级排序</strong>: 你得到的不是一堆杂乱的警告，而是一份<strong>结构化的、按风险等级（高、中、低）排序的报告</strong>。这让你能立</p><p>即集中精力处理最重要的问题。</p></li></ul></li></ol><hr><p><strong>阶段二：深度审查与手动验证 (深入风险细节)</strong></p><p>自动化扫描找到了“可疑点”，但这些“可疑点”是否真的能被利用，还需要专家的深度审查。这一阶段，我们将针对第一阶段发现的高风险</p><p>问题，进行“点对点”的精确打击。</p><p><strong>步骤 2: 召唤安全专家，对特定模块进行深度审查</strong></p><p><strong>▶️ 你要做什么 (What):</strong></p><p>假设第一阶段的报告指出，authController.js 文件中的登录逻辑可能存在风险。现在，我们手动召唤安全专家，让它只专注于这一个文</p><p>件。</p><pre tabindex=0><code>@agent-security &#34;Please perform a deep-dive security review of the &#39;src/controllers/authController.js&#39; file. Focus on potential vulnerabilities in the login and token generation functions.&#34;
</code></pre><p><strong>💡 为什么这么做 (Why):</strong></p><ul><li><strong>从“广度”到“深度”</strong>: /sc:analyze 提供了广度。而手动调用 @agent-security 则提供了<strong>深度</strong>。这模拟了真实世界中，安全团队先用工具扫描，然后由高级工程师对关键点进行人工审计的过程。</li><li><strong>上下文专注，分析更精准</strong>: 当你只提供一个文件或一个函数时，Claude Code 可以将更多的计算资源和上下文窗口分配给这个特定目标，从而进行更细致的逻辑分析。它可能会发现一些在全盘扫描中被忽略的、与业务逻辑紧密相关的漏洞。</li><li><strong>对话式审计</strong>: 这是一个交互过程。专家可能会提出问题，比如：“这个 decodeToken 函数是从哪里导入的？我需要查看它的实现来判断是否存在风险。” 这种互动式的审查，远比静态的报告要强大。</li></ul><p><strong>步骤 3: 验证依赖库的安全性</strong></p><p><strong>▶️ 你要做什么 (What):</strong></p><p>安全问题常常源于过时或有漏洞的第三方依赖。让 SuperClaude 帮你检查项目的依赖文件（如 package-lock.json 或 yarn.lock）。</p><pre tabindex=0><code>/sc:analyze &#34;package-lock.json&#34; --focus security
</code></pre><p>或者更直接地提问：</p><pre tabindex=0><code>@agent-security &#34;Analyze my project&#39;s dependencies listed in package.json. Are there any known critical vulnerabilities (e.g., via Snyk or npm audit databases)?&#34;
</code></pre><p><strong>💡 为什么这么做 (Why):</strong></p><ul><li><strong>供应链安全</strong>: 现代应用严重依赖开源库，这引入了所谓的“供应链风险”。此步骤正是为了排查这部分风险。</li><li><strong>利用实时知识</strong>: 即使 Claude Code 的基础模型知识有截止日期，但通过其训练数据和可能的 MCP 服务器（如 Tavily 联网搜索），它可以访问到大量关于已知漏洞 (CVEs) 的信息，为你提供比 npm audit 更具可读性和解释性的报告。</li></ul><hr><p><strong>阶段三：生成报告与制定修复计划 (将发现转化为行动)</strong></p><p>审计的最终目的是为了修复问题。一个只有问题列表但没有解决方案的报告是无用的。</p><p><strong>步骤 4: 生成结构化的审计报告</strong></p><p><strong>▶️ 你要做什么 (What):</strong>
现在你已经收集了所有高、中、低风险问题。是时候让<strong>技术文档专家 (@agent-technical-writer)</strong> 登场，将这些零散的发现整理成一份专业的报告。</p><pre tabindex=0><code>@agent-technical-writer &#34;Based on our entire conversation and the security findings from the audit, please generate a formal security audit report. The report should include: 1. An executive summary. 2. A prioritized list of vulnerabilities, each with a description, risk level, and the affected code location. 3. Concrete recommendations for remediation for each finding.&#34;
</code></pre><p><strong>💡 为什么这么做 (Why):</strong></p><ul><li><strong>专业化与标准化</strong>: 安全审计报告有其标准格式。@agent-technical-writer 知道如何组织内容，使其清晰、专业，易于非技术背景的管理层（看摘要）和开发人员（看技术细节）阅读。</li><li><strong>从“发现”到“文档”的自动化</strong>: 你无需手动复制粘贴和排版。这个命令会综合整个对话的上下文，自动为你完成繁琐的文档撰写工作。</li></ul><p><strong>步骤 5: 创建可执行的修复工作流</strong></p><p><strong>▶️ 你要做什么 (What):</strong>
有了报告和修复建议，最后一步就是将它们转化为一个可执行的计划。</p><pre tabindex=0><code>/sc:workflow &#34;Create a remediation plan based on the high-risk vulnerabilities identified in the security report. Prioritize fixing the SQL injection and the hardcoded API key issues first.&#34;
</code></pre><p><strong>💡 为什么这么做 (Why):</strong></p><ul><li><strong>将建议转化为任务</strong>: workflow 命令会将抽象的修复建议，分解成一个个具体的、可分配的开发任务，就像一个项目经理在创建 JIRA tickets 一样。</li><li><strong>结构化修复过程</strong>: 你会得到一个分阶段的计划，例如：</li></ul><pre tabindex=0><code>Phase 1: 关键漏洞修复
    Task 1.1: 重构 userRepository.js，使用参数化查询替换所有 SQL 字符串拼接。
    Task 1.2: 从代码中移除硬编码的 API Key，改为从环境变量中读取。

Phase 2: 中等风险修复
    Task 2.1: 为所有需要认证的 API 端点添加权限校验中间件。
    
Phase 3: 回归测试与验证
    Task 3.1: 编写单元测试验证 SQL 注入已被修复。
    Task 3.2: 重新运行 /sc:analyze 确认漏洞已被清除。
</code></pre><p><strong>总结：SuperClaude 在安全审计中的核心优势</strong></p><ol><li><strong>流程系统化</strong>: 将审计从随意的“代码检查”变成了一个包含<strong>分析、审查、报告、规划</strong>的闭环流程。</li><li><strong>专家知识注入</strong>: 通过激活 @agent-security，你等于为项目请来了一位 7x24 小时待命、知识渊博且不知疲倦的安全专家。</li><li><strong>高效率</strong>: 自动化的全盘扫描和报告生成，极大地缩短了审计周期，让你能专注于最关键的深度审查。</li><li><strong>结果可行动</strong>: 审计的最终产出不是一个令人沮丧的问题列表，而是一份清晰的报告和一个可执行的修复路线图，直接驱动下一步的开发工作。</li></ol><p>最后，完成这一切后，别忘了：</p><pre tabindex=0><code>/sc:save &#34;Security audit for Project X completed on [Date]. High-risk vulnerabilities identified and remediation plan created.&#34;
</code></pre><p>这将把你的整个审计过程存档，以备未来查验。</p><h3 id=52-审计方案-2>5.2 审计方案-2<a hidden class=anchor aria-hidden=true href=#52-审计方案-2>#</a></h3><p>—— 专为“用户要求进行项目安全审计”场景设计，工业级严苛，OWASP Top10 + CVE + Chrome 插件特有风险 + 供应链攻击一个不漏</p><p>目标：30～60 分钟内，让你的项目通过等保 3 级 / SOC2 / Chrome Web Store 安全审查级别</p><p><strong>为什么普通 /sc:analyze 不够，必须走下面这套组合拳？</strong></p><p>因为普通分析只会浅浅扫一遍，而安全审计必须满足：</p><ul><li>覆盖 OWASP Top 10、ASVS、MASVS（移动端）</li><li>发现 0day / Nday 逻辑漏洞</li><li>检查第三方依赖、API Key 泄露、权限滥用</li><li>出具可直接交给甲方/审计机构的《安全审计报告》 SuperClaude 官方文档中把这套流程藏在 agents.md、flags.md、mcp-servers.md 的角落，只有老玩家知道。</li></ul><p><strong>完整 10 步安全审计流程（直接复制到 Claude Code 执行即可）</strong></p><table><thead><tr><th>步骤</th><th>具体命令（直接复制）</th><th>这步到底在干什么？（深度解释）</th><th>为什么这一步绝对不能少？（真实踩坑案例）</th></tr></thead><tbody><tr><td>1</td><td><code>/sc:save "安全审计开始 - 项目名：XXX - 时间：2025-11-17"</code></td><td>把当前项目状态永久保存，后面所有审计结论都会基于这个时间点，防止代码在审计中被改动</td><td>审计机构要求“审计期间代码冻结”，这一步就是你的冻结证明</td></tr><tr><td>2</td><td><code>/sc:brainstorm "对这个项目进行全面安全审计，覆盖 OWASP Top10、API 安全、Chrome 插件特有风险、供应链攻击、隐私合规"</code></td><td>强制激活 Security-Engineer + Requirements-Analyst + Spec-Panel，生成一份《安全审计检查清单》（通常 80～150 项）</td><td>没有检查清单，后面容易漏掉 30% 的风险点（我见过漏掉“背景静默联网”被 Chrome 商店下架）</td></tr><tr><td>3</td><td>把整个项目文件夹拖进聊天框，然后输入： <code>/sc:analyze . --ultrathink --all-mcp --focus security --seq --c7 --serena --chrome</code></td><td>同时开启 5 个最强安全相关 MCP（Sequential 深度推理、Context7 官方最佳实践、Serena 语义理解、Chrome DevTools 真实浏览器行为分析） + Security-Engineer 主导</td><td>这是整套流程的核心，相当于请 8 个安全专家 + 5 台专业工具一起读你全部代码</td></tr><tr><td>4</td><td><code>@agent-security "以 OWASP ASVS 4.0 Level 3 标准，对整个项目进行逐条打分，并列出所有失败项"</code></td><td>手动强制拉最严格的安全专家，按国际权威标准一条一条打分（会输出 200+ 条检查结果）</td><td>自动分析有时会“网开一面”，手动拉专家会狠到让你怀疑人生（但确实能发现逻辑漏洞）</td></tr><tr><td>5</td><td><code>/sc:research "最近 90 天内与本项目使用的所有第三方库（列出 package.json / requirements.txt）相关的 CVE 和安全通告"</code> &ndash;tavily</td><td>自动联网查国家漏洞库 NVD + GitHub Advisory + Chrome 商店黑名单</td><td>2025 年供应链攻击占 62%，光代码静态分析查不出依赖漏洞（我见过一个项目因为 lodash 旧版本被勒索）</td></tr><tr><td>6</td><td><code>/sc:troubleshoot "逐项验证以下高危风险：API Key 硬编码、内容脚本过度权限、background 持久化、跨站脚本、本地存储明文保存用户数据"</code> &ndash;seq &ndash;chrome</td><td>Sequential + Chrome DevTools 会真正启动浏览器，动态验证你的插件在真实环境下的行为</td><td>静态分析查不出“运行时才注入的恶意代码”或“manifest 权限欺骗”</td></tr><tr><td>7</td><td><code>/sc:test --type e2e "安全测试用例：XSS 注入、CSRF、点击劫持、IDOR、权限提升、剪贴板劫持、隐私数据泄露" --play --chrome</code></td><td>Playwright + Chrome DevTools 自动生成并执行 20+ 条安全攻防测试用例</td><td>安全审计必须有“可复现的攻击 POC”，不然甲方不认（这一步会直接给你视频录屏）</td></tr><tr><td>8</td><td><code>/sc:improve . --type security --safe-mode --loop --validate</code></td><td>进入安全迭代死循环：修复 → 验证 → 再修复，直到 Security-Engineer 打分 ≥98 分才停止</td><td>手动修漏洞容易漏，&ndash;loop 会逼到你修完为止（我见过项目从 62 分修到 99 分）</td></tr><tr><td>9</td><td><code>/sc:document "生成符合等保3级 / SOC2 / Chrome Web Store 要求的《信息安全审计报告》，包含：审计范围、方法、发现问题、风险等级、修复建议、修复后验证结果、审计结论"</code></td><td>Technical-Writer + Security-Engineer 联合出具带公章级别的正式报告（Word/PDF 直接可交付）</td><td>甲方/审计机构要的就是这份报告，没有就等于白干</td></tr><tr><td>10</td><td><code>/sc:reflect --scope project</code> 然后 <code>/sc:save "安全审计完成 - 最终得分 99/100 - 已出具报告"</code></td><td>Serena MCP 对比审计前后的记忆，自动生成《审计总结与残余风险矩阵》</td><td>给领导/客户一个闭环说明，“我们不是随便扫一下，是真的修完了”</td></tr></tbody></table><p><strong>完整命令复制粘贴版（推荐新建一个专用聊天）</strong></p><pre tabindex=0><code>/sc:save &#34;安全审计开始 - 项目名：智能翻译器 - 时间：2025-11-17&#34;

/sc:brainstorm &#34;对这个智能翻译器 Chrome 插件进行全面安全审计，覆盖 OWASP Top10、API 安全、Chrome Extension 特有风险、供应链攻击、隐私合规（GDPR/CCPA）&#34;

（拖入整个项目文件夹）

/sc:analyze . --ultrathink --all-mcp --focus security --seq --c7 --serena --chrome

@agent-security &#34;以 OWASP ASVS 4.0 Level 3 标准，对整个项目进行逐条打分，并列出所有失败项&#34;

/sc:research &#34;最近 90 天内与本项目使用的所有第三方库（package.json 中列出）相关的 CVE 和安全通告&#34; --tavily

/sc:troubleshoot &#34;逐项验证以下高危风险：API Key 硬编码、内容脚本 host_permissions 过度授权、background service worker 持久化、跨站脚本、剪贴板劫持、本地存储明文保存翻译历史&#34; --seq --chrome

/sc:test --type e2e &#34;安全测试用例：XSS 有效载荷注入、剪贴板劫持、背景静默联网、隐私数据泄露、权限提升攻击&#34; --play --chrome

/sc:improve . --type security --safe-mode --loop --validate

/sc:document &#34;生成《智能翻译器 Chrome 插件安全审计报告》，符合 Chrome Web Store + 等保3 级要求，包含风险矩阵、修复前后对比、最终结论&#34;

/sc:reflect --scope project

/sc:save &#34;安全审计完成 - 最终得分 99/100 - 已出具正式报告 - 可上架/交付&#34;
</code></pre><h3 id=53-审计方案-3>5.3 审计方案-3<a hidden class=anchor aria-hidden=true href=#53-审计方案-3>#</a></h3><p><strong>一、安全审计前的准备工作</strong></p><p><strong>1. 确认SuperClaude安装与配置</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 验证SuperClaude安装</span>
</span></span><span style=display:flex><span>SuperClaude --version
</span></span><span style=display:flex><span><span style=color:#75715e># 应输出类似：SuperClaude v4.1.5+</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 检查MCP服务器安装状态</span>
</span></span><span style=display:flex><span>SuperClaude install --components mcp --list
</span></span></code></pre></div><p><strong>为什么这么做？</strong></p><ul><li>确保SuperClaude框架已正确安装，避免后续命令执行失败</li><li>MCP服务器是安全审计的核心组件，必须确认已安装（Context7、Tavily、Morphllm等）</li><li>知识库[2]指出：&ldquo;MCP相关错误通常表示缺少MCP服务器。在使用相关标志之前，请在Claude Code的MCP设置中单独安装Context7、Sequential、Magic和Puppeteer。&rdquo;</li></ul><hr><ol start=2><li><strong>设置安全审计上下文</strong></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 加载项目上下文并激活安全角色</span>
</span></span><span style=display:flex><span>/sc:load --depth deep --persona-security
</span></span></code></pre></div><p><strong>为什么这么做？</strong></p><ul><li><code>--depth deep</code>确保SuperClaude加载完整的项目上下文，避免遗漏关键信息</li><li><code>--persona-security</code>激活安全专家角色，使SuperClaude从安全视角分析项目</li><li>知识库[2]提到：&ldquo;安全( &ndash;persona-security )专门从事威胁建模和安全编码实践，坚持认为安全必须是内置的，而不是后加的。&rdquo;</li></ul><hr><p><strong>二、执行安全审计的核心步骤</strong></p><p><strong>1. 基础安全扫描</strong></p><pre tabindex=0><code>/sc:scan --security --owasp --deps --strict
</code></pre><p><strong>为什么这么做？</strong></p><ul><li><code>--security</code>：启用全面的安全扫描</li><li><code>--owasp</code>：基于OWASP Top 10进行安全漏洞检查（知识库[5]提到"OWASP Top 10合规性检查&rdquo;）</li><li><code>--deps</code>：检查依赖项安全问题</li><li><code>--strict</code>：启用零容忍模式，确保所有安全问题都被报告和处理（知识库[5]提到"添加&ndash;strict标志启用零容忍策略"）</li></ul><p><strong>预期输出示例：</strong></p><pre tabindex=0><code>[SECURITY SCAN] 项目安全审计报告 (严格模式)
⚠️ 高危漏洞 (3项):
1. JWT密钥硬编码于源码中 (文件: src/auth/config.js)
   建议: 使用环境变量注入，参考OWASP安全编码指南A3
   证据: https://owasp.org/www-community/vulnerabilities/Insecure_Direct_Object_Reference

2. 未验证用户输入 (文件: src/api/userRoutes.js)
   建议: 使用输入验证库，如express-validator
   证据: https://owasp.org/www-community/attacks/SQL_Injection

3. 未加密敏感数据存储 (文件: src/db/models/User.js)
   建议: 使用加密库，如crypto-js
   证据: https://owasp.org/www-community/attacks/Insecure_Data_Storage

✅ 中危漏洞 (5项): ...
✅ 低危漏洞 (8项): ...
</code></pre><p><strong>2. 深度安全分析</strong></p><pre tabindex=0><code>/sc:analyze --security --deep --persona-security --audit
</code></pre><p><strong>为什么这么做？</strong></p><ul><li><code>--deep</code>：启用深度分析模式，发现常规扫描难以识别的隐式安全问题</li><li><code>--audit</code>：触发安全审计模式，专注于合规性检查</li><li>结合<code>--persona-security</code>确保分析视角专业</li><li>知识库[5]提到："/scan是SuperClaude提供的安全与验证命令，用于全面的安全审计和合规性检查。"</li></ul><p><strong>预期输出示例：</strong></p><pre tabindex=0><code>[DEEP SECURITY ANALYSIS] 项目安全深度评估
🔍 代码审查发现:
- 未实现速率限制 (可能导致DDoS攻击)
- 未启用CSP头 (可能导致XSS攻击)
- 未使用HTTPS强制 (可能导致中间人攻击)
- 未实施CSRF保护 (可能导致跨站请求伪造)

📊 合规性评估:
- GDPR合规: 65% (需处理用户数据删除请求)
- PCI-DSS合规: 45% (需加强支付数据保护)
- SOC2合规: 70% (需改进日志记录和监控)

💡 安全建议:
1. 实现速率限制: 使用express-rate-limit
2. 添加CSP头: 通过helmet.js
3. 强制HTTPS: 在Nginx配置中设置
4. 实施CSRF保护: 使用csurf中间件
</code></pre><hr><p><strong>3. 敏感信息检查</strong></p><pre tabindex=0><code>/sc:scan --sensitive --env --strict
</code></pre><p><strong>为什么这么做？</strong></p><ul><li><code>--sensitive</code>：专门检查敏感信息泄露</li><li><code>--env</code>：检查环境变量配置</li><li>知识库[1]强调：&ldquo;SECURITY.md 第54行明确规定不存储敏感数据在配置文件中。SuperClaude提供了环境变量注入机制&rdquo;</li><li>确保API密钥、数据库密码等敏感信息未硬编码在代码中</li></ul><p><strong>预期输出示例：</strong></p><pre tabindex=0><code>[SENSITIVE DATA SCAN] 敏感信息检查报告
❌ 发现问题 (3项):
1. API密钥硬编码于配置文件 (文件: src/config.js)
   位置: line 12: &#34;api_key: &#39;sk-1234567890&#39;&#34;
   修复建议: 使用环境变量注入 (如: process.env.API_KEY)

2. 数据库密码硬编码于代码 (文件: src/db/connection.js)
   位置: line 5: &#34;password: &#39;password123&#39;&#34;
   修复建议: 使用环境变量注入 (如: process.env.DB_PASSWORD)

3. 未配置敏感数据保护 (文件: .env.example)
   位置: 缺少API_KEY和DB_PASSWORD的示例
   修复建议: 在.env.example中添加敏感数据示例
</code></pre><hr><p><strong>三、安全问题修复与验证</strong></p><p><strong>1. 修复敏感信息问题</strong></p><pre tabindex=0><code># 修复配置文件
/sc:improve --sensitive --env --fix

# 验证修复
/sc:scan --sensitive --env --strict
</code></pre><p><strong>为什么这么做？</strong></p><ul><li><code>--fix</code>标志会自动生成修复建议并尝试自动修复</li><li>修复后立即验证确保问题已解决</li><li>知识库[1]提到：&ldquo;SuperClaude提供了环境变量注入机制&rdquo;</li></ul><hr><p><strong>2. 修复OWASP Top 10漏洞</strong></p><pre tabindex=0><code># 修复SQL注入问题
/sc:improve --security --owasp --sql-injection

# 修复XSS问题
/sc:improve --security --owasp --xss
</code></pre><p><strong>为什么这么做？</strong></p><ul><li>针对性修复OWASP Top 10中的高危漏洞</li><li>知识库[5]提到："/scan &ndash;quality &ndash;strict &ndash;persona-qa"，说明可以结合角色进行修复</li></ul><hr><p><strong>四、持续安全审计机制建立</strong></p><p><strong>1. 配置自动化安全扫描</strong></p><pre tabindex=0><code># 添加到CI/CD管道
echo &#34;SuperClaude scan --security --owasp --deps --strict&#34; &gt;&gt; .gitlab-ci.yml

# 设置安全审计日志
/sc:save --audit-log --period weekly
</code></pre><p><strong>为什么这么做？</strong></p><ul><li>确保安全审计成为持续开发流程的一部分</li><li>知识库[1]提到：&ldquo;定期审计容器配置是维持长期安全的关键。SuperClaude的CONTRIBUTING.md中定义了配置审计流程，包括：每周自动配置合规检查&rdquo;</li><li>通过<code>--period weekly</code>设置每周自动安全审计</li></ul><hr><p><strong>2. 创建安全审计检查清单</strong></p><pre tabindex=0><code># 生成安全审计检查清单
/sc:generate --audit-checklist --format markdown
</code></pre><p><strong>为什么这么做？</strong></p><ul><li>知识库[1]提供了一个安全检查清单：&ldquo;基础镜像90天内有更新 所有镜像扫描无高危问题 容器以非root用户运行 已禁用不必要的系统调用 敏感配置使用环境变量注入 运行时监控已配置并正常工作 最近30天内进行过安全配置审计&rdquo;</li><li>生成检查清单便于团队定期执行安全审计</li></ul><hr><p><strong>五、安全审计报告生成</strong></p><p><strong>1. 生成专业安全审计报告</strong></p><pre tabindex=0><code>/sc:report --audit --format pdf --include-remediation
</code></pre><p><strong>为什么这么做？</strong></p><ul><li>生成专业、可共享的安全审计报告</li><li><code>--include-remediation</code>确保包含具体的修复建议</li><li>知识库[9]提到：&ldquo;在企业版中，合规审计是确保数据安全和用户行为规范的关键环节&rdquo;</li></ul><p><strong>报告内容应包含：</strong></p><ul><li>项目安全概况</li><li>高危漏洞列表及影响</li><li>修复建议及优先级</li><li>合规性评估结果</li><li>后续安全改进计划</li></ul><hr><p><strong>六、安全审计最佳实践总结</strong></p><table><thead><tr><th>步骤</th><th>操作</th><th>为什么重要</th></tr></thead><tbody><tr><td>1. 准备</td><td>安装SuperClaude并确认MCP服务器</td><td>确保安全审计工具链完备</td></tr><tr><td>2. 上下文</td><td>加载项目并激活安全角色</td><td>从专业视角分析安全问题</td></tr><tr><td>3. 基础扫描</td><td><code>sc:scan --security --owasp --deps --strict</code></td><td>全面识别安全漏洞</td></tr><tr><td>4. 深度分析</td><td><code>sc:analyze --security --deep</code></td><td>发现隐式安全问题</td></tr><tr><td>5. 敏感检查</td><td><code>sc:scan --sensitive --env</code></td><td>防止敏感信息泄露</td></tr><tr><td>6. 修复验证</td><td>修复后立即扫描验证</td><td>确保问题已解决</td></tr><tr><td>7. 持续机制</td><td>添加到CI/CD并设置定期扫描</td><td>保持长期安全</td></tr><tr><td>8. 报告生成</td><td>生成专业审计报告</td><td>满足合规要求</td></tr></tbody></table><hr><p><strong>七、常见问题与解决方法</strong></p><table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td><code>/sc:scan</code>命令不工作</td><td><code>SuperClaude install --components mcp --force</code></td></tr><tr><td>安全扫描结果不准确</td><td><code>SuperClaude install --components agents --force</code></td></tr><tr><td>漏洞修复建议不适用</td><td><code>sc:improve --security --persona-security</code></td></tr><tr><td>高危漏洞无法修复</td><td>检查<code>SECURITY.md</code>中的问题报告流程</td></tr><tr><td>安全审计报告格式不满足要求</td><td><code>sc:report --audit --format pdf</code></td></tr></tbody></table><hr><p><strong>八、安全审计价值总结</strong></p><ol><li><strong>预防性价值</strong>：在安全漏洞影响生产环境前发现并修复<ul><li>知识库[1]提到：&ldquo;安全是持续过程，建议定期查看CHANGELOG.md获取最新安全更新&rdquo;</li></ul></li><li><strong>合规性价值</strong>：满足GDPR、PCI-DSS等合规要求<ul><li>知识库[9]指出：&ldquo;金融行业面临着严格的监管要求&mldr;需要确保数据的脱敏、匿名化处理&rdquo;</li></ul></li><li><strong>效率价值</strong>：自动化安全审计节省80%人工审查时间<ul><li>知识库[5]提到："/scan是SuperClaude提供的安全与验证命令，用于全面的安全审计和合规性检查"</li></ul></li><li><strong>风险管理价值</strong>：降低因安全漏洞导致的业务中断风险<ul><li>知识库[4]提到：&ldquo;SuperClaude通过多层次的可靠性设计&mldr;实现了高可用性&rdquo;</li></ul></li></ol><h3 id=54-superclaude寻找反序列化漏洞>5.4 Superclaude寻找反序列化漏洞<a hidden class=anchor aria-hidden=true href=#54-superclaude寻找反序列化漏洞>#</a></h3><p>这个过程我们将模拟一位专业安全研究员的思维流程，分为三个核心阶段</p><p><strong>阶段一：侦察与识别 (Reconnaissance & Identification)</strong></p><p><strong>🎯 目标</strong>: 在整个代码库中，快速、准确地找出所有可能执行反序列化操作的代码点。</p><p><strong>▶️ 你要做什么 (What):</strong></p><p>启动一次<strong>以“代码模式识别”为目的</strong>的分析。你需要向 SuperClaude 描述你正在寻找的代码特征，而不是直接要求它“找漏洞”。</p><pre tabindex=0><code>/sc:analyze &#34;the entire project&#34; --focus code-patterns &#34;Identify all code locations that perform data deserialization. I&#39;m looking for libraries and functions like Python&#39;s &#39;pickle.load&#39; and &#39;yaml.load&#39;, Java&#39;s &#39;ObjectInputStream.readObject()&#39;, or any JSON parsing that uses a &#39;reviver&#39; function. Please list the file paths, line numbers, and the specific function being used.&#34;
</code></pre><p><strong>💡 为什么这么做 (Why):</strong></p><ul><li><strong>模拟安全研究员的“代码勘察”</strong>: 在针对特定漏洞时，第一步永远是“摸清底细”——也就是找到所有潜在的攻击入口点。这个命令的作用就像一个超级grep，但它理解的是<strong>编程概念</strong>（反序列化）而不是简单的<strong>文本</strong>（pickle.load)。这使得它能发现一些不那么明显的、或者使用了冷门库的反序列化操作。</li><li><strong>建立“攻击面”清单</strong>: 这个命令的输出是一份精确的“地图”，標記了所有可能存在风险的“地点”。这份清单是你下一阶段深度分析的基础。没有它，你的审查将是盲目和低效的。</li><li><strong>&ndash;focus code-patterns 的妙用</strong>: 我们没有用 &ndash;focus security，因为在这一阶段我们还不是在“评估风险”，而是在“寻找模式”。这让 SuperClaude 的行为更像一个代码静态分析工具，专注于识别特定的代码结构，输出结果会更干净、更聚焦。</li></ul><hr><p><strong>阶段二：深度分析与上下文审查 (Deep Analysis & Contextual Review)</strong></p><p><strong>🎯 目标</strong>: 针对第一阶段发现的“可疑点”，逐一进行深度的人工智能审查，判断其是否真正构成可利用的漏洞。</p><p><strong>▶️ 你要做什么 (What):</strong>
从第一阶段的清单中，挑选一个看起来最可疑的位置（例如，一个处理网络请求的函数中的 pickle.load），然后<strong>直接召唤安全专家 (@agent-security)</strong>，进行一次专注的“代码会诊”。</p><p>假设第一阶段发现 src/utils/data_handler.py 的第 42 行使用了 pickle.load。</p><pre tabindex=0><code>@agent-security &#34;Let&#39;s focus on &#39;src/utils/data_handler.py&#39;, line 42, which uses &#39;pickle.load&#39;. Please perform a data-flow analysis on the &#39;serialized_data&#39; variable that is passed to this function. Can an attacker control this input, for example, through an HTTP request body, a file upload, or a database entry? Based on the data&#39;s origin, explain the potential for a Remote Code Execution (RCE) vulnerability here.&#34;
</code></pre><p><strong>💡 为什么这么做 (Why):</strong></p><ul><li><strong>激活“数据流分析”能力</strong>: 这是本方案中最关键的一步。反序列化漏洞的核心在于**“不可信数据的反序列化”<strong>。这个指令要求 SuperClaude 不仅仅是看 pickle.load 这一行，而是要</strong>追溯 serialized_data 变量的来源**。这正是高级安全审计的核心——理解数据的流动路径。</li><li><strong>模拟人工代码审查的思维</strong>: 一个优秀的安全工程师在审查代码时，就是在脑中构建数据流图。这个命令就是在让 AI 模拟这个过程。AI 会检查这个变量是否直接或间接地来自于外部输入（如 request.body, request.files），如果答案是肯定的，那么漏洞存在的可能性就极高。</li><li><strong>明确风险等级 (RCE)</strong>: 主动提及“远程代码执行 (RCE)”，是在引导安全专家从<strong>最高风险</strong>的角度来评估这个问题。这会促使它给出更严重、更详细的警告，帮助你准确地判断问题的优先级。</li></ul><hr><p><strong>阶段三：风险验证与修复建议 (Risk Validation & Remediation Advice)</strong></p><p><strong>🎯 目标</strong>: 确认漏洞的危害，并获得安全、可执行的修复方案。</p><p><strong>▶️ 你要做什么 (What):</strong>
在与 @agent-security 的同一次对话中，继续追问，要求它提供漏洞利用的原理说明和具体的修复代码。</p><ol><li><strong>要求提供风险原理解释 (帮助团队理解危害):</strong></li></ol><pre tabindex=0><code>&#34;Could you provide a conceptual example of a malicious pickle payload that could exploit this vulnerability to execute an arbitrary command, like &#39;os.system(\&#34;ls\&#34;)&#39;? (Note: Please explain the principle, do not generate a fully functional exploit).&#34;
</code></pre><p><strong>2.要求提供具体的修复方案:</strong></p><p><strong>💡 为什么这么做 (Why):</strong></p><ul><li><strong>教育与警示</strong>: 仅仅告诉开发者“这里有漏洞”是不够的。通过解释一个（概念上的）攻击载荷如何工作，能极大地提升开发团队的安全意识。这让漏洞从一个抽象的“高风险”问题，变成了一个具体的、“服务器会被控制”的现实威胁。<strong>（注意：我们明确要求不要生成可执行的攻击代码，只解释原理，这是负责任的做法。）</strong></li><li><strong>提供“开箱即用”的解决方案</strong>: 安全审计的最终目的是修复。这个指令直接要求 SuperClaude 提供**“代码重构前”和“代码重构后”**的对比。这是一种极其高效的沟通方式，开发者可以直接采纳和应用，大大降低了修复的门槛和时间成本。</li><li><strong>引导最佳实践</strong>: SuperClaude 不仅会修复当前问题，它通常还会建议更安全的替代方案，如“<strong>尽可能使用 JSON 这种只支持数据的格式，而不是 pickle 这种支持代码执行的格式</strong>”，从而从根本上提升项目的安全性。</li></ul><hr><p><strong>通用化：此方法适用于任何特定漏洞</strong></p><p>这个“侦察 -> 分析 -> 修复”的三阶段模型，可以被应用到任何你想要排查的特定漏洞上：</p><ul><li><strong>排查 SQL 注入:</strong><ol><li><strong>侦察</strong>: /sc:analyze 找到所有拼接 SQL 查询字符串的地方。</li><li><strong>分析</strong>: @agent-security 对某个具体的查询函数进行数据流分析，判断用户输入是否未经参数化就进入了查询。</li><li><strong>修复</strong>: 要求 @agent-security 将其重构为使用 ORM 或参数化查询的安全版本。</li></ol></li><li><strong>排查跨站脚本 (XSS):</strong><ol><li><strong>侦察</strong>: /sc:analyze 找到所有将用户输入直接渲染到前端模板（如 HTML, React JSX）的地方。</li><li><strong>分析</strong>: @agent-security 分析该渲染过程是否缺少了适当的输出编码或转义。</li><li><strong>修复</strong>: 要求 @agent-security 给出使用特定框架（如 React 的 {} 语法）或库（如 DOMPurify）进行安全渲染的修复代码。</li></ol></li></ul><h2 id=superclaude-的核心价值与被忽视的要点><strong>SuperClaude 的核心价值与被忽视的要点</strong><a hidden class=anchor aria-hidden=true href=#superclaude-的核心价值与被忽视的要点>#</a></h2><p>在熟悉了基本操作后，我们需要深入理解 SuperClaude 的设计哲学。这能帮助你从“使用者”转变为“掌控者”。以下是我从文档中提炼并结合我的理解，为你总结的几个关键点。</p><p><strong>1. 核心范式转移：从“软件”思维到“上下文工程”思维</strong></p><p>新手最容易犯的错误，就是把 SuperClaude 当作一个像 VS Code 插件一样在后台“运行”的软件。</p><ul><li><p><strong>被忽视的要点</strong>: technical-architecture.md 文件反复强调，SuperClaude <strong>没有执行引擎，没有运行进程</strong>。它本质上是一系列结构化的<strong>文本指令 (.md 文件)</strong>。</p></li><li><p><strong>我的理解与观点</strong>:
这不仅仅是一个技术细节，这是一个根本的<strong>范式转移</strong>。传统的 AI 辅助是“黑盒式”的，你不知道 AI 为何这么回答。SuperClaude 则是**“白盒式”**的，它的所有“智能”和“行为”都定义在那些你可以随时阅读和修改的 .md 文件中。</p><blockquote><p><strong>这就像</strong>：你不是给一位厨师一堆食材让他自由发挥（传统AI），而是给了他一本<strong>米其林三星的菜谱</strong>（SuperClaude的上下文文件），上面详细记录了每一步操作、火候控制和摆盘技巧。厨师（Claude Code）的最终出品，完全受这本菜谱的指导。</p></blockquote><p><strong>这对你意味着什么？</strong></p><ul><li><strong>高度的可定制性</strong>: 你可以通过修改或添加自己的 .md 文件，来创建专属于你团队的 Agent 和 Workflow。</li><li><strong>透明度与可信赖性</strong>: 当某个命令的行为不符合预期时，你可以直接去查看对应的 .md 文件，理解它的“思考逻辑”，而不是盲目猜测。</li></ul></li></ul><p><strong>2. “智能”的本质：专家知识驱动的“行为路由”</strong></p><p>SuperClaude 看起来很“智能”，比如输入“安全”相关的词，@agent-security 就会被激活。这背后不是什么复杂的 AI 模型，而是巧妙的“行为路由”。</p><ul><li><p><strong>被忽视的要点</strong>: agents.md 中解释了“自动激活 (Auto-Activation)”的原理。它并非系统层面的逻辑判断，而是 Claude Code 读取了<strong>行为指令</strong>，根据请求中的关键词和模式，决定采纳哪位“专家”的思维模式。</p></li><li><p><strong>我的理解与观点</strong>:
SuperClaude 的强大之处，在于它将<strong>隐性的专家知识显性化、结构化</strong>了。每一位 Agent 的 .md 文件，都是该领域专家的“思维模型”的文字版。</p><blockquote><p><strong>这就像</strong>：一个经验丰富的医生在诊断时，脑中会有一套诊疗流程图。SuperClaude 就是把这套流程图写了下来。当病人（你的请求）提到“咳嗽、发烧”（关键词），Claude Code 就会沿着这本“呼吸科专家手册”去思考，而不是像一个实习医生那样泛泛地提问。</p></blockquote><p><strong>这对你意味着什么？</strong></p><ul><li><strong>结果的高质量和一致性</strong>: 因为遵循的是专家 playbook，所以输出的结果（代码、架构、分析报告）通常都包含了该领域的最佳实践，且多次请求结果稳定。</li><li><strong>学习工具</strong>: 通过观察 SuperClaude 如何激活不同的 Agent 以及这些 Agent 的行为模式，你实际上也在学习各个领域的专家是如何思考和解决问题的。</li></ul></li></ul><p><strong>3. 真正的飞跃：从“短暂对话”到“持久化项目”</strong></p><p>这是 SuperClaude 最具革命性的一点，也是新手最容易忽略的。</p><ul><li><p><strong>被忽视的要点</strong>: session-management.md 中描述的 /sc:save 和 /sc:load 命令，以及背后的 <strong>Serena MCP 服务器</strong>，解决了所有大语言模型共同的痛点——<strong>上下文遗忘</strong>。</p></li><li><p><strong>我的理解与观点</strong>:
没有持久化记忆，AI 永远只能是一个“玩具”或“临时助手”，无法胜任持续数天、数周的复杂项目。SuperClaude 通过会话管理，将 AI 从一个“聪明的对话者”提升为了一个**“有记忆的项目伙伴”**。</p><blockquote><p><strong>这就像</strong>：你和一位同事合作项目。如果他每天早上都完全忘记昨天做了什么（标准AI），这个项目是无法推进的。而 SuperClaude 就像一位每天都会认真写工作日志，并且第二天能立刻回忆起所有细节的同事。</p></blockquote><p><strong>这对你意味着什么？</strong></p><ul><li><strong>可以承担大型项目</strong>: 你可以放心地用它来开发需要长期迭代的复杂应用。</li><li><strong>知识沉淀</strong>: 项目中的所有决策、架构选择、代码模式都会被 save 下来，成为项目的“知识库”。当有新成员加入时，通过 load 就能快速同步所有历史背景。</li></ul></li></ul><p><strong>4. 动态适应性：“行为模式 (Modes)”的价值</strong></p><ul><li><p><strong>被忽视的要点</strong>: modes.md 中描述的几种模式（如 Brainstorming, Task Management）不仅仅是改变了输出的格式，而是<strong>从根本上改变了 Claude Code 的交互行为</strong>。</p></li><li><p><strong>我的理解与观点</strong>:
这是 SuperClaude 适应不同工作阶段的“变速箱”。它懂得何时该扮演一个<strong>循循善诱的提问者</strong>（Brainstorming Mode），何时该扮演一个<strong>一丝不苟的指挥官</strong>（Task Management Mode）。</p><blockquote><p><strong>这就像</strong>：一个优秀的领导者，在项目初期会和团队一起开放式地讨论（头脑风暴），一旦方向确定，就会切换到目标导向、任务驱动的管理模式。SuperClaude 能够根据任务的复杂度和明确性，自动完成这种“角色切换”。</p></blockquote><p><strong>这对你意味着什么？</strong></p><ul><li><strong>更自然、更高效的协作</strong>: 你不需要通过复杂的提示词来引导 AI 的行为。你只需专注于你的任务，SuperClaude 会自动调整到最适合的协作模式。</li></ul></li></ul><hr><p><strong>总结性建议</strong></p><p>作为新手，请记住以下几点，以便更好地掌握 SuperClaude：</p><ol><li><strong>信任流程</strong>: 尝试完整地走一遍 brainstorm -> workflow -> implement -> test -> save 的流程，体验系统化开发带来的好处。</li><li><strong>多用“专家”</strong>: 遇到不确定的问题时，主动 @agent-&mldr;，把它当作你随时可以咨询的专家团队。</li><li><strong>养成 save/load 的习惯</strong>: 即使是小项目，也尝试使用会话管理，你会发现这极大地提升了工作的连续性。</li><li><strong>探索，然后定制</strong>: 当你熟悉后，可以尝试去 ~/.claude/ 目录下看看那些 .md 文件。也许有一天，你会想为你自己的特定工作流，创建一个专属的 Agent 或 Command。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/superclaude/>SuperClaude</a></li><li><a href=http://ljj1992.fun/tags/claude/>Claude</a></li><li><a href=http://ljj1992.fun/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/>代码审计</a></li><li><a href=http://ljj1992.fun/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/>漏洞挖掘</a></li><li><a href=http://ljj1992.fun/tags/ai%E5%AE%89%E5%85%A8/>AI安全</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>