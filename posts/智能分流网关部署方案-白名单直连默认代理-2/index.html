<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>star徐的博客</title>
<meta name="keywords" content="">
<meta name="description" content="​&mdash;
title: &ldquo;智能分流网关部署方案 (白名单直连默认代理)&rdquo;
date: 2025-11-13T18:00:00&#43;08:00
draft: false
categories: [&ldquo;网络技术&rdquo;]
tags: [&ldquo;网络&rdquo;, &ldquo;WireGuard&rdquo;, &ldquo;ipset&rdquo;, &ldquo;DNS&rdquo;]
​&mdash;
&hellip; (文章的其他内容)
方案概览

核心技术: WireGuard, Dnsmasq, Iptables, IPset, 策略路由
核心策略: 白名单直连，默认代理。
流量路径:

DNS查询:

国内域名 (匹配dnsmasq-china-list): 通过国内DNS (119.29.29.29等) 直接解析，并将结果IP自动加入directlist IP白名单集合。
被墙域名 &amp; 未知域名: 统一通过WireGuard隧道向上游DNS (8.8.8.8) 查询。被墙域名的结果IP会自动加入gfwlist IP集合。


数据传输:

国内IP (匹配directlist IP白名单): 直接连接（走本地出口）。
所有其他IP (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。




核心特性:

DNS查询保护: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。
默认代理: 任何未明确指定为“直连”的流量，都将默认通过隧道，提供更强的隐私保护。
Kill Switch: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。
全自动化: 定时脚本自动更新国内外域名与IP列表，无需人工干预。




第一部分：VPS (服务器端) 配置
VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。
1. 系统准备与软件安装
# 更新系统软件包列表并升级已安装的软件
sudo apt update &amp;&amp; sudo apt upgrade -y

# 安装WireGuard
sudo apt install wireguard -y
2. 启用IP转发
# 编辑sysctl配置文件
sudo nano /etc/sysctl.conf
确保文件中包含以下行（去掉前面的#号）：">
<meta name="author" content="您的姓名">
<link rel="canonical" href="//localhost:1313/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88-%E7%99%BD%E5%90%8D%E5%8D%95%E7%9B%B4%E8%BF%9E%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%90%86-2/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="//localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="//localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="//localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="//localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="//localhost:1313/posts/%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E7%BD%91%E5%85%B3%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88-%E7%99%BD%E5%90%8D%E5%8D%95%E7%9B%B4%E8%BF%9E%E9%BB%98%E8%AE%A4%E4%BB%A3%E7%90%86-2/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="//localhost:1313/" accesskey="h" title="star徐的博客 (Alt + H)">star徐的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="//localhost:1313/" title="首页">
                    <span>首页</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="//localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="//localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta"><span>您的姓名</span>

</div>
  </header> 
  <div class="post-content"><p>​&mdash;
title: &ldquo;智能分流网关部署方案 (白名单直连默认代理)&rdquo;
date: 2025-11-13T18:00:00+08:00
draft: false
categories: [&ldquo;网络技术&rdquo;]
tags: [&ldquo;网络&rdquo;, &ldquo;WireGuard&rdquo;, &ldquo;ipset&rdquo;, &ldquo;DNS&rdquo;]
​&mdash;
&hellip; (文章的其他内容)</p>
<h2 id="方案概览">方案概览<a hidden class="anchor" aria-hidden="true" href="#方案概览">#</a></h2>
<ul>
<li><strong>核心技术</strong>: WireGuard, Dnsmasq, Iptables, IPset, 策略路由</li>
<li><strong>核心策略</strong>: <strong>白名单直连，默认代理</strong>。</li>
<li><strong>流量路径</strong>:
<ol>
<li><strong>DNS查询</strong>:
<ul>
<li><strong>国内域名</strong> (匹配<code>dnsmasq-china-list</code>): 通过国内DNS (<code>119.29.29.29</code>等) 直接解析，并将结果IP自动加入<code>directlist</code> IP白名单集合。</li>
<li><strong>被墙域名 &amp; 未知域名</strong>: 统一通过WireGuard隧道向上游DNS (<code>8.8.8.8</code>) 查询。被墙域名的结果IP会自动加入<code>gfwlist</code> IP集合。</li>
</ul>
</li>
<li><strong>数据传输</strong>:
<ul>
<li><strong>国内IP</strong> (匹配<code>directlist</code> IP白名单): 直接连接（走本地出口）。</li>
<li><strong>所有其他IP</strong> (包括被墙IP和未知IP): 由于未匹配到白名单，默认被Iptables打上标记，强制通过策略路由进入WireGuard隧道。</li>
</ul>
</li>
</ol>
</li>
<li><strong>核心特性</strong>:
<ul>
<li><strong>DNS查询保护</strong>: 对国外及未知域名的DNS查询本身也被强制通过隧道，防止ISP窥探。</li>
<li><strong>默认代理</strong>: 任何未明确指定为“直连”的流量，都将默认通过隧道，提供更强的隐私保护。</li>
<li><strong>Kill Switch</strong>: VPN隧道意外断开时，自动阻止所有需要走隧道的流量，防止真实IP泄露。</li>
<li><strong>全自动化</strong>: 定时脚本自动更新国内外域名与IP列表，无需人工干预。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第一部分vps-服务器端-配置">第一部分：VPS (服务器端) 配置<a hidden class="anchor" aria-hidden="true" href="#第一部分vps-服务器端-配置">#</a></h2>
<p>VPS作为流量的最终出口，负责将隧道数据转发至公共互联网。</p>
<h3 id="1-系统准备与软件安装">1. 系统准备与软件安装<a hidden class="anchor" aria-hidden="true" href="#1-系统准备与软件安装">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 更新系统软件包列表并升级已安装的软件</span>
</span></span><span style="display:flex;"><span>sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 安装WireGuard</span>
</span></span><span style="display:flex;"><span>sudo apt install wireguard -y
</span></span></code></pre></div><h3 id="2-启用ip转发">2. 启用IP转发<a hidden class="anchor" aria-hidden="true" href="#2-启用ip转发">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 编辑sysctl配置文件</span>
</span></span><span style="display:flex;"><span>sudo nano /etc/sysctl.conf
</span></span></code></pre></div><p>确保文件中包含以下行（去掉前面的<code>#</code>号）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ini" data-lang="ini"><span style="display:flex;"><span><span style="color:#75715e"># 启用IPv4数据包转发</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">net.ipv4.ip_forward</span><span style="color:#f92672">=</span><span style="color:#e6db74">1</span>
</span></span></code></pre></div><p>保存文件后，执行命令使其立即生效：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 从/etc/sysctl.conf加载内核参数</span>
</span></span><span style="display:flex;"><span>sudo sysctl -p
</span></span></code></pre></div><h3 id="3-生成wireguard密钥">3. 生成WireGuard密钥<a hidden class="anchor" aria-hidden="true" href="#3-生成wireguard密钥">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 一步完成生成私钥、保存、计算公钥、保存</span>
</span></span><span style="display:flex;"><span>wg genkey | tee vps_privatekey | wg pubkey &gt; vps_publickey
</span></span></code></pre></div><blockquote>
<p><strong>提示</strong>: 请记下 <code>vps_privatekey</code> 和 <code>vps_publickey</code> 文件的内容。</p>
</blockquote>
<h3 id="4-配置wireguard-etcwireguardwg0conf">4. 配置WireGuard (<code>/etc/wireguard/wg0.conf</code>)<a hidden class="anchor" aria-hidden="true" href="#4-配置wireguard-etcwireguardwg0conf">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 创建并编辑配置文件</span>
</span></span><span style="display:flex;"><span>sudo nano /etc/wireguard/wg0.conf
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>填入以下内容：
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>ini
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Interface<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 本服务器在隧道中的IPv4地址</span>
</span></span><span style="display:flex;"><span>Address <span style="color:#f92672">=</span> 10.0.0.1/24
</span></span><span style="display:flex;"><span>SaveConfig <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span><span style="color:#75715e"># WireGuard监听的UDP端口</span>
</span></span><span style="display:flex;"><span>ListenPort <span style="color:#f92672">=</span> <span style="color:#ae81ff">51820</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 填入您上一步生成的VPS私钥</span>
</span></span><span style="display:flex;"><span>PrivateKey <span style="color:#f92672">=</span> &lt;在此粘贴vps_privatekey的内容&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Peer<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 稍后填入国内网关的公钥</span>
</span></span><span style="display:flex;"><span>PublicKey <span style="color:#f92672">=</span> &lt;稍后填入国内网关的公钥&gt;
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 分配给国内网关的隧道IP地址</span>
</span></span><span style="display:flex;"><span>AllowedIPs <span style="color:#f92672">=</span> 10.0.0.2/32
</span></span></code></pre></div><h3 id="5-配置防火墙nat规则">5. 配置防火墙NAT规则<a hidden class="anchor" aria-hidden="true" href="#5-配置防火墙nat规则">#</a></h3>
<blockquote>
<p><strong>注意</strong>: 如果你的公网网卡不是 <code>eth0</code>，请用 <code>ip a</code> 命令查看并替换。这一步是必需的，它负责将从隧道过来的、源地址为私网IP（<code>10.0.0.2</code>）的数据包，在发送到公网前，将其源地址“伪装”成VPS自己的公网IP，从而让目标服务器知道将响应数据发回给谁。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 允许所有来自wg0接口的数据包被转发</span>
</span></span><span style="display:flex;"><span>sudo iptables -A FORWARD -i wg0 -j ACCEPT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 将所有从公网网卡出去的包，其源地址伪装成公网地址</span>
</span></span><span style="display:flex;"><span>sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
</span></span></code></pre></div><h3 id="6-启动wireguard服务">6. 启动WireGuard服务<a hidden class="anchor" aria-hidden="true" href="#6-启动wireguard服务">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 启动名为wg0的WireGuard接口</span>
</span></span><span style="display:flex;"><span>sudo wg-quick up wg0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 设置WireGuard服务开机自启</span>
</span></span><span style="display:flex;"><span>sudo systemctl enable wg-quick@wg0
</span></span></code></pre></div><hr>
<h2 id="第二部分国内linux网关-客户端-配置">第二部分：国内Linux网关 (客户端) 配置<a hidden class="anchor" aria-hidden="true" href="#第二部分国内linux网关-客户端-配置">#</a></h2>
<p>这是整个系统的核心，所有智能分流逻辑都在此实现。</p>
<h3 id="1-系统准备与软件安装-1">1. 系统准备与软件安装<a hidden class="anchor" aria-hidden="true" href="#1-系统准备与软件安装-1">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 更新并升级</span>
</span></span><span style="display:flex;"><span>sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 安装所有必需的软件</span>
</span></span><span style="display:flex;"><span>sudo apt install wireguard dnsmasq ipset git curl -y
</span></span></code></pre></div><h3 id="2-生成wireguard密钥">2. 生成WireGuard密钥<a hidden class="anchor" aria-hidden="true" href="#2-生成wireguard密钥">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wg genkey | tee domestic_privatekey | wg pubkey &gt; domestic_publickey<span style="color:#e6db74">```</span>
</span></span><span style="display:flex;"><span>&gt; **重要**: 将 <span style="color:#e6db74">`</span>domestic_publickey<span style="color:#e6db74">`</span> 文件的内容，填入您VPS上 <span style="color:#e6db74">`</span>wg0.conf<span style="color:#e6db74">`</span> 文件里 <span style="color:#e6db74">`</span><span style="color:#f92672">[</span>Peer<span style="color:#f92672">]</span><span style="color:#e6db74">`</span> 部分的 <span style="color:#e6db74">`</span>PublicKey<span style="color:#e6db74">`</span> 字段。然后在VPS上重启WireGuard <span style="color:#f92672">(</span><span style="color:#e6db74">`</span>sudo wg-quick down wg0 <span style="color:#f92672">&amp;&amp;</span> sudo wg-quick up wg0<span style="color:#e6db74">`</span><span style="color:#f92672">)</span>。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### 3. 配置Dnsmasq</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>*   **主配置文件 <span style="color:#f92672">(</span><span style="color:#e6db74">`</span>/etc/dnsmasq.conf<span style="color:#e6db74">`</span><span style="color:#f92672">)</span>**:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">```</span>bash
</span></span><span style="display:flex;"><span>    sudo nano /etc/dnsmasq.conf
</span></span></code></pre></div><pre><code>清空并填入以下内容 (将`192.168.1.1`替换为您的网关实际IP):
```ini
resolv-file=/etc/resolv.dnsmasq.conf
strict-order
listen-address=127.0.0.1,192.168.1.1
bind-interfaces
conf-dir=/etc/dnsmasq.d,*.conf
cache-size=10000
no-poll
no-hosts
```
</code></pre>
<ul>
<li><strong>上游DNS服务器文件 (<code>/etc/resolv.dnsmasq.conf</code>)</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/resolv.dnsmasq.conf
</span></span></code></pre></div>填入（这是未匹配到任何规则时，默认使用的DNS）：
<pre tabindex="0"><code>nameserver 8.8.8.8
</code></pre></li>
</ul>
<h3 id="4-创建自动化与路由脚本">4. 创建自动化与路由脚本<a hidden class="anchor" aria-hidden="true" href="#4-创建自动化与路由脚本">#</a></h3>
<p>您需要手动创建以下三个脚本。</p>
<ul>
<li>
<p><strong>脚本1: 更新规则库 (<code>/usr/local/bin/update-lists.sh</code>)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /usr/local/bin/update-lists.sh
</span></span></code></pre></div><p>粘贴以下内容（<strong>已包含详细注释</strong>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e"># 脚本的开头，声明使用bash解释器来执行。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># set -e 是一个安全设置。它告诉脚本，如果任何命令执行后返回非零的退出状态（通常表示错误），</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 整个脚本将立即停止执行。这可以防止在某个步骤失败后，脚本继续执行错误或不完整的操作。</span>
</span></span><span style="display:flex;"><span>set -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 变量定义 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 定义一些常用的路径和文件名，方便后续引用和修改。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># gfwlist2dnsmasq 工具的存放目录</span>
</span></span><span style="display:flex;"><span>GFWLIST2DNSMASQ_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/opt/gfwlist2dnsmasq&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># dnsmasq-china-list 项目的存放目录</span>
</span></span><span style="display:flex;"><span>CHINA_LIST_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/opt/dnsmasq-china-list&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Dnsmasq 加载额外配置文件的目录</span>
</span></span><span style="display:flex;"><span>DNSMASQ_CONF_DIR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/etc/dnsmasq.d&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 由 gfwlist 生成的 Dnsmasq 配置文件路径</span>
</span></span><span style="display:flex;"><span>DNSMASQ_CONF_GFWLIST<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_DIR<span style="color:#e6db74">/gfwlist.conf&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 我们自己处理并合并后的国内域名 Dnsmasq 配置文件路径</span>
</span></span><span style="display:flex;"><span>DNSMASQ_CONF_CHINA_LIST_MERGED<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_DIR<span style="color:#e6db74">/china-list.conf&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 定义需要处理的国内域名列表源文件名数组</span>
</span></span><span style="display:flex;"><span>CHINA_LIST_SOURCE_FILES<span style="color:#f92672">=(</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;accelerated-domains.china.conf&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;apple.china.conf&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;google.china.conf&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 1/4: Updating gfwlist rules...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查 gfwlist2dnsmasq 工具目录是否存在。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -d <span style="color:#e6db74">&#34;</span>$GFWLIST2DNSMASQ_DIR<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># 如果目录不存在 (! -d)，说明是第一次运行，就从 GitHub 克隆 (clone) 整个项目到指定目录。</span>
</span></span><span style="display:flex;"><span>  git clone https://github.com/cokebar/gfwlist2dnsmasq.git <span style="color:#e6db74">&#34;</span>$GFWLIST2DNSMASQ_DIR<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 cd 命令进入该工具的目录，并用 git pull 拉取最新的更新。</span>
</span></span><span style="display:flex;"><span>cd <span style="color:#e6db74">&#34;</span>$GFWLIST2DNSMASQ_DIR<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&amp;&amp;</span> git pull
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 执行 gfwlist2dnsmasq.sh 脚本，生成 Dnsmasq 配置文件。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -d 8.8.8.8: 指定解析这些域名时使用的DNS服务器。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -s gfwlist: 指定解析出的IP要加入名为 &#34;gfwlist&#34; 的 ipset 集合。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -o &#34;...&#34;: 指定输出配置文件的路径。</span>
</span></span><span style="display:flex;"><span>./gfwlist2dnsmasq.sh -d 8.8.8.8 -s gfwlist -o <span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_GFWLIST<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 2/4: Updating and processing domestic domain lists...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 检查 dnsmasq-china-list 的本地仓库目录是否存在。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -d <span style="color:#e6db74">&#34;</span>$CHINA_LIST_DIR<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># 如果不存在，就从 GitHub 克隆项目。</span>
</span></span><span style="display:flex;"><span>  git clone https://github.com/felixonmars/dnsmasq-china-list.git <span style="color:#e6db74">&#34;</span>$CHINA_LIST_DIR<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 进入该目录并拉取最新更新。</span>
</span></span><span style="display:flex;"><span>cd <span style="color:#e6db74">&#34;</span>$CHINA_LIST_DIR<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&amp;&amp;</span> git pull
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 自动化处理核心 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 &gt; 操作符，清空或创建我们即将写入的合并配置文件。这可以确保每次运行时都是一个全新的文件。</span>
</span></span><span style="display:flex;"><span>&gt; <span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_CHINA_LIST_MERGED<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Processing china-list files to add ipset directive...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 使用 for 循环，遍历上面定义的国内域名列表源文件名数组。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> file in <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>CHINA_LIST_SOURCE_FILES[@]<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># sed 是一个强大的文本处理工具。这行命令是整个自动化方案的关键之一。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># &#39;s|...|...|&#39;: s 代表替换 (substitute)。我们用 | 作为分隔符，避免与路径中的 / 冲突。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># &#39;s|/\([^/]*\)$|/\1\nipset=/\1/directlist|&#39;:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#   - `/\([^/]*\)$`: 这是要查找的模式。它匹配以 &#34;/&#34; 开头，后面跟着一串不包含 &#34;/&#34; 的字符，直到行尾。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     例如，它会匹配 &#39;server=/qq.com/119.29.29.29&#39; 中的 &#39;/qq.com&#39;。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     `\(` 和 `\)` 用于创建一个“捕获组”，把匹配到的域名（如 &#39;qq.com&#39;）存起来。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#   - `/\1\nipset=/\1/directlist`: 这是替换后的内容。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     `\1` 代表第一个捕获组的内容（即域名）。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     `\n` 代表换行符。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#     所以，这整段的意思是：在原始行（如 &#39;server=/qq.com/...&#39;）的后面，换一行，并插入 &#39;ipset=/qq.com/directlist&#39;。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># `&#34;${CHINA_LIST_DIR}/${file}&#34;`: 这是 sed 命令要处理的输入文件。</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># `&gt;&gt; &#34;$DNSMASQ_CONF_CHINA_LIST_MERGED&#34;`: `&gt;&gt;` 是追加重定向，将 sed 处理后的结果追加到我们合并的配置文件中。</span>
</span></span><span style="display:flex;"><span>  sed <span style="color:#e6db74">&#39;s|/\([^/]*\)$|/\1\nipset=/\1/directlist|&#39;</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>CHINA_LIST_DIR<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>file<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> &gt;&gt; <span style="color:#e6db74">&#34;</span>$DNSMASQ_CONF_CHINA_LIST_MERGED<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 3/4: Cleaning up old china-list files...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 为了避免 Dnsmasq 加载我们处理前的原始文件，造成规则冲突或重复，这里将它们从配置目录中删除。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># rm -f: -f (force) 表示即使文件不存在也不报错。</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> file in <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>CHINA_LIST_SOURCE_FILES[@]<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>    rm -f <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>DNSMASQ_CONF_DIR<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>file<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 4/4: Restarting Dnsmasq...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 所有规则都已更新并处理完毕，现在重启 Dnsmasq 服务以加载所有新的配置文件。</span>
</span></span><span style="display:flex;"><span>sudo systemctl restart dnsmasq
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Update process finished.&#34;</span>
</span></span></code></pre></div></li>
<li>
<p><strong>脚本2: 应用防火墙和路由规则 (<code>/usr/local/bin/apply-routing-rules.sh</code>)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /usr/local/bin/apply-routing-rules.sh
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>    粘贴以下内容：
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>bash
</span></span><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash</span>
</span></span><span style="display:flex;"><span>set -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 变量定义 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># FW_MARK: 防火墙标记，用于策略路由。可以任意，但通常用WireGuard端口号便于识别。</span>
</span></span><span style="display:flex;"><span>FW_MARK<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;51820&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># TABLE_ID: 自定义路由表的ID。避免与系统已使用的表冲突，100是一个安全的选择。</span>
</span></span><span style="display:flex;"><span>TABLE_ID<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;100&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># FOREIGN_DNS: 我们指定的国外/上游DNS服务器，用于DNS防泄漏。</span>
</span></span><span style="display:flex;"><span>FOREIGN_DNS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;8.8.8.8&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 1/3: Initializing ipsets...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 初始化IP集合 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 销毁并创建 gfwlist 和新的 directlist 集合，确保每次应用都是干净的状态。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2&gt;/dev/null: 将可能出现的“集合不存在”的错误信息重定向到“黑洞”，避免在首次运行时报错。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># || true: 即使ipset destroy命令失败（比如集合不存在），也确保脚本继续执行。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># timeout 86400: 设置ipset中条目的默认超时时间为一天(86400秒)，之后会自动过期。</span>
</span></span><span style="display:flex;"><span>ipset destroy gfwlist 2&gt;/dev/null <span style="color:#f92672">||</span> true; ipset create gfwlist hash:ip,family inet,timeout <span style="color:#ae81ff">86400</span>
</span></span><span style="display:flex;"><span>ipset destroy directlist 2&gt;/dev/null <span style="color:#f92672">||</span> true; ipset create directlist hash:ip,family inet,timeout <span style="color:#ae81ff">86400</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 2/3: Configuring firewall and policy routing (Default Proxy Mode)...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 清理旧规则 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -t mangle: 指定操作mangle表。-F: Flush，清空链。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># PREROUTING链: 处理进入本机、需要转发给局域网其他设备的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># OUTPUT链: 处理本机自己产生的数据包。</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -F PREROUTING; iptables -t mangle -F OUTPUT; iptables -t filter -F OUTPUT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 流量标记 (Mangle Table) ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># [策略反转]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 规则1: 优先标记本机发往国外DNS的查询请求，确保DNS解析本身走隧道，防止被窥探。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -p udp --dport 53: 匹配协议为udp、目标端口为53（DNS）的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -d $FOREIGN_DNS: 匹配目标地址是8.8.8.8的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -j MARK --set-mark $FW_MARK: 对匹配的数据包打上标记。</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -A OUTPUT -p udp --dport <span style="color:#ae81ff">53</span> -d $FOREIGN_DNS -j MARK --set-mark $FW_MARK
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 规则2: 白名单规则。如果流量的目标IP在直连白名单(directlist)中，则直接返回(RETURN)，</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 不进行后续任何标记。这意味着它将走系统默认路由（即本地网络出口）。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -m set --match-set directlist dst: 匹配目标IP(dst)在名为directlist的集合中的数据包。</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -A PREROUTING -m set --match-set directlist dst -j RETURN
</span></span><span style="display:flex;"><span>iptables -t mangle -A OUTPUT -m set --match-set directlist dst -j RETURN
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 规则3: 默认标记规则。对于所有不满足上一条白名单规则的流量，全部无条件打上标记。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这包括了gfwlist的流量和所有未知的互联网流量。</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -A PREROUTING -j MARK --set-mark $FW_MARK
</span></span><span style="display:flex;"><span>iptables -t mangle -A OUTPUT -j MARK --set-mark $FW_MARK
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- Kill Switch (Filter Table) ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 在OUTPUT链顶部插入规则：如果数据包有标记但出口不是wg0，则丢弃(DROP)。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这是防止VPN断开时，被标记的流量从本地出口泄露真实IP。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -I OUTPUT 1: 在OUTPUT链的第1个位置插入此规则，确保最先被匹配。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -m mark --mark $FW_MARK: 匹配带有我们设置的标记的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ! -o wg0: 匹配出口网卡 *不是* wg0 的数据包。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># -j DROP: 丢弃数据包。</span>
</span></span><span style="display:flex;"><span>iptables -I OUTPUT <span style="color:#ae81ff">1</span> -m mark --mark $FW_MARK ! -o wg0 -j DROP
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 策略路由 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 删除可能存在的旧规则，然后添加新规则：所有带标记的包，去查询ID为100的路由表。</span>
</span></span><span style="display:flex;"><span>ip rule del fwmark $FW_MARK table $TABLE_ID 2&gt;/dev/null <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>ip rule add fwmark $FW_MARK table $TABLE_ID
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 在路由表100中，设置默认路由为通过wg0接口发出。</span>
</span></span><span style="display:flex;"><span>ip route add default dev wg0 table $TABLE_ID
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 刷新路由缓存使规则立即生效。</span>
</span></span><span style="display:flex;"><span>ip route flush cache
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; 3/3: Routing rules applied.&#34;</span>
</span></span></code></pre></div></li>
<li>
<p><strong>脚本3: 清理所有规则 (<code>/usr/local/bin/cleanup-routing-rules.sh</code>)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /usr/local/bin/cleanup-routing-rules.sh
</span></span></code></pre></div><p>粘贴以下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>set -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 变量定义 ---</span>
</span></span><span style="display:flex;"><span>FW_MARK<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;51820&#34;</span>
</span></span><span style="display:flex;"><span>TABLE_ID<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;100&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;--&gt; Cleaning up all firewall and routing rules...&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 清理iptables规则 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 清空 Mangle 表和 Filter 表中我们可能添加过规则的链</span>
</span></span><span style="display:flex;"><span>iptables -t mangle -F PREROUTING; iptables -t mangle -F OUTPUT; iptables -t filter -F OUTPUT
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 清理策略路由 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 删除之前添加的策略路由规则</span>
</span></span><span style="display:flex;"><span>ip rule del fwmark $FW_MARK table $TABLE_ID 2&gt;/dev/null <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 清理ipset集合 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 销毁 ipset 集合，释放内存</span>
</span></span><span style="display:flex;"><span>ipset destroy gfwlist 2&gt;/dev/null <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>ipset destroy directlist 2&gt;/dev/null <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Cleanup complete.&#34;</span>
</span></span></code></pre></div></li>
<li>
<p><strong>赋予脚本执行权限</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo chmod +x /usr/local/bin/*.sh
</span></span></code></pre></div></li>
</ul>
<h3 id="5-配置wireguard-etcwireguardwg0conf-并集成脚本">5. 配置WireGuard (<code>/etc/wireguard/wg0.conf</code>) 并集成脚本<a hidden class="anchor" aria-hidden="true" href="#5-配置wireguard-etcwireguardwg0conf-并集成脚本">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/wireguard/wg0.conf
</span></span></code></pre></div><p>填入以下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ini" data-lang="ini"><span style="display:flex;"><span><span style="color:#66d9ef">[Interface]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 填入您之前生成的国内网关私钥</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PrivateKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;在此粘贴domestic_privatekey的内容&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 本网关在隧道中的IPv4地址</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Address</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">10.0.0.2/32</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 防火墙标记 (此处的FwMark主要由wg-quick内部使用，我们的脚本也使用了相同的值，但不直接关联)</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">FwMark</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">51820</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 关键：告诉wg-quick不要自动修改主路由表，交由我们的策略路由脚本完全接管</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Table</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">off</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 当wg0启动后，自动执行规则应用脚本</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PostUp</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/usr/local/bin/apply-routing-rules.sh</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 当wg0关闭前，自动执行规则清理脚本</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PreDown</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">/usr/local/bin/cleanup-routing-rules.sh</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">[Peer]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 填入您VPS的公钥</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PublicKey</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;在此粘贴vps_publickey的内容&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 您VPS的公网IP地址和WireGuard监听的端口</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Endpoint</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;你的VPS公网IP&gt;:51820</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 允许所有IP通过隧道（具体哪些流量走隧道由我们的策略路由决定）</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">AllowedIPs</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">0.0.0.0/0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 每25秒发送一个心跳包，保持NAT穿透和连接活跃</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">PersistentKeepalive</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">25</span>
</span></span></code></pre></div><hr>
<h2 id="第三部分首次部署与日常使用">第三部分：首次部署与日常使用<a hidden class="anchor" aria-hidden="true" href="#第三部分首次部署与日常使用">#</a></h2>
<ol>
<li>
<p><strong>首次运行</strong>:</p>
<ul>
<li><strong>更新规则库</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo /usr/local/bin/update-lists.sh
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>    *   **启动服务**:
</span></span><span style="display:flex;"><span><span style="color:#e6db74">```</span>bash
</span></span><span style="display:flex;"><span>sudo wg-quick up wg0
</span></span></code></pre></div></li>
<li><strong>设置开机自启</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl enable wg-quick@wg0
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p><strong>设置自动化更新 (每日更新)</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 编辑root用户的定时任务，因为脚本需要sudo权限</span>
</span></span><span style="display:flex;"><span>sudo crontab -e
</span></span></code></pre></div><p>在文件末尾添加一行并保存。<code>0 3 * * *</code> 表示在每天的凌晨3点0分执行。</p>
<pre tabindex="0"><code class="language-crontab" data-lang="crontab"># 在每天的凌晨3点，自动运行更新脚本
0 3 * * * /usr/local/bin/update-lists.sh
</code></pre></li>
<li>
<p><strong>局域网设备配置</strong>:
将您局域网内的其他设备（电脑、手机等）的<strong>网关</strong>和<strong>DNS服务器</strong>地址，全部设置为您这台Linux网关的局域网IP（例如 <code>192.168.1.1</code>）。</p>
</li>
<li>
<p><strong>验证</strong>:</p>
<ul>
<li>
<p><strong>国内网站测试</strong>: 访问 <code>ip.cn</code> 或 <code>ip138.com</code>，应显示您<strong>本地的公网IP</strong>。</p>
</li>
<li>
<p><strong>国外网站测试</strong>: 在局域网设备上访问 <code>ip.sb</code>、<code>ifconfig.me</code> 或其他任何国外网站，应显示<strong>VPS的公网IP</strong>。</p>
</li>
<li>
<p><strong>DNS泄露测试</strong>: 访问 <code>dnsleaktest.com</code>，显示的应是您VPS所在地的DNS信息（或Google的DNS），绝不应是您本地运营商的DNS。</p>
</li>
<li>
<p><strong>Kill Switch测试</strong>: 在网关上运行 <code>sudo wg-quick down wg0</code>。此时，您应该<strong>只能访问国内网站</strong>（如<code>baidu.com</code>），而<strong>无法访问任何国外网站</strong>（包括<code>google.com</code>和一些小众网站）。再运行 <code>sudo wg-quick up wg0</code> 即可恢复所有访问。</p>
</li>
<li>
<p><strong>使用 <code>dig</code> 命令进行精准DNS解析验证</strong>:</p>
<blockquote>
<p><code>dig</code> 是一个强大的DNS查询工具，可以精确地告诉我们是哪个DNS服务器响应了查询，以及查询的结果。这比浏览器访问更底层、更准确。如果您的局域网设备上没有<code>dig</code>，请先安装 (例如 <code>sudo apt install dnsutils</code>)。</p>
</blockquote>
<ul>
<li>
<p><strong>测试国内域名</strong>:
在局域网内的<strong>另一台电脑</strong>（不是网关本身）上执行以下命令，将<code>192.168.1.1</code>换成您的网关IP：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dig www.baidu.com @192.168.1.1
</span></span></code></pre></div><p><strong>预期结果</strong>:
你会看到类似下面的输出。关键在于 <code>SERVER</code> 行，它必须显示的是你<strong>网关的IP地址</strong>。这证明你的DNS请求被网关正确接收并由Dnsmasq根据国内列表的规则进行了处理。</p>
<pre tabindex="0"><code>; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; www.baidu.com @192.168.1.1
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 54010
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 65494
;; QUESTION SECTION:
;www.baidu.com.                 IN      A

;; ANSWER SECTION:
www.baidu.com.          600     IN      CNAME   www.a.shifen.com.
www.a.shifen.com.       60      IN      A       110.242.68.3
www.a.shifen.com.       60      IN      A       110.242.68.4

;; Query time: 15 msec
;; SERVER: 192.168.1.1#53(192.168.1.1)  &lt;-- 关键看这里！
;; WHEN: Thu Oct 23 11:30:00 UTC 2025
;; MSG SIZE  rcvd: 107
</code></pre><p>查询时间 (<code>Query time</code>) 通常会很短（例如 &lt; 50ms）。</p>
</li>
<li>
<p><strong>测试国外域名</strong>:
同样，在局域网客户端上执行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dig www.google.com @192.168.1.1
</span></span></code></pre></div><p><strong>预期结果</strong>:
<code>SERVER</code> 行依然显示的是你<strong>网关的IP地址</strong>。这表明请求被网关Dnsmasq接收，然后Dnsmasq根据规则（未匹配国内域名列表），将查询转发给了默认的上游DNS <code>8.8.8.8</code>。由于这个转发过程是通过WireGuard隧道的，所以查询时间 (<code>Query time</code>) 可能会比国内域名稍长一些。</p>
<pre tabindex="0"><code>; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; www.google.com @192.168.1.1
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 37123
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 65494
;; QUESTION SECTION:
;www.google.com.                        IN      A

;; ANSWER SECTION:
www.google.com.         242     IN      A       142.250.199.100

;; Query time: 120 msec   &lt;-- 时间可能因隧道延迟而变长
;; SERVER: 192.168.1.1#53(192.168.1.1)  &lt;-- 关键看这里！
;; WHEN: Thu Oct 23 11:32:15 UTC 2025
;; MSG SIZE  rcvd: 59
```            通过这两个 `dig` 测试，你可以百分之百确认Dnsmasq的分流策略已经按预期工作。
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>文档结束</strong></p>
<hr>
<hr>
<h2 id="检查与改进建议">检查与改进建议<a hidden class="anchor" aria-hidden="true" href="#检查与改进建议">#</a></h2>
<h3 id="一-技术方案审查-technical-review">一、 技术方案审查 (Technical Review)<a hidden class="anchor" aria-hidden="true" href="#一-技术方案审查-technical-review">#</a></h3>
<p><strong>总体评价：方案设计非常出色，技术实现合理且正确。</strong></p>
<p>这是一个工业级的个人网关部署方案，逻辑环环相扣，考虑了自动化和安全性。我对方案中的命令和配置逐一进行了检查，结论如下：</p>
<ol>
<li><strong>VPS端配置</strong>：完全正确。<code>net.ipv4.ip_forward=1</code> 开启了路由功能，<code>iptables</code> 的 <code>MASQUERADE</code> 规则是实现NAT转换的标准做法，配置无误。</li>
<li><strong>网关端Dnsmasq配置</strong>：配置合理。通过 <code>conf-dir</code> 加载分流规则，通过 <code>resolv-file</code> 指定默认上游DNS，这是实现DNS分流的标准实践。</li>
<li><strong>核心脚本 <code>update-lists.sh</code></strong>：逻辑严谨，实现巧妙。
<ul>
<li><code>git clone/pull</code> 的逻辑可以确保规则库始终是最新版本。</li>
<li><strong>核心命令</strong> <code>sed 's|/\([^/]*\)$|/\1\nipset=/\1/directlist|'</code> <strong>是整个自动化方案的精髓</strong>。它没有修改原始规则文件，而是在内存中处理每一行，动态地为每个国内域名规则追加一条 <code>ipset</code> 指令。这使得Dnsmasq在解析这些域名的同时，能自动将解析出的IP地址添加到名为 <code>directlist</code> 的IP集合中。这个实现非常优雅且高效。</li>
</ul>
</li>
<li><strong>核心脚本 <code>apply-routing-rules.sh</code></strong>：逻辑正确，实现了“白名单直连，默认代理”的反向策略。
<ul>
<li><strong>IPset初始化</strong>：<code>ipset destroy ... || true</code> 的写法很规范，能避免脚本在首次运行时因集合不存在而报错中断。</li>
<li><strong>流量标记逻辑</strong>：这是典型的“策略反转”思路。它没有去标记“需要代理”的流量，而是先匹配“需要直连”的流量（<code>-m set --match-set directlist dst -j RETURN</code>）让其通过，然后将<strong>所有剩下</strong>的流量（<code>-j MARK</code>）无条件标记。这确保了任何未知流量都会默认走代理，增强了隐私性。</li>
<li><strong>Kill Switch</strong>：<code>iptables -I OUTPUT 1 -m mark --mark $FW_MARK ! -o wg0 -j DROP</code> 是一条非常关键和正确的安全规则。它为网关本机提供了强有力的防泄漏保障。对于局域网内的其他设备，当 <code>wg0</code> 接口关闭时，策略路由 <code>ip rule</code> 所指向的路由表 <code>100</code> 中的 <code>default dev wg0</code> 路由会失效，数据包同样无法发出，从而实现了对整个局域网的Kill Switch效果。</li>
</ul>
</li>
<li><strong>WireGuard客户端配置</strong>：配置正确，特别是 <code>Table = off</code> 的使用。
<ul>
<li><code>Table = off</code> 是高级用法，它阻止了 <code>wg-quick</code> 工具修改系统默认的主路由表。这是本方案能正常工作的<strong>关键设置</strong>，因为它把路由控制权完全交给了我们的 <code>PostUp</code> 脚本和策略路由，避免了路由冲突。</li>
<li>通过 <code>PostUp</code> 和 <code>PreDown</code> 钩子来自动执行规则应用和清理脚本，是 <code>wg-quick</code> 的标准集成方式，实现了配置的自动化和原子性。</li>
</ul>
</li>
</ol>
<h3 id="二-总结与细微改进建议">二、 总结与细微改进建议<a hidden class="anchor" aria-hidden="true" href="#二-总结与细微改进建议">#</a></h3>
<p><strong>总结</strong></p>
<p>这篇部署方案从技术角度看是<strong>一份可以被直接采纳并部署的、高质量的生产级方案</strong>。它逻辑清晰、自动化程度高、安全性强，并且正确地运用了Linux网络栈的各项高级功能（策略路由、ipset、mangle标记等）。对于想要实现精细化流量控制的用户来说，这是一个极佳的模板和学习材料。</p>
<p><strong>细微改进建议（非错误修正）</strong></p>
<ol>
<li><strong>脚本注释增强</strong>：我已经根据您的要求，在上面的原文副本中，对 <code>apply-routing-rules.sh</code> 和其他脚本的部分关键命令增加了更详细的注释，以便于新手理解每个参数的意义。</li>
<li><strong>Crontab命令</strong>：在“设置自动化更新”部分，原命令 <code>crontab -e</code> 会编辑当前用户的定时任务。由于更新脚本和重启服务需要root权限，建议明确为 <code>sudo crontab -e</code>，以编辑root用户的定时任务。这一点我也在上面的副本中修正了。</li>
<li><strong>ipset持久化（可选）</strong>：当前的ipset规则是临时的，每次重启网关或重启 <code>wg-quick</code> 服务时，<code>apply-routing-rules.sh</code> 会重建它们。这是完全可行的。但如果追求更快的启动速度，可以研究 <code>ipset-persistent</code> 等工具，将ipset集合保存到磁盘，并在系统启动时自动加载。不过对于本方案来说，现有机制已经足够好，这并非必要项。</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="//localhost:1313/">star徐的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
