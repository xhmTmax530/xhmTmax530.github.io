<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Claude Code 常用命令使用解析 | star徐的博客</title><meta name=keywords content="AI,Claude,安全工具,命令行"><meta name=description content="Claude Code 常用命令使用解析
大家好，作为一个刚接触 Claude Code 的新手，我根据官方文档和一些热门的介绍视频，整理这份学习笔记和实践总结。主要是为了记录自己的学习过程，同时也希望能起到一个抛砖引玉的作用，为同样在入门路上的朋友们提供一些参考和便利。
这篇总结更多是我个人的理解和实践，内容可能比较基础，难免有疏漏或错误之处，对于经验丰富的高手们，可以直接略过这篇文章。
🚀 第一部分：基础入门 - 安装与启动
1. 环境准备

安装 Node.js： Claude Code 是一个基于 Node.js 的命令行工具。请先访问 Node.js 官网，下载并安装推荐的 LTS (长期支持) 版本。

2. 安装 Claude Code


打开你的终端（Windows 用户使用 PowerShell，Mac/Linux 用户使用 Terminal），输入以下命令并回车：
codeBash
npm install -g @anthropic-ai/claude-code

【原理讲解】 npm 是 Node.js 的包管理器。-g 参数代表“全局安装”，这意味着你可以在电脑的任何文件夹中使用 claude 命令。



3. 启动与初始化

创建项目文件夹： 在你希望的位置创建一个新文件夹（例如 my-first-app），然后通过终端进入该文件夹。
启动 Claude Code： 在项目文件夹的终端中，输入 claude 并回车。
初始化项目： 启动后，立刻输入 /init 命令。


【至关重要】 /init 命令是与 Claude Code 高效协作的基石。它会扫描当前项目并创建一个 CLAUDE.md 文件。这个文件相当于 AI 的“项目记忆”，后续所有操作，AI 都会参考它来理解你的项目结构，确保它的行为与你的项目高度相关。"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/claude-code-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/claude-code-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/claude-code-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="Claude Code 常用命令使用解析"><meta property="og:description" content="Claude Code 常用命令使用解析 大家好，作为一个刚接触 Claude Code 的新手，我根据官方文档和一些热门的介绍视频，整理这份学习笔记和实践总结。主要是为了记录自己的学习过程，同时也希望能起到一个抛砖引玉的作用，为同样在入门路上的朋友们提供一些参考和便利。
这篇总结更多是我个人的理解和实践，内容可能比较基础，难免有疏漏或错误之处，对于经验丰富的高手们，可以直接略过这篇文章。
🚀 第一部分：基础入门 - 安装与启动 1. 环境准备 安装 Node.js： Claude Code 是一个基于 Node.js 的命令行工具。请先访问 Node.js 官网，下载并安装推荐的 LTS (长期支持) 版本。 2. 安装 Claude Code 打开你的终端（Windows 用户使用 PowerShell，Mac/Linux 用户使用 Terminal），输入以下命令并回车：
codeBash
npm install -g @anthropic-ai/claude-code 【原理讲解】 npm 是 Node.js 的包管理器。-g 参数代表“全局安装”，这意味着你可以在电脑的任何文件夹中使用 claude 命令。
3. 启动与初始化 创建项目文件夹： 在你希望的位置创建一个新文件夹（例如 my-first-app），然后通过终端进入该文件夹。 启动 Claude Code： 在项目文件夹的终端中，输入 claude 并回车。 初始化项目： 启动后，立刻输入 /init 命令。 【至关重要】 /init 命令是与 Claude Code 高效协作的基石。它会扫描当前项目并创建一个 CLAUDE.md 文件。这个文件相当于 AI 的“项目记忆”，后续所有操作，AI 都会参考它来理解你的项目结构，确保它的行为与你的项目高度相关。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-13T19:05:00+08:50"><meta property="article:modified_time" content="2025-11-13T19:05:00+08:50"><meta property="article:tag" content="AI"><meta property="article:tag" content="Claude"><meta property="article:tag" content="安全工具"><meta property="article:tag" content="命令行"><meta name=twitter:card content="summary"><meta name=twitter:title content="Claude Code 常用命令使用解析"><meta name=twitter:description content="Claude Code 常用命令使用解析
大家好，作为一个刚接触 Claude Code 的新手，我根据官方文档和一些热门的介绍视频，整理这份学习笔记和实践总结。主要是为了记录自己的学习过程，同时也希望能起到一个抛砖引玉的作用，为同样在入门路上的朋友们提供一些参考和便利。
这篇总结更多是我个人的理解和实践，内容可能比较基础，难免有疏漏或错误之处，对于经验丰富的高手们，可以直接略过这篇文章。
🚀 第一部分：基础入门 - 安装与启动
1. 环境准备

安装 Node.js： Claude Code 是一个基于 Node.js 的命令行工具。请先访问 Node.js 官网，下载并安装推荐的 LTS (长期支持) 版本。

2. 安装 Claude Code


打开你的终端（Windows 用户使用 PowerShell，Mac/Linux 用户使用 Terminal），输入以下命令并回车：
codeBash
npm install -g @anthropic-ai/claude-code

【原理讲解】 npm 是 Node.js 的包管理器。-g 参数代表“全局安装”，这意味着你可以在电脑的任何文件夹中使用 claude 命令。



3. 启动与初始化

创建项目文件夹： 在你希望的位置创建一个新文件夹（例如 my-first-app），然后通过终端进入该文件夹。
启动 Claude Code： 在项目文件夹的终端中，输入 claude 并回车。
初始化项目： 启动后，立刻输入 /init 命令。


【至关重要】 /init 命令是与 Claude Code 高效协作的基石。它会扫描当前项目并创建一个 CLAUDE.md 文件。这个文件相当于 AI 的“项目记忆”，后续所有操作，AI 都会参考它来理解你的项目结构，确保它的行为与你的项目高度相关。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"Claude Code 常用命令使用解析","item":"http://ljj1992.fun/posts/claude-code-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Claude Code 常用命令使用解析","name":"Claude Code 常用命令使用解析","description":"Claude Code 常用命令使用解析 大家好，作为一个刚接触 Claude Code 的新手，我根据官方文档和一些热门的介绍视频，整理这份学习笔记和实践总结。主要是为了记录自己的学习过程，同时也希望能起到一个抛砖引玉的作用，为同样在入门路上的朋友们提供一些参考和便利。\n这篇总结更多是我个人的理解和实践，内容可能比较基础，难免有疏漏或错误之处，对于经验丰富的高手们，可以直接略过这篇文章。\n🚀 第一部分：基础入门 - 安装与启动 1. 环境准备 安装 Node.js： Claude Code 是一个基于 Node.js 的命令行工具。请先访问 Node.js 官网，下载并安装推荐的 LTS (长期支持) 版本。 2. 安装 Claude Code 打开你的终端（Windows 用户使用 PowerShell，Mac/Linux 用户使用 Terminal），输入以下命令并回车：\ncodeBash\nnpm install -g @anthropic-ai/claude-code 【原理讲解】 npm 是 Node.js 的包管理器。-g 参数代表“全局安装”，这意味着你可以在电脑的任何文件夹中使用 claude 命令。\n3. 启动与初始化 创建项目文件夹： 在你希望的位置创建一个新文件夹（例如 my-first-app），然后通过终端进入该文件夹。 启动 Claude Code： 在项目文件夹的终端中，输入 claude 并回车。 初始化项目： 启动后，立刻输入 /init 命令。 【至关重要】 /init 命令是与 Claude Code 高效协作的基石。它会扫描当前项目并创建一个 CLAUDE.md 文件。这个文件相当于 AI 的“项目记忆”，后续所有操作，AI 都会参考它来理解你的项目结构，确保它的行为与你的项目高度相关。\n","keywords":["AI","Claude","安全工具","命令行"],"articleBody":"Claude Code 常用命令使用解析 大家好，作为一个刚接触 Claude Code 的新手，我根据官方文档和一些热门的介绍视频，整理这份学习笔记和实践总结。主要是为了记录自己的学习过程，同时也希望能起到一个抛砖引玉的作用，为同样在入门路上的朋友们提供一些参考和便利。\n这篇总结更多是我个人的理解和实践，内容可能比较基础，难免有疏漏或错误之处，对于经验丰富的高手们，可以直接略过这篇文章。\n🚀 第一部分：基础入门 - 安装与启动 1. 环境准备 安装 Node.js： Claude Code 是一个基于 Node.js 的命令行工具。请先访问 Node.js 官网，下载并安装推荐的 LTS (长期支持) 版本。 2. 安装 Claude Code 打开你的终端（Windows 用户使用 PowerShell，Mac/Linux 用户使用 Terminal），输入以下命令并回车：\ncodeBash\nnpm install -g @anthropic-ai/claude-code 【原理讲解】 npm 是 Node.js 的包管理器。-g 参数代表“全局安装”，这意味着你可以在电脑的任何文件夹中使用 claude 命令。\n3. 启动与初始化 创建项目文件夹： 在你希望的位置创建一个新文件夹（例如 my-first-app），然后通过终端进入该文件夹。 启动 Claude Code： 在项目文件夹的终端中，输入 claude 并回车。 初始化项目： 启动后，立刻输入 /init 命令。 【至关重要】 /init 命令是与 Claude Code 高效协作的基石。它会扫描当前项目并创建一个 CLAUDE.md 文件。这个文件相当于 AI 的“项目记忆”，后续所有操作，AI 都会参考它来理解你的项目结构，确保它的行为与你的项目高度相关。\n🧠 第二部分：核心交互 - 与 AI 高效对话 掌握以下命令，你就能像指挥一位得力助手一样，精准地管理 AI 的“记忆”和“专注力”。\n命令 功能 详细解读 /init 初始化项目 最重要的命令。为项目创建 CLAUDE.md 上下文文件，让 AI 拥有对项目的宏观认知。 /compact 压缩上下文 智能地“忘记”不重要的历史对话，保留核心摘要，提高 AI 专注力并节省 Token 消耗。可以附加指令，如 /compact 主要保留前端对话。 /clear 清理上下文 当开始一个全新任务时，用它来清空对话历史，避免 AI 受到之前内容的干扰。 think\nthink hard\nthink harder\nultrathink 提升思考强度 在提问前加上这些官方内置的指令，可以逐步增加 AI 用于思考和规划的计算资源。对于复杂任务，ultrathink 能带来更全面的解决方案。 ! (例如 ! npm install) 临时命令行模式 无需切换窗口，直接在 Claude Code 中执行系统命令。执行的命令和结果会自动加入上下文，AI 会知道你刚刚做了什么。 # (例如 # 使用 Next.js 14) 添加记忆 将重要信息添加为“长期记忆”。可以选择仅对当前项目生效 (Project memory) 或全局生效 (User memory)。 ⚙️ 第三部分：生态集成 - 让 Claude Code 融入你的工作流 Claude Code 的强大之处在于它能与你现有的开发工具无缝集成。\n1. IDE 集成 (/ide) 准备： 在你的 IDE (如 VS Code) 中安装官方插件 Claude Code for VSCode。 连接： 在 Claude Code 中运行 /ide 命令并连接到你的 IDE。 核心功能： 代码感知： 你在 IDE 中选中的代码，Claude Code 能实时感知并进行问答。 代码修改同步： AI 对代码的修改会直接在 IDE 中以“差异对比 (Diff)”视图呈现，让你清晰地看到变更，并一键接受。 2. MCP (Model Context Protocol) 集成 概念： MCP 是一种让 AI 与外部工具（如数据库、API、文件系统）交互的协议。 作用： 极大地扩展了 AI 的能力边界。例如，通过 context7 这个 MCP Server，AI 可以查询到最新的第三方库文档，弥补自身知识库的滞后性。 使用： 通过 claude mcp add 命令进行添加。 3. GitHub 集成 准备： 安装 GitHub CLI。 作用： 授权后的 Claude Code 可以直接操作你的 GitHub 仓库。 强大之处： 可以实现惊人的自动化工作流。例如，你可以直接告诉它：“查看 GitHub 仓库里的 Issue #1，根据描述修复这个 bug，创建一个名为 bugfix/login-error 的新分支，然后将修改推送到这个分支。” Claude Code 会一步步自动完成所有操作。 🤖 第四部分：自动化与智能化 - Hooks 与 SubAgents 这是 Claude Code 最能体现其“智能”的两个高级功能。它们能将重复性的工作流程自动化，甚至让 AI 自我修正，极大地提升开发效率。\n1. SubAgent (子代理) 概念： 类似于编程中的“多线程”或现实生活中的“专家团队”。主 Agent (你的主对话) 可以将一个复杂的任务拆解成多个独立的子任务，并分配给不同的、专门的 SubAgent 去并行执行。 优势： 专注： 每个 SubAgent 只关心自己的小任务，拥有独立的、精简的上下文，不易出错。 高效： 并行处理可以显著加快复杂任务的完成速度。 1.1 创建并使用你的第一个 SubAgent (新手教程) 创建一个专门负责“播报天气”的 SubAgent。\n第一步：进入 Agent 管理界面\n操作： 在 Claude Code 中输入 /agents 并回车。 第二步：开始创建新 Agent\n操作： 你会看到一个菜单，选择 \u003e Create new agent 并回车。 第三步：定义 Agent 的角色 (核心)\n操作： 这是最关键的一步。你需要用自然语言清晰地描述这个 Agent 的职责。输入以下描述：\n你是一个天气预报大师，使用联网工具查询天气。\n第四步：为 Agent 分配工具\n操作： 接下来会让你选择这个 Agent 可以使用哪些工具。对于一个天气预报员，它需要联网。为了简单起见，新手可以直接选择 [x] All tools (所有工具)。 进阶提示： 在实际应用中，为了安全和专注，你应该只为 Agent 分配它完成任务所必需的最小工具集。比如，天气 Agent 只需要 WebSearch 工具就足够了。 第五步：选择模型和颜色\n操作： 选择一个模型（通常默认的 Sonnet 即可），然后为你的 Agent 选一个颜色（例如 Blue），这样在对话中可以轻松区分它。 第六步：确认并保存\n操作： 回车确认，你的第一个 SubAgent weather-forecast-master 就创建完成了！ 1.2 如何调用 SubAgent 有两种方式可以调用你创建的 SubAgent：\n隐式调用 (自动委派)： 这是最智能的方式。你只需要在主对话中提出一个包含多个任务的复杂请求，主 Agent 会自动分析并将合适的子任务委派给对应的 SubAgent。\n示例： “帮我审查 feature/new-ui 分支的代码，并查一下北京今天的天气怎么样？”\nClaude Code 会自动将“审查代码”的任务交给代码审查 Agent，将“查天气”的任务交给天气预报 Agent。\n显式调用 (手动指定)： 如果你想强制使用某个 Agent，可以在对话中使用 @ 符号来直接呼叫它。\n示例： @weather-forecast-master 北京今天天气如何？\n这会确保只有 weather-forecast-master 这个 Agent 来处理你的请求。\n2. Hooks (钩子)：终极自动化工具 这是我们重点讲解的部分，也是实现高度自动化工作流的关键。\n2.1 钩子是什么？ 定义： 钩子是一种事件驱动的自动化机制。它允许你在 Claude Code 工作流程的特定事件发生时，自动触发并执行预先定义好的操作。 运行原理： 监听 (Listening)： Claude Code 在运行时会不断广播各种事件信号（如 PreToolUse）。 匹配 (Matching)： 你定义的 Hook 监听到信号后，会检查事件类型和触发条件 (Matcher) 是否都匹配。 触发与执行 (Triggering \u0026 Execution)： 匹配成功后，Hook 被触发，系统暂停当前流程，去执行你定义的操作。 反馈 (Feedback)： 脚本的执行结果（通过退出码）可以反过来影响 Claude Code 的后续行为（是继续还是中止）。 2.2 钩子的运行 为了更好地理解 Hook，我们可以把它想象成一个机场的“智能安检系统”，它的工作流程由以下四个核心概念构成：\n1.Hook Events (钩子事件) —— “安检的时机”\n定义： Hook 被触发的时间点。\n核心类型：\nPreToolUse：在工具使用之前触发。（相当于登机前的安检）。 PostToolUse：在工具使用之后触发。（相当于落地后的海关检查）。 Notification, UserPromptSubmit 等。 常用列表：\n触发事件 触发时机 PreToolUse 在工具使用之前触发。（事前钩子） PostToolUse 在工具使用之后触发。（事后钩子） Notification 系统发出通知时触发。 UserPromptSubmit 用户提交新消息时触发。 一句话总结： 它是触发器，决定了你的逻辑在哪个阶段介入。\n2.触发条件 (Matchers) —— “安检系统针对哪种旅客？”\n定义： Matcher 是一个过滤器，它精确地告诉 Hook 应该关注哪一种或哪一类工具的行为。\n作用： 确保 Hook 只在您关心的特定操作上触发，而不是对所有操作都做出反应。\n触发条件 (Matchers) - “针对哪个工具？”\nMatcher 对应的工具/操作 Edit MultiEdit Write 文件创建、编辑、写入 Bash 执行命令行命令 Task Subagent 创建子任务或子代理 WebFetch WebSearch 访问网页或网络搜索 UseMcpTool 使用外部 MCP 工具 组合使用： 您可以用 |（代表“或”）来组合多个 Matcher，例如 “matcher”: “Edit|Write” 表示当“编辑”或“写入”文件时都触发。\n一句话总结： 它是过滤器，是 Hook 触发的精确条件。\n3.Hook Input (钩子输入) —— “安检员拿到的旅客信息”\n定义： 当事件触发时，Claude Code 通过标准输入 (Stdin) “喂”给你的脚本的数据，通常是 JSON 格式。 核心作用： 让你的脚本知道“要发生什么”或“发生了什么”。例如，对于 PreToolUse 事件，Input 会包含工具名和参数，如 {“tool”: “Edit”, “path”: “main.py”}。 一句话总结： 它是脚本接收到的上下文数据包。 4.Hook Output (钩子输出) —— “安检员的最终决定”\n定义： 你的脚本运行结束后，反馈给 Claude Code 的信息。 核心组成： 退出码 (Exit Code)： 0 代表“成功/放行”，非 0 代表“失败/中止”。 打印信息 (Stdout/Stderr)： 你在脚本中 print() 的内容，会作为反馈信息显示给用户。 一句话总结： 它是脚本的判决书和给用户的留言。 5.Working with MCP Tools (处理特殊旅客) —— “针对外部工具的规则”\n定义： 这是一个特定的应用场景，指 Hook 如何针对 MCP 工具（外部扩展工具，如数据库连接器）进行拦截。 核心区别： 拦截外部工具需要使用专门的 matcher: “UseMcpTool”。 一句话总结： 它是针对外部扩展工具的特定拦截规则。 2.3 command 与 script 的核心区别 command：简单、直接，不能接收来自 Claude Code 的事件数据。适用于“即发即忘”的通知类任务。 script：功能强大，能通过标准输入 stdin 接收事件数据（Hook Input），并通过退出码（Hook Output）反馈处理结果。适用于需要验证、判断、与工作流交互的复杂任务。👉 参考官方文档 https://code.claude.com/docs/en/hooks#subagentstop 2.4 简单上手例子：代码修改后语法检查 需求： 每当 Claude Code 修改了代码，都自动运行 prettier 检查格式。\n配置 (.claude/settings.json)：\ncodeJSON\n{ \"hooks\": { \"PostToolUse\": [ // 事后钩子 { \"matcher\": \"Edit|MultiEdit|Write\", // 匹配文件修改操作 \"hooks\": [ { \"type\": \"command\", \"command\": \"npx prettier --check .\" // 执行格式化检查命令 } ] } ] } } 解读： 这个配置定义了一个事后钩子，在任何文件编辑操作之后，执行一个简单的命令行命令来检查代码格式。\n2.5 复杂例子：事前和事后审计钩子 需求： 在 Claude Code 每次准备执行任何命令行 (Bash) 操作之前，将该命令及其描述记录到日志文件中。\n第一步：配置事前钩子 (PreToolUse) 记录“意图” 在 .claude/settings.json 中添加：\ncodeJSON\n{ \"hooks\": { \"PreToolUse\": [ { \"matcher\": \"Bash\", \"hooks\": [ { \"type\": \"command\", \"command\": \"jq -r '\\\"INTENT: \\\\(.tool_input.command)\\\"' \u003e\u003e ~/.claude/bash-audit-log.txt\" } ] } ] } } 解读： 这个钩子的作用是创建一个命令执行日志。在 Claude Code 每次准备执行任何命令行 (Bash) 操作之前，它会先将这个即将执行的命令和它的描述，自动记录到一个名为 bash-command-log.txt 的日志文件中。\n✍️逐行解释\n让我们来拆解这段 JSON 配置：\n{ \"hooks\": { “hooks”: { … }：这是定义所有钩子的顶层容器。所有的 Hook 规则都必须写在这个大括号里面。 \"PreToolUse\": [ “PreToolUse”: [ … ]：这里定义了一个钩子事件。PreToolUse 意味着这个钩子将在 Claude Code “准备使用工具之前” (Pre-Tool-Use) 被触发。这是一个事前钩子，它有机会在操作真正发生前介入。 { \"matcher\": \"Bash\", “matcher”: “Bash”：这是触发条件。它告诉 Claude Code：“我只关心 Bash 类型的工具”。也就是说，只有当 AI 准备执行一个命令行命令时，这个钩子才会被激活。如果 AI 准备做的是修改文件 (Edit) 或网络搜索 (WebSearch)，这个钩子将保持沉默。 \"hooks\": [ “hooks”: [ … ]：这是当上述条件满足时，需要执行的具体操作列表。 { \"type\": \"command\", “type”: “command”：定义了要执行的操作类型是命令行命令。 \"command\": \"jq -r '\\\"\\\\(.tool_input.command) - \\\\(.tool_input.description // \\\"No description\\\")\\\"' \u003e\u003e ~/.claude/bash-command-log.txt\" } “command”: “…\"：这是整个例子的核心，是实际被执行的命令。我们把它拆成三个部分来理解：\njq -r ‘…’ (数据处理部分) » (数据流向部分) ~/.claude/bash-command-log.txt (数据目的地部分) 下面我们来详细讲解这三个部分。\n📄 核心命令 jq 的深度解析\njq 是一个非常强大的命令行 JSON 处理器。你可以把它想象成一个专门用来解析和格式化 JSON 数据的“瑞士军刀”。\n当这个 Hook 被触发时，Claude Code 会自动将 PreToolUse 事件的输入数据（Hook Input）——一个描述了即将执行的 Bash 命令的 JSON 对象——通过管道传递给 jq 命令。\n这个 JSON 输入数据大概长这个样子：\ncodeJSON\n{ \"tool_input\": { \"command\": \"ls -l\", \"description\": \"List files in the directory\" } } 现在我们来看 jq 命令本身：\njq -r ‘\"\\(.tool_input.command) - \\(.tool_input.description // \"No description\")\"’\njq: 调用 jq 这个程序。 -r: 代表 “raw output”（原始输出）。它的作用是，在输出结果时去掉字符串两边的双引号。如果没有它，输出到文件里的内容会是 “ls -l - List files…\"，带有多余的引号。 ’…’: 单引号里是 jq 的处理脚本。 \"…\"：脚本最外层的 \" 表示我们希望最终输出的是一个字符串。 \\(.tool_input.command)：这是 jq 的字符串插值语法。 .tool_input.command 表示“从输入的 JSON 数据中，找到 tool_input 对象，再找到它里面的 command 字段”。在这里，它会提取出 “ls -l”。 -：这是一个普通的分隔符，会原样输出。 \\(.tool_input.description // “No description”)： 它首先尝试提取 .tool_input.description 字段。 // 是 jq 中的默认值操作符。如果 description 字段存在且不为 null，就使用它的值。如果它不存在或者为 null，就使用 // 后面的默认值 “No description”。这使得脚本非常健壮，即使 AI 有时没有提供描述，日志也不会出错。 所以，这一整段 jq 命令的作用就是：读取输入的 JSON，提取出 command 和 description，然后把它们格式化成一个像 ls -l - List files in the directory 这样的、人类可读的字符串。\n数据流向与目的地\n»: 这是标准的 Shell 追加重定向操作符。它会将 jq 命令处理后输出的字符串，追加到指定文件的末尾。使用 » 而不是 \u003e 可以确保日志文件是不断累加的，而不是每次都被覆盖。 ~/.claude/bash-command-log.txt: 这是日志文件的存储路径。~ 代表用户的主目录（Home Directory）。这意味着无论你在哪个项目里运行 Claude Code，所有的 Bash 命令执行记录都会被统一记录到用户主目录下的同一个全局日志文件中。 📌总结一下完整流程\nClaude Code 准备执行一个 Bash 命令，比如 ls -l。 PreToolUse 事件被触发，matcher 成功匹配到 Bash。 Claude Code 将包含 { “command”: “ls -l”, “description”: “…” } 的 JSON 数据作为输入，传递给 Hook 中定义的 command。 系统终端执行 jq 命令，jq 从输入中读取 JSON，将其格式化为字符串 ls -l - List files in the directory。 \u003e\u003e 操作符捕获这个字符串，并将其作为新的一行写入到 ~/.claude/bash-command-log.txt 文件中。 这个 Hook 执行完毕后，Claude Code 才会继续执行原来的 ls -l 命令。 这个例子巧妙地利用了 PreToolUse 事件、command 类型、jq 工具和 Shell 重定向，实现了一个非侵入式、全局生效的 AI 行为审计功能。侵入式、全局生效的 AI 行为审计功能。\n第二步：配置事后钩子 (PostToolUse) 记录“结果”\n因为 PreToolUse 钩子是在命令即将被执行之前触发的，所以它能捕获到的信息只有：\n将要执行的命令本身（例如 rm -rf temp/）。 AI 对这个命令的描述。 在那个时间点，命令还没有被交给操作系统去执行，因此任何由该命令产生的结果都是未知的。具体来说\n看不到标准输出 (stdout)： 比如 ls -l 命令会列出哪些文件，在 PreToolUse 阶段是不知道的。 看不到标准错误 (stderr)： 如果命令执行失败，失败的原因在 PreToolUse 阶段也是不知道的。 看不到文件系统变化： rm 命令到底成功删除了哪些文件，mkdir 命令是否成功创建了文件夹，这些在 PreToolUse 阶段都无法获知。 🔍所以PreToolUse只能审计 AI 打算做什么，而不能审计它实际做成了什么**。它是一个行为意图的记录器。\n❓如何记录“结果”？\n为了解决这个问题，Claude Code 提供了 PreToolUse 的“另一半”—— 💎PostToolUse 钩子。\nPostToolUse 钩子是在命令执行完成之后触发的。它接收到的 Hook Input (输入数据) 就包含了命令执行的结果。\nPostToolUse 的输入数据（JSON 格式）大致如下：PostToolUse 的输入数据（JSON 格式）大致如下：\n{ \"tool_output\": { \"stdout\": \"这是命令的标准输出内容...\", \"stderr\": \"这是命令的错误输出内容...\" } } 示例：创建一个记录“结果”的日志钩子\n我们可以再创建一个钩子，专门用来记录命令执行后的结果。\n修改 settings.json 文件： 我们可以添加一个新的 PostToolUse 钩子。\ncodeJSON\n{ \"hooks\": { // ... 这是我们之前创建的 PreToolUse 钩子 ... \"PreToolUse\": [ { \"matcher\": \"Bash\", \"hooks\": [ { \"type\": \"command\", \"command\": \"jq -r '\\\"INTENT: \\\\(.tool_input.command)\\\"' \u003e\u003e ~/.claude/bash-audit-log.txt\" } ] } ], // +++ 这是我们新添加的 PostToolUse 钩子 +++ \"PostToolUse\": [ { \"matcher\": \"Bash\", \"hooks\": [ { \"type\": \"command\", \"command\": \"jq -r '\\\"RESULT: STDOUT=\\\\(.tool_output.stdout // \\\\\\\"\\\\\\\") | STDERR=\\\\(.tool_output.stderr // \\\\\\\"\\\\\\\")\\\"' \u003e\u003e ~/.claude/bash-audit-log.txt\" } ] } ] } } 代码解释：\n“PostToolUse”: 在工具使用之后触发。 jq -r ‘…：同样使用 jq 来处理。 \"RESULT: …\"：输出一个以 “RESULT:” 开头的字符串。 STDOUT=\\(.tool_output.stdout // \\\"\\\")：提取标准输出。如果 stdout 为空 (null)，则 // 默认值操作符会将其替换为一个空字符串 “\"，避免日志中出现 “null” 字样。 STDERR=\\(.tool_output.stderr // \\\"\\\")：同理，提取标准错误。 \u003e\u003e ~/.claude/bash-audit-log.txt：将结果追加到同一个日志文件中。 最终效果：完整的审计闭环，当您同时配置了 PreToolUse 和 PostToolUse 这两个钩子后，您的 bash-audit-log.txt 日志文件就会变成这样，形成一个完美的审计闭环：\n解读： 这会在 Bash 命令执行后，从 Hook Input (tool_output) 中提取标准输出 (stdout) 和标准错误 (stderr)，格式化后同样追加到日志文件中。\n最终的审计闭环日志 (bash-audit-log.txt) 效果：\n# 1. 事前钩子记录意图 INTENT: rm non_existent_file.txt # 2. 事后钩子记录结果 RESULT: STDOUT= | STDERR=rm: cannot remove 'non_existent_file.txt': No such file or directory 通过 PreToolUse 和 PostToolUse 的组合，我们完美地实现了对 AI 行为的意图记录和结果审计，形成了一个强大而完整的监控闭环。\n🖥️ 第五部分：可视化操作 - Claudia 桌面应用 对于不习惯纯命令行的用户，社区提供了 Claudia 这个开源的桌面应用。它为 Claude Code 的核心功能提供了图形化界面：\n项目和对话管理： 直观地查看和切换不同的项目和历史会话。 可视化配置： 通过点击界面来创建和管理 Agents, MCP, 自定义命令, Hooks 等。 历史检查点 (Checkpoints)： 强大的“时间旅行”功能，可以一键将文件系统状态和对话历史同时回退到之前的某个时间点，是撤销误操作的神器。 ","wordCount":"1182","inLanguage":"en","datePublished":"2025-11-13T19:05:00+08:50","dateModified":"2025-11-13T19:05:00+08:50","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/claude-code-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Claude Code 常用命令使用解析</h1><div class=post-meta><span title='2025-11-13 19:05:00 +0850 +0850'>November 13, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h1 id=claude-code-常用命令使用解析>Claude Code 常用命令使用解析<a hidden class=anchor aria-hidden=true href=#claude-code-常用命令使用解析>#</a></h1><p>大家好，作为一个刚接触 Claude Code 的新手，我根据官方文档和一些热门的介绍视频，整理这份学习笔记和实践总结。主要是为了记录自己的学习过程，同时也希望能起到一个抛砖引玉的作用，为同样在入门路上的朋友们提供一些参考和便利。</p><p>这篇总结更多是我个人的理解和实践，内容可能比较基础，难免有疏漏或错误之处，对于经验丰富的高手们，可以直接略过这篇文章。</p><h2 id=-第一部分基础入门---安装与启动>🚀 第一部分：基础入门 - 安装与启动<a hidden class=anchor aria-hidden=true href=#-第一部分基础入门---安装与启动>#</a></h2><h3 id=1-环境准备>1. 环境准备<a hidden class=anchor aria-hidden=true href=#1-环境准备>#</a></h3><ul><li><strong>安装 Node.js：</strong> Claude Code 是一个基于 Node.js 的命令行工具。请先访问 <a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fnodejs.org%2F">Node.js 官网</a>，下载并安装推荐的 LTS (长期支持) 版本。</li></ul><h3 id=2-安装-claude-code>2. 安装 Claude Code<a hidden class=anchor aria-hidden=true href=#2-安装-claude-code>#</a></h3><ul><li><p>打开你的终端（Windows 用户使用 PowerShell，Mac/Linux 用户使用 Terminal），输入以下命令并回车：</p><p>codeBash</p><pre tabindex=0><code>npm install -g @anthropic-ai/claude-code
</code></pre><blockquote><p><strong>【原理讲解】</strong> npm 是 Node.js 的包管理器。-g 参数代表“全局安装”，这意味着你可以在电脑的任何文件夹中使用 claude 命令。</p></blockquote></li></ul><h3 id=3-启动与初始化>3. 启动与初始化<a hidden class=anchor aria-hidden=true href=#3-启动与初始化>#</a></h3><ol><li><strong>创建项目文件夹：</strong> 在你希望的位置创建一个新文件夹（例如 my-first-app），然后通过终端进入该文件夹。</li><li><strong>启动 Claude Code：</strong> 在项目文件夹的终端中，输入 claude 并回车。</li><li><strong>初始化项目：</strong> 启动后，立刻输入 /init 命令。</li></ol><blockquote><p><strong>【至关重要】</strong> /init 命令是与 Claude Code 高效协作的基石。它会扫描当前项目并创建一个 CLAUDE.md 文件。这个文件相当于 AI 的“项目记忆”，后续所有操作，AI 都会参考它来理解你的项目结构，确保它的行为与你的项目高度相关。</p></blockquote><hr><h2 id=-第二部分核心交互---与-ai-高效对话>🧠 第二部分：核心交互 - 与 AI 高效对话<a hidden class=anchor aria-hidden=true href=#-第二部分核心交互---与-ai-高效对话>#</a></h2><p>掌握以下命令，你就能像指挥一位得力助手一样，精准地管理 AI 的“记忆”和“专注力”。</p><table><thead><tr><th>命令</th><th>功能</th><th>详细解读</th></tr></thead><tbody><tr><td>/init</td><td><strong>初始化项目</strong></td><td><strong>最重要的命令</strong>。为项目创建 CLAUDE.md 上下文文件，让 AI 拥有对项目的宏观认知。</td></tr><tr><td>/compact</td><td><strong>压缩上下文</strong></td><td>智能地“忘记”不重要的历史对话，保留核心摘要，<strong>提高 AI 专注力并节省 Token 消耗</strong>。可以附加指令，如 /compact 主要保留前端对话。</td></tr><tr><td>/clear</td><td><strong>清理上下文</strong></td><td>当开始一个全新任务时，用它来清空对话历史，避免 AI 受到之前内容的干扰。</td></tr><tr><td>think<br>think hard<br>think harder<br>ultrathink</td><td><strong>提升思考强度</strong></td><td>在提问前加上这些官方内置的指令，可以逐步增加 AI 用于思考和规划的计算资源。对于复杂任务，ultrathink 能带来更全面的解决方案。</td></tr><tr><td>! (例如 ! npm install)</td><td><strong>临时命令行模式</strong></td><td>无需切换窗口，直接在 Claude Code 中执行系统命令。<strong>执行的命令和结果会自动加入上下文</strong>，AI 会知道你刚刚做了什么。</td></tr><tr><td># (例如 # 使用 Next.js 14)</td><td><strong>添加记忆</strong></td><td>将重要信息添加为“长期记忆”。可以选择仅对当前项目生效 (Project memory) 或全局生效 (User memory)。</td></tr></tbody></table><hr><h2 id=-第三部分生态集成---让-claude-code-融入你的工作流>⚙️ 第三部分：生态集成 - 让 Claude Code 融入你的工作流<a hidden class=anchor aria-hidden=true href=#-第三部分生态集成---让-claude-code-融入你的工作流>#</a></h2><p>Claude Code 的强大之处在于它能与你现有的开发工具无缝集成。</p><h3 id=1-ide-集成-ide>1. IDE 集成 (/ide)<a hidden class=anchor aria-hidden=true href=#1-ide-集成-ide>#</a></h3><ul><li><strong>准备：</strong> 在你的 IDE (如 VS Code) 中安装官方插件 Claude Code for VSCode。</li><li><strong>连接：</strong> 在 Claude Code 中运行 /ide 命令并连接到你的 IDE。</li><li><strong>核心功能：</strong><ul><li><strong>代码感知：</strong> 你在 IDE 中选中的代码，Claude Code 能实时感知并进行问答。</li><li><strong>代码修改同步：</strong> AI 对代码的修改会直接在 IDE 中以“差异对比 (Diff)”视图呈现，让你清晰地看到变更，并一键接受。</li></ul></li></ul><h3 id=2-mcp-model-context-protocol-集成>2. MCP (Model Context Protocol) 集成<a hidden class=anchor aria-hidden=true href=#2-mcp-model-context-protocol-集成>#</a></h3><ul><li><strong>概念：</strong> MCP 是一种让 AI 与<strong>外部工具</strong>（如数据库、API、文件系统）交互的协议。</li><li><strong>作用：</strong> 极大地扩展了 AI 的能力边界。例如，通过 context7 这个 MCP Server，AI 可以查询到最新的第三方库文档，弥补自身知识库的滞后性。</li><li><strong>使用：</strong> 通过 claude mcp add 命令进行添加。</li></ul><h3 id=3-github-集成>3. GitHub 集成<a hidden class=anchor aria-hidden=true href=#3-github-集成>#</a></h3><ul><li><strong>准备：</strong> 安装 <a href="https://www.google.com/url?sa=E&amp;q=https%3A%2F%2Fcli.github.com%2F">GitHub CLI</a>。</li><li><strong>作用：</strong> 授权后的 Claude Code 可以直接操作你的 GitHub 仓库。</li><li><strong>强大之处：</strong> 可以实现惊人的自动化工作流。例如，你可以直接告诉它：“<strong>查看 GitHub 仓库里的 Issue #1，根据描述修复这个 bug，创建一个名为 bugfix/login-error 的新分支，然后将修改推送到这个分支。</strong>” Claude Code 会一步步自动完成所有操作。</li></ul><hr><h2 id=-第四部分自动化与智能化---hooks-与-subagents>🤖 第四部分：自动化与智能化 - Hooks 与 SubAgents<a hidden class=anchor aria-hidden=true href=#-第四部分自动化与智能化---hooks-与-subagents>#</a></h2><p>这是 Claude Code 最能体现其“智能”的两个高级功能。它们能将重复性的工作流程自动化，甚至让 AI 自我修正，极大地提升开发效率。</p><h3 id=1-subagent-子代理>1. SubAgent (子代理)<a hidden class=anchor aria-hidden=true href=#1-subagent-子代理>#</a></h3><ul><li><strong>概念：</strong> 类似于编程中的“多线程”或现实生活中的“专家团队”。主 Agent (你的主对话) 可以将一个复杂的任务<strong>拆解</strong>成多个独立的子任务，并分配给不同的、专门的 <strong>SubAgent</strong> 去<strong>并行执行</strong>。</li><li><strong>优势：</strong><ul><li><strong>专注：</strong> 每个 SubAgent 只关心自己的小任务，拥有独立的、精简的上下文，不易出错。</li><li><strong>高效：</strong> 并行处理可以显著加快复杂任务的完成速度。</li></ul></li></ul><h4 id=11-创建并使用你的第一个-subagent-新手教程>1.1 创建并使用你的第一个 SubAgent (新手教程)<a hidden class=anchor aria-hidden=true href=#11-创建并使用你的第一个-subagent-新手教程>#</a></h4><p>创建一个专门负责“播报天气”的 SubAgent。</p><p><strong>第一步：进入 Agent 管理界面</strong></p><ul><li><strong>操作：</strong> 在 Claude Code 中输入 /agents 并回车。</li></ul><p><strong>第二步：开始创建新 Agent</strong></p><ul><li><strong>操作：</strong> 你会看到一个菜单，选择 > Create new agent 并回车。</li></ul><p><strong>第三步：定义 Agent 的角色 (核心)</strong></p><ul><li><p><strong>操作：</strong> 这是最关键的一步。你需要用自然语言清晰地描述这个 Agent 的职责。输入以下描述：</p><blockquote><p>你是一个天气预报大师，使用联网工具查询天气。</p></blockquote></li></ul><p><strong>第四步：为 Agent 分配工具</strong></p><ul><li><strong>操作：</strong> 接下来会让你选择这个 Agent 可以使用哪些工具。对于一个天气预报员，它需要联网。为了简单起见，新手可以直接选择 [x] All tools (所有工具)。</li><li><strong>进阶提示：</strong> 在实际应用中，为了安全和专注，你应该只为 Agent 分配它完成任务所必需的最小工具集。比如，天气 Agent 只需要 WebSearch 工具就足够了。</li></ul><p><strong>第五步：选择模型和颜色</strong></p><ul><li><strong>操作：</strong> 选择一个模型（通常默认的 Sonnet 即可），然后为你的 Agent 选一个颜色（例如 Blue），这样在对话中可以轻松区分它。</li></ul><p><strong>第六步：确认并保存</strong></p><ul><li><strong>操作：</strong> 回车确认，你的第一个 SubAgent weather-forecast-master 就创建完成了！</li></ul><h4 id=12-如何调用-subagent>1.2 如何调用 SubAgent<a hidden class=anchor aria-hidden=true href=#12-如何调用-subagent>#</a></h4><p>有两种方式可以调用你创建的 SubAgent：</p><ol><li><p><strong>隐式调用 (自动委派)：</strong>
这是最智能的方式。你只需要在主对话中提出一个包含多个任务的复杂请求，主 Agent 会自动分析并将合适的子任务委派给对应的 SubAgent。</p><blockquote><p><strong>示例：</strong> “帮我审查 feature/new-ui 分支的代码，并查一下北京今天的天气怎么样？”</p><p>Claude Code 会自动将“审查代码”的任务交给代码审查 Agent，将“查天气”的任务交给天气预报 Agent。</p></blockquote></li><li><p><strong>显式调用 (手动指定)：</strong>
如果你想强制使用某个 Agent，可以在对话中使用 @ 符号来直接呼叫它。</p><blockquote><p><strong>示例：</strong> @weather-forecast-master 北京今天天气如何？</p><p>这会确保只有 weather-forecast-master 这个 Agent 来处理你的请求。</p></blockquote></li></ol><h3 id=2-hooks-钩子终极自动化工具>2. Hooks (钩子)：终极自动化工具<a hidden class=anchor aria-hidden=true href=#2-hooks-钩子终极自动化工具>#</a></h3><p>这是我们重点讲解的部分，也是实现高度自动化工作流的关键。</p><h4 id=21-钩子是什么>2.1 钩子是什么？<a hidden class=anchor aria-hidden=true href=#21-钩子是什么>#</a></h4><ul><li><strong>定义：</strong> 钩子是一种<strong>事件驱动</strong>的自动化机制。它允许你在 Claude Code 工作流程的<strong>特定事件发生时</strong>，自动<strong>触发并执行预先定义好的操作</strong>。</li><li><strong>运行原理：</strong><ol><li><strong>监听 (Listening)：</strong> Claude Code 在运行时会不断广播各种事件信号（如 PreToolUse）。</li><li><strong>匹配 (Matching)：</strong> 你定义的 Hook 监听到信号后，会检查<strong>事件类型</strong>和<strong>触发条件 (Matcher)</strong> 是否都匹配。</li><li><strong>触发与执行 (Triggering & Execution)：</strong> 匹配成功后，Hook 被触发，系统暂停当前流程，去执行你定义的操作。</li><li><strong>反馈 (Feedback)：</strong> 脚本的执行结果（通过<strong>退出码</strong>）可以反过来影响 Claude Code 的后续行为（是继续还是中止）。</li></ol></li></ul><h4 id=22-钩子的运行>2.2 钩子的运行<a hidden class=anchor aria-hidden=true href=#22-钩子的运行>#</a></h4><p>为了更好地理解 Hook，我们可以把它想象成一个机场的“智能安检系统”，它的工作流程由以下四个核心概念构成：</p><p>1.<strong>Hook Events (钩子事件) —— “安检的时机”</strong></p><ul><li><p><strong>定义：</strong> Hook 被触发的<strong>时间点</strong>。</p></li><li><p><strong>核心类型：</strong></p><ul><li>PreToolUse：在工具<strong>使用之前</strong>触发。（相当于登机前的安检）。</li><li>PostToolUse：在工具<strong>使用之后</strong>触发。（相当于落地后的海关检查）。</li><li>Notification, UserPromptSubmit 等。</li></ul><p><strong>常用列表</strong>：</p><table><thead><tr><th>触发事件</th><th>触发时机</th></tr></thead><tbody><tr><td>PreToolUse</td><td>在工具<strong>使用之前</strong>触发。（事前钩子）</td></tr><tr><td>PostToolUse</td><td>在工具<strong>使用之后</strong>触发。（事后钩子）</td></tr><tr><td>Notification</td><td>系统发出通知时触发。</td></tr><tr><td>UserPromptSubmit</td><td>用户提交新消息时触发。</td></tr></tbody></table></li><li><p><strong>一句话总结：</strong> 它是<strong>触发器</strong>，决定了你的逻辑在哪个阶段介入。</p></li></ul><p>2.<strong>触发条件 (Matchers) —— “安检系统针对哪种旅客？”</strong></p><ul><li><p><strong>定义：</strong> Matcher 是一个<strong>过滤器</strong>，它精确地告诉 Hook 应该关注<strong>哪一种或哪一类工具</strong>的行为。</p></li><li><p><strong>作用：</strong> 确保 Hook 只在您关心的特定操作上触发，而不是对所有操作都做出反应。</p></li><li><p><strong>触发条件 (Matchers) - “针对哪个工具？”</strong></p><table><thead><tr><th>Matcher</th><th>对应的工具/操作</th></tr></thead><tbody><tr><td>Edit MultiEdit Write</td><td>文件创建、编辑、写入</td></tr><tr><td>Bash</td><td>执行命令行命令</td></tr><tr><td>Task Subagent</td><td>创建子任务或子代理</td></tr><tr><td>WebFetch WebSearch</td><td>访问网页或网络搜索</td></tr><tr><td>UseMcpTool</td><td><strong>使用外部 MCP 工具</strong></td></tr></tbody></table></li><li><p><strong>组合使用：</strong> 您可以用 |（代表“或”）来组合多个 Matcher，例如 &ldquo;matcher&rdquo;: &ldquo;Edit|Write&rdquo; 表示当“编辑”或“写入”文件时都触发。</p></li><li><p><strong>一句话总结：</strong> 它是<strong>过滤器</strong>，是 Hook 触发的精确条件。</p></li></ul><p>3.<strong>Hook Input (钩子输入) —— “安检员拿到的旅客信息”</strong></p><ul><li><strong>定义：</strong> 当事件触发时，Claude Code <strong>通过标准输入 (Stdin) “喂”给你的脚本的数据</strong>，通常是 JSON 格式。</li><li><strong>核心作用：</strong> 让你的脚本知道“要发生什么”或“发生了什么”。例如，对于 PreToolUse 事件，Input 会包含工具名和参数，如 {&ldquo;tool&rdquo;: &ldquo;Edit&rdquo;, &ldquo;path&rdquo;: &ldquo;main.py&rdquo;}。</li><li><strong>一句话总结：</strong> 它是<strong>脚本接收到的上下文数据包</strong>。</li></ul><p>4.<strong>Hook Output (钩子输出) —— “安检员的最终决定”</strong></p><ul><li><strong>定义：</strong> 你的脚本运行结束后，<strong>反馈给 Claude Code 的信息</strong>。</li><li><strong>核心组成：</strong><ul><li><strong>退出码 (Exit Code)：</strong> 0 代表“成功/放行”，非 0 代表“失败/中止”。</li><li><strong>打印信息 (Stdout/Stderr)：</strong> 你在脚本中 print() 的内容，会作为反馈信息显示给用户。</li></ul></li><li><strong>一句话总结：</strong> 它是<strong>脚本的判决书和给用户的留言</strong>。</li></ul><p>5.<strong>Working with MCP Tools (处理特殊旅客) —— “针对外部工具的规则”</strong></p><ul><li><strong>定义：</strong> 这是一个特定的应用场景，指 Hook 如何针对 <strong>MCP 工具</strong>（外部扩展工具，如数据库连接器）进行拦截。</li><li><strong>核心区别：</strong> 拦截外部工具需要使用专门的 matcher: &ldquo;UseMcpTool&rdquo;。</li><li><strong>一句话总结：</strong> 它是<strong>针对外部扩展工具的特定拦截规则</strong>。</li></ul><h4 id=23-command-与-script-的核心区别>2.3 command 与 script 的核心区别<a hidden class=anchor aria-hidden=true href=#23-command-与-script-的核心区别>#</a></h4><ul><li><strong>command</strong>：简单、直接，<strong>不能接收</strong>来自 Claude Code 的事件数据。适用于“即发即忘”的通知类任务。</li><li><strong>script</strong>：功能强大，<strong>能通过标准输入 stdin 接收</strong>事件数据（Hook Input），并通过<strong>退出码</strong>（Hook Output）反馈处理结果。适用于需要验证、判断、与工作流交互的复杂任务。👉 参考官方文档 <a href=https://code.claude.com/docs/en/hooks#subagentstop>https://code.claude.com/docs/en/hooks#subagentstop</a></li></ul><h4 id=24-简单上手例子代码修改后语法检查>2.4 简单上手例子：代码修改后语法检查<a hidden class=anchor aria-hidden=true href=#24-简单上手例子代码修改后语法检查>#</a></h4><p><strong>需求：</strong> 每当 Claude Code 修改了代码，都自动运行 prettier 检查格式。</p><p><strong>配置 (.claude/settings.json)：</strong></p><p>codeJSON</p><pre tabindex=0><code>{
  &#34;hooks&#34;: {
    &#34;PostToolUse&#34;: [ // 事后钩子
      {
        &#34;matcher&#34;: &#34;Edit|MultiEdit|Write&#34;, // 匹配文件修改操作
        &#34;hooks&#34;: [
          {
            &#34;type&#34;: &#34;command&#34;,
            &#34;command&#34;: &#34;npx prettier --check .&#34; // 执行格式化检查命令
          }
        ]
      }
    ]
  }
}
</code></pre><p><strong>解读：</strong> 这个配置定义了一个事后钩子，在任何文件编辑操作<strong>之后</strong>，执行一个简单的命令行命令来检查代码格式。</p><h4 id=25-复杂例子事前和事后审计钩子>2.5 复杂例子：事前和事后审计钩子<a hidden class=anchor aria-hidden=true href=#25-复杂例子事前和事后审计钩子>#</a></h4><p><strong>需求：</strong> 在 Claude Code 每次<strong>准备</strong>执行任何命令行 (Bash) 操作<strong>之前</strong>，将该命令及其描述记录到日志文件中。</p><p><strong>第一步：配置事前钩子 (PreToolUse) 记录“意图”</strong>
在 .claude/settings.json 中添加：</p><p>codeJSON</p><pre tabindex=0><code>{
  &#34;hooks&#34;: {
    &#34;PreToolUse&#34;: [
      {
        &#34;matcher&#34;: &#34;Bash&#34;,
        &#34;hooks&#34;: [
          {
            &#34;type&#34;: &#34;command&#34;,
            &#34;command&#34;: &#34;jq -r &#39;\&#34;INTENT: \\(.tool_input.command)\&#34;&#39; &gt;&gt; ~/.claude/bash-audit-log.txt&#34;
          }
        ]
      }
    ]
  }
}
</code></pre><blockquote><p><strong>解读：</strong> 这个钩子的作用是<strong>创建一个命令执行日志</strong>。在 Claude Code 每次<strong>准备</strong>执行任何命令行 (Bash) 操作<strong>之前</strong>，它会先将这个即将执行的命令和它的描述，自动记录到一个名为 bash-command-log.txt 的日志文件中。</p></blockquote><hr><p>✍️逐行解释</p><p>让我们来拆解这段 JSON 配置：</p><pre tabindex=0><code>{
  &#34;hooks&#34;: {
</code></pre><ul><li>&ldquo;hooks&rdquo;: { &mldr; }：这是定义所有钩子的<strong>顶层容器</strong>。所有的 Hook 规则都必须写在这个大括号里面。</li></ul><pre tabindex=0><code>&#34;PreToolUse&#34;: [
</code></pre><ul><li>&ldquo;PreToolUse&rdquo;: [ &mldr; ]：这里定义了一个<strong>钩子事件</strong>。PreToolUse 意味着这个钩子将在 Claude Code <strong>“准备使用工具之前”</strong> (Pre-Tool-Use) 被触发。这是一个<strong>事前钩子</strong>，它有机会在操作真正发生前介入。</li></ul><pre tabindex=0><code>{
        &#34;matcher&#34;: &#34;Bash&#34;,
</code></pre><ul><li>&ldquo;matcher&rdquo;: &ldquo;Bash&rdquo;：这是<strong>触发条件</strong>。它告诉 Claude Code：“我只关心 Bash 类型的工具”。也就是说，只有当 AI 准备执行一个<strong>命令行命令</strong>时，这个钩子才会被激活。如果 AI 准备做的是修改文件 (Edit) 或网络搜索 (WebSearch)，这个钩子将保持沉默。</li></ul><pre tabindex=0><code>&#34;hooks&#34;: [
</code></pre><ul><li>&ldquo;hooks&rdquo;: [ &mldr; ]：这是当上述条件满足时，需要执行的<strong>具体操作列表</strong>。</li></ul><pre tabindex=0><code>{
            &#34;type&#34;: &#34;command&#34;,
</code></pre><ul><li>&ldquo;type&rdquo;: &ldquo;command&rdquo;：定义了要执行的操作类型是<strong>命令行命令</strong>。</li></ul><pre tabindex=0><code>&#34;command&#34;: &#34;jq -r &#39;\&#34;\\(.tool_input.command) - \\(.tool_input.description // \&#34;No description\&#34;)\&#34;&#39; &gt;&gt; ~/.claude/bash-command-log.txt&#34;
          }
</code></pre><ul><li><p>&ldquo;command&rdquo;: &ldquo;&mldr;"：这是整个例子的核心，是实际被执行的命令。我们把它拆成三个部分来理解：</p><ol><li><strong>jq -r &lsquo;&mldr;&rsquo;</strong> (数据处理部分)</li><li><strong>&#187;</strong> (数据流向部分)</li><li><strong>~/.claude/bash-command-log.txt</strong> (数据目的地部分)</li></ol><p>下面我们来详细讲解这三个部分。</p></li></ul><hr><p>📄 核心命令 jq 的深度解析</p><p>jq 是一个非常强大的<strong>命令行 JSON 处理器</strong>。你可以把它想象成一个专门用来解析和格式化 JSON 数据的“瑞士军刀”。</p><p>当这个 Hook 被触发时，Claude Code 会自动将 PreToolUse 事件的<strong>输入数据（Hook Input）</strong>——一个描述了即将执行的 Bash 命令的 JSON 对象——通过管道传递给 jq 命令。</p><p>这个 JSON 输入数据大概长这个样子：</p><p>codeJSON</p><pre tabindex=0><code>{
  &#34;tool_input&#34;: {
    &#34;command&#34;: &#34;ls -l&#34;,
    &#34;description&#34;: &#34;List files in the directory&#34;
  }
}
</code></pre><p>现在我们来看 jq 命令本身：</p><p>jq -r &lsquo;"\(.tool_input.command) - \(.tool_input.description // "No description")"&rsquo;</p><ul><li><strong>jq</strong>: 调用 jq 这个程序。</li><li><strong>-r</strong>: 代表 &ldquo;raw output&rdquo;（原始输出）。它的作用是，在输出结果时去掉字符串两边的双引号。如果没有它，输出到文件里的内容会是 &ldquo;ls -l - List files&mldr;"，带有多余的引号。</li><li><strong>&rsquo;&mldr;&rsquo;</strong>: 单引号里是 jq 的处理脚本。<ul><li>"&mldr;"：脚本最外层的 " 表示我们希望最终输出的是一个<strong>字符串</strong>。</li><li>\(.tool_input.command)：这是 jq 的<strong>字符串插值</strong>语法。<ul><li>.tool_input.command 表示“从输入的 JSON 数据中，找到 tool_input 对象，再找到它里面的 command 字段”。在这里，它会提取出 &ldquo;ls -l&rdquo;。</li></ul></li><li>-：这是一个<strong>普通的分隔符</strong>，会原样输出。</li><li>\(.tool_input.description // &ldquo;No description&rdquo;)：<ul><li>它首先尝试提取 .tool_input.description 字段。</li><li>// 是 jq 中的<strong>默认值操作符</strong>。如果 description 字段存在且不为 null，就使用它的值。如果它不存在或者为 null，就使用 // 后面的默认值 &ldquo;No description&rdquo;。这使得脚本非常健壮，即使 AI 有时没有提供描述，日志也不会出错。</li></ul></li></ul></li></ul><p>所以，这一整段 jq 命令的作用就是：读取输入的 JSON，提取出 command 和 description，然后把它们格式化成一个像 ls -l - List files in the directory 这样的、人类可读的字符串。</p><p>数据流向与目的地</p><ul><li><strong>&#187;</strong>: 这是标准的 Shell <strong>追加重定向</strong>操作符。它会将 jq 命令处理后输出的字符串，<strong>追加</strong>到指定文件的末尾。使用 &#187; 而不是 > 可以确保日志文件是不断累加的，而不是每次都被覆盖。</li><li><strong>~/.claude/bash-command-log.txt</strong>: 这是日志文件的<strong>存储路径</strong>。~ 代表用户的<strong>主目录</strong>（Home Directory）。这意味着无论你在哪个项目里运行 Claude Code，所有的 Bash 命令执行记录都会被统一记录到用户主目录下的同一个全局日志文件中。</li></ul><p>📌总结一下完整流程</p><ol><li>Claude Code 准备执行一个 Bash 命令，比如 ls -l。</li><li>PreToolUse 事件被触发，matcher 成功匹配到 Bash。</li><li>Claude Code 将包含 { &ldquo;command&rdquo;: &ldquo;ls -l&rdquo;, &ldquo;description&rdquo;: &ldquo;&mldr;&rdquo; } 的 JSON 数据作为<strong>输入</strong>，传递给 Hook 中定义的 command。</li><li>系统终端执行 jq 命令，jq 从输入中读取 JSON，将其格式化为字符串 ls -l - List files in the directory。</li><li>>> 操作符捕获这个字符串，并将其作为新的一行写入到 ~/.claude/bash-command-log.txt 文件中。</li><li>这个 Hook 执行完毕后，Claude Code <strong>才会继续执行</strong>原来的 ls -l 命令。</li></ol><p>这个例子巧妙地利用了 PreToolUse 事件、command 类型、jq 工具和 Shell 重定向，实现了一个非侵入式、全局生效的 AI 行为审计功能。侵入式、全局生效的 AI 行为审计功能。</p><hr><p><strong>第二步：配置事后钩子 (PostToolUse) 记录“结果”</strong></p><p>因为 PreToolUse 钩子是在命令<strong>即将被执行之前</strong>触发的，所以它能捕获到的信息只有：</p><ul><li><strong>将要执行的命令本身</strong>（例如 rm -rf temp/）。</li><li>AI 对这个命令的<strong>描述</strong>。</li></ul><p>在那个时间点，命令还没有被交给操作系统去执行，因此<strong>任何由该命令产生的结果都是未知的</strong>。具体来说</p><ul><li><strong>看不到标准输出 (stdout)：</strong> 比如 ls -l 命令会列出哪些文件，在 PreToolUse 阶段是不知道的。</li><li><strong>看不到标准错误 (stderr)：</strong> 如果命令执行失败，失败的原因在 PreToolUse 阶段也是不知道的。</li><li><strong>看不到文件系统变化：</strong> rm 命令到底成功删除了哪些文件，mkdir 命令是否成功创建了文件夹，这些在 PreToolUse 阶段都无法获知。</li></ul><p>🔍所以PreToolUse只能审计 AI 打算做什么，而不能审计它实际做成了什么**。它是一个行为意图的记录器。</p><p><strong>❓如何记录“结果”？</strong></p><p>为了解决这个问题，Claude Code 提供了 PreToolUse 的“另一半”—— 💎<strong>PostToolUse 钩子</strong>。</p><p>PostToolUse 钩子是在命令<strong>执行完成之后</strong>触发的。它接收到的 Hook Input (输入数据) 就包含了命令执行的结果。</p><p>PostToolUse 的输入数据（JSON 格式）大致如下：PostToolUse 的输入数据（JSON 格式）大致如下：</p><pre tabindex=0><code>{
  &#34;tool_output&#34;: {
    &#34;stdout&#34;: &#34;这是命令的标准输出内容...&#34;,
    &#34;stderr&#34;: &#34;这是命令的错误输出内容...&#34;
  }
}
</code></pre><p><strong>示例：创建一个记录“结果”的日志钩子</strong></p><p>我们可以再创建一个钩子，专门用来记录命令执行后的结果。</p><ol><li><p><strong>修改 settings.json 文件：</strong>
我们可以添加一个新的 PostToolUse 钩子。</p><p>codeJSON</p><pre tabindex=0><code>{
  &#34;hooks&#34;: {
    // ... 这是我们之前创建的 PreToolUse 钩子 ...
    &#34;PreToolUse&#34;: [
      {
        &#34;matcher&#34;: &#34;Bash&#34;,
        &#34;hooks&#34;: [
          {
            &#34;type&#34;: &#34;command&#34;,
            &#34;command&#34;: &#34;jq -r &#39;\&#34;INTENT: \\(.tool_input.command)\&#34;&#39; &gt;&gt; ~/.claude/bash-audit-log.txt&#34;
          }
        ]
      }
    ],
    // +++ 这是我们新添加的 PostToolUse 钩子 +++
    &#34;PostToolUse&#34;: [
      {
        &#34;matcher&#34;: &#34;Bash&#34;,
        &#34;hooks&#34;: [
          {
            &#34;type&#34;: &#34;command&#34;,
            &#34;command&#34;: &#34;jq -r &#39;\&#34;RESULT: STDOUT=\\(.tool_output.stdout // \\\&#34;\\\&#34;) | STDERR=\\(.tool_output.stderr // \\\&#34;\\\&#34;)\&#34;&#39; &gt;&gt; ~/.claude/bash-audit-log.txt&#34;
          }
        ]
      }
    ]
  }
}
</code></pre></li><li><p><strong>代码解释：</strong></p><ul><li>&ldquo;PostToolUse&rdquo;: 在工具使用<strong>之后</strong>触发。</li><li>jq -r &lsquo;&mldr;：同样使用 jq 来处理。<ul><li>"RESULT: &mldr;"：输出一个以 &ldquo;RESULT:&rdquo; 开头的字符串。</li><li>STDOUT=\(.tool_output.stdout // \"\")：提取标准输出。如果 stdout 为空 (null)，则 // 默认值操作符会将其替换为一个空字符串 &ldquo;"，避免日志中出现 &ldquo;null&rdquo; 字样。</li><li>STDERR=\(.tool_output.stderr // \"\")：同理，提取标准错误。</li></ul></li><li>>> ~/.claude/bash-audit-log.txt：将结果<strong>追加</strong>到同一个日志文件中。</li></ul></li></ol><p>最终效果：完整的审计闭环，当您同时配置了 PreToolUse 和 PostToolUse 这两个钩子后，您的 bash-audit-log.txt 日志文件就会变成这样，形成一个完美的审计闭环：</p><blockquote><p><strong>解读：</strong> 这会在 Bash 命令<strong>执行后</strong>，从 <strong>Hook Input</strong> (tool_output) 中提取标准输出 (stdout) 和标准错误 (stderr)，格式化后同样追加到日志文件中。</p></blockquote><p><strong>最终的审计闭环日志 (bash-audit-log.txt) 效果：</strong></p><pre tabindex=0><code># 1. 事前钩子记录意图
INTENT: rm non_existent_file.txt
# 2. 事后钩子记录结果
RESULT: STDOUT= | STDERR=rm: cannot remove &#39;non_existent_file.txt&#39;: No such file or directory
</code></pre><p>通过 PreToolUse 和 PostToolUse 的组合，我们完美地实现了对 AI 行为的<strong>意图记录</strong>和<strong>结果审计</strong>，形成了一个强大而完整的监控闭环。</p><hr><h2 id=-第五部分可视化操作---claudia-桌面应用>🖥️ 第五部分：可视化操作 - Claudia 桌面应用<a hidden class=anchor aria-hidden=true href=#-第五部分可视化操作---claudia-桌面应用>#</a></h2><p>对于不习惯纯命令行的用户，社区提供了 Claudia 这个开源的桌面应用。它为 Claude Code 的核心功能提供了图形化界面：</p><ul><li><strong>项目和对话管理：</strong> 直观地查看和切换不同的项目和历史会话。</li><li><strong>可视化配置：</strong> 通过点击界面来创建和管理 Agents, MCP, 自定义命令, Hooks 等。</li><li><strong>历史检查点 (Checkpoints)：</strong> 强大的“时间旅行”功能，可以一键将<strong>文件系统状态</strong>和<strong>对话历史</strong>同时回退到之前的某个时间点，是撤销误操作的神器。</li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/ai/>AI</a></li><li><a href=http://ljj1992.fun/tags/claude/>Claude</a></li><li><a href=http://ljj1992.fun/tags/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/>安全工具</a></li><li><a href=http://ljj1992.fun/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/>命令行</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>