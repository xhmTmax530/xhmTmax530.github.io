<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>servlet基础知识 | star徐的博客</title><meta name=keywords content="Java,Servlet,Web开发,编程"><meta name=description content="servlet基础知识
作为安全爱好者的基础性研究
Servlet：名字的由来
Servlet = “Server” + “Applet”
早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 服务器端 的小程序，所以叫 “Server Applet”，简称 Servlet。

它在解决什么问题？

动态内容：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。
性能瓶颈：传统 CGI 为每个请求开一个进程，开销大、响应慢。
跨平台：CGI 脚本依赖操作系统，移植困难。

ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。

作用一句话
接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。
底层逻辑与框架

  
      
          阶段
          动作
          关键角色
      
  
  
      
          1. 请求到达
          浏览器发 HTTP 请求到 Web 服务器（如 Tomcat）
          Web 服务器
      
      
          2. 路由到 Servlet
          服务器根据 URL 把请求交给对应的 Servlet 类
          Servlet 容器
      
      
          3. 生命周期
          容器负责：加载类 → 创建实例 → 调用 init() → 多次 service() → 最终 destroy()
          Servlet 本身
      
      
          4. 处理请求
          service() 方法根据 HTTP 方法（GET/POST）调用 doGet()/doPost()，开发者只写业务逻辑
          HttpServlet
      
      
          5. 生成响应
          通过 HttpServletResponse 写回 HTML、JSON 或文件
          Servlet
      
      
          6. 线程复用
          同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁
          JVM 线程池
      
  

核心优势"><meta name=author content="您的姓名"><link rel=canonical href=http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://ljj1992.fun/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://ljj1992.fun/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://ljj1992.fun/favicon-32x32.png><link rel=apple-touch-icon href=http://ljj1992.fun/apple-touch-icon.png><link rel=mask-icon href=http://ljj1992.fun/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="star徐的博客"><meta property="og:title" content="servlet基础知识"><meta property="og:description" content="servlet基础知识 作为安全爱好者的基础性研究
Servlet：名字的由来
Servlet = “Server” + “Applet” 早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 服务器端 的小程序，所以叫 “Server Applet”，简称 Servlet。
它在解决什么问题？
动态内容：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。 性能瓶颈：传统 CGI 为每个请求开一个进程，开销大、响应慢。 跨平台：CGI 脚本依赖操作系统，移植困难。 ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。
作用一句话
接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。
底层逻辑与框架
阶段 动作 关键角色 1. 请求到达 浏览器发 HTTP 请求到 Web 服务器（如 Tomcat） Web 服务器 2. 路由到 Servlet 服务器根据 URL 把请求交给对应的 Servlet 类 Servlet 容器 3. 生命周期 容器负责：加载类 → 创建实例 → 调用 init() → 多次 service() → 最终 destroy() Servlet 本身 4. 处理请求 service() 方法根据 HTTP 方法（GET/POST）调用 doGet()/doPost()，开发者只写业务逻辑 HttpServlet 5. 生成响应 通过 HttpServletResponse 写回 HTML、JSON 或文件 Servlet 6. 线程复用 同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁 JVM 线程池 核心优势"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-17T23:58:00+08:00"><meta property="article:modified_time" content="2025-11-17T23:58:00+08:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Servlet"><meta property="article:tag" content="Web开发"><meta property="article:tag" content="编程"><meta name=twitter:card content="summary"><meta name=twitter:title content="servlet基础知识"><meta name=twitter:description content="servlet基础知识
作为安全爱好者的基础性研究
Servlet：名字的由来
Servlet = “Server” + “Applet”
早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 服务器端 的小程序，所以叫 “Server Applet”，简称 Servlet。

它在解决什么问题？

动态内容：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。
性能瓶颈：传统 CGI 为每个请求开一个进程，开销大、响应慢。
跨平台：CGI 脚本依赖操作系统，移植困难。

ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。

作用一句话
接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。
底层逻辑与框架

  
      
          阶段
          动作
          关键角色
      
  
  
      
          1. 请求到达
          浏览器发 HTTP 请求到 Web 服务器（如 Tomcat）
          Web 服务器
      
      
          2. 路由到 Servlet
          服务器根据 URL 把请求交给对应的 Servlet 类
          Servlet 容器
      
      
          3. 生命周期
          容器负责：加载类 → 创建实例 → 调用 init() → 多次 service() → 最终 destroy()
          Servlet 本身
      
      
          4. 处理请求
          service() 方法根据 HTTP 方法（GET/POST）调用 doGet()/doPost()，开发者只写业务逻辑
          HttpServlet
      
      
          5. 生成响应
          通过 HttpServletResponse 写回 HTML、JSON 或文件
          Servlet
      
      
          6. 线程复用
          同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁
          JVM 线程池
      
  

核心优势"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://ljj1992.fun/posts/"},{"@type":"ListItem","position":2,"name":"servlet基础知识","item":"http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"servlet基础知识","name":"servlet基础知识","description":"servlet基础知识 作为安全爱好者的基础性研究\nServlet：名字的由来\nServlet = “Server” + “Applet” 早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 服务器端 的小程序，所以叫 “Server Applet”，简称 Servlet。\n它在解决什么问题？\n动态内容：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。 性能瓶颈：传统 CGI 为每个请求开一个进程，开销大、响应慢。 跨平台：CGI 脚本依赖操作系统，移植困难。 ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。\n作用一句话\n接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。\n底层逻辑与框架\n阶段 动作 关键角色 1. 请求到达 浏览器发 HTTP 请求到 Web 服务器（如 Tomcat） Web 服务器 2. 路由到 Servlet 服务器根据 URL 把请求交给对应的 Servlet 类 Servlet 容器 3. 生命周期 容器负责：加载类 → 创建实例 → 调用 init() → 多次 service() → 最终 destroy() Servlet 本身 4. 处理请求 service() 方法根据 HTTP 方法（GET/POST）调用 doGet()/doPost()，开发者只写业务逻辑 HttpServlet 5. 生成响应 通过 HttpServletResponse 写回 HTML、JSON 或文件 Servlet 6. 线程复用 同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁 JVM 线程池 核心优势\n","keywords":["Java","Servlet","Web开发","编程"],"articleBody":"servlet基础知识 作为安全爱好者的基础性研究\nServlet：名字的由来\nServlet = “Server” + “Applet” 早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 服务器端 的小程序，所以叫 “Server Applet”，简称 Servlet。\n它在解决什么问题？\n动态内容：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。 性能瓶颈：传统 CGI 为每个请求开一个进程，开销大、响应慢。 跨平台：CGI 脚本依赖操作系统，移植困难。 ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。\n作用一句话\n接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。\n底层逻辑与框架\n阶段 动作 关键角色 1. 请求到达 浏览器发 HTTP 请求到 Web 服务器（如 Tomcat） Web 服务器 2. 路由到 Servlet 服务器根据 URL 把请求交给对应的 Servlet 类 Servlet 容器 3. 生命周期 容器负责：加载类 → 创建实例 → 调用 init() → 多次 service() → 最终 destroy() Servlet 本身 4. 处理请求 service() 方法根据 HTTP 方法（GET/POST）调用 doGet()/doPost()，开发者只写业务逻辑 HttpServlet 5. 生成响应 通过 HttpServletResponse 写回 HTML、JSON 或文件 Servlet 6. 线程复用 同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁 JVM 线程池 核心优势\n高性能：线程级并发，不是进程级。 可移植：任何支持 Java 的服务器都能跑。 功能全：Session、Cookie、过滤器、监听器一应俱全。 可扩展：配合 JSP、Filter、Listener 构成完整的 Java Web 体系。 Servlet 的完整生命周期和工作流程 用大白话 + 原理 + 代码演示，把每一个阶段掰开揉碎，分析每个阶段它到底做了点什么：\n从浏览器点下回车开始，到服务器返回网页结束，中间到底发生了什么？\n🧭 全局流程图（先看个全景）\n用户请求 → Tomcat 接收 → 找到对应 Servlet → 创建/复用实例 → 调用 doGet/doPost → 生成响应 → 返回网页 ↑ ↑ ↑ 路由匹配 生命周期 业务逻辑执行 我们分 5 个阶段 来讲： ✅ 阶段一：路由到 Servlet（URL 找类） ✅ 阶段二：Servlet 生命周期（创建、初始化、销毁） ✅ 阶段三：处理请求（doGet/doPost） ✅ 阶段四：生成响应（写回 HTML/JSON） ✅ 阶段五：线程并发（多个用户同时访问） 每个阶段都配 代码 + 逐行解释 + 大白话 + 原理说明。\n📌 阶段一：路由到 Servlet（URL 找类） 💬 大白话：\n你访问 http://localhost:8080/hello，Tomcat 怎么知道该让哪个 Java 类来处理？ 靠的是 映射规则，就像“门牌号”一样，告诉服务器：“/hello 这个地址归 HelloServlet 管”。\n🔧 两种方式设置路由：\n方式一：用注解（推荐）\n@WebServlet(\"/hello\") public class HelloServlet extends HttpServlet { ... } 方式二：写 web.xml\nHello com.example.HelloServlet Hello /hello 👉 无论哪种方式，最终结果都是：URL → Servlet 类 的映射表\n📌 阶段二：Servlet 生命周期（创建 → 初始化 → 使用 → 销毁） Servlet 不是“用一次就扔”，而是“一次创建，长期服役”。\n🔄 生命周期三阶段：\n阶段 方法 何时触发 调用几次 初始化 init() 第一次请求到达时 1次 服务 service() → doGet()/doPost() 每次请求 多次 销毁 destroy() 服务器关闭或卸载应用 1次 💡 注意：一个 Servlet 类只创建一个实例，但会被多个线程同时调用！\n📄 代码演示：带生命周期日志的 HelloServlet package com.example; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; // 1. 告诉 Tomcat：这个类处理 /hello 路径的请求 @WebServlet(\"/hello\") public class HelloServlet extends HttpServlet { private int requestCount = 0; // 记录被访问了多少次 // 2. 初始化阶段：Tomcat 创建这个类的实例后，自动调用 init() @Override public void init() throws ServletException { System.out.println(\"🔧 HelloServlet 正在初始化！这是第一次启动！\"); super.init(); } // 3. 服务阶段：每次有请求来，都会调用 service()，它会自动分发到 doGet 或 doPost @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"⚡ 请求进来了！准备处理...\"); super.service(req, resp); // 调用父类逻辑，根据请求方法决定走 doGet 还是 doPost } // 4. 处理 GET 请求 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // 每处理一次，计数器 +1 requestCount++; System.out.printf(\"🟢 正在处理第 %d 次 GET 请求，来自: %s%n\", requestCount, req.getRemoteAddr()); // 设置响应内容类型为 HTML resp.setContentType(\"text/html;charset=UTF-8\"); // 获取输出流，用来写回网页内容 PrintWriter out = resp.getWriter(); // 写出 HTML 页面 out.println(\"你好，世界！\"); out.println(\"你是第 \" + requestCount + \" 个访问者\n\"); out.println(\"你的 IP 是：\" + req.getRemoteAddr() + \"\n\"); } // 5. 当服务器关闭时，自动调用 destroy() @Override public void destroy() { System.out.println(\"🛑 HelloServlet 正在销毁！再见！\"); super.destroy(); } } 🔍 逐行解释（重点！）\n行 代码 @WebServlet(\"/hello\") 给这个类贴个“门牌号”：谁访问 /hello，就找它 extends HttpServlet 继承父类，获得处理 HTTP 请求的能力（比如自动区分 GET/POST） init() 第一次请求来之前，Tomcat 会调用一次，适合做“准备工作”（比如连接数据库） service() 每次请求都先进这里，然后它自动判断是 GET 还是 POST，再转发给 doGet 或 doPost super.service(...) 调用父类的标准流程，不要删！ doGet() 专门处理 GET 请求（比如浏览器地址栏访问） requestCount++ 记录总共被访问了多少次（注意：这是成员变量！多个线程共享） resp.setContentType(...) 告诉浏览器：“我要返回的是 HTML，用 UTF-8 编码” PrintWriter out = resp.getWriter() 拿到“笔”，可以往响应里写内容 out.println(...) 把 HTML 内容一行行写回去 destroy() 服务器关闭前调用，适合做“收尾工作”（比如关闭数据库连接） 📌 阶段三：处理请求（doGet/doPost） 💬 大白话：\n你可以把 doGet 想象成一个“服务员”，他每天上班（服务期），只要客人点单（发请求），他就按菜单（代码）上菜（返回网页）。\n🔧 HttpServletRequest 是什么？\n它是“请求包裹”，里面装着：\n用户的 IP（getRemoteAddr()） 请求参数（getParameter(\"name\")） 请求头（User-Agent、Cookie 等） Session 信息 🔧 HttpServletResponse 是什么？\n它是“响应包裹”，你要把生成的内容（HTML、JSON）塞进去，然后“打包发回去”。\n📌 阶段四：生成响应（写回 HTML） 💬 大白话：\n你不是在写网页，而是在“拼字符串”。 Java 代码像厨师一样，把 HTML 片段一个个拼起来，最后做成一道“动态菜”。\n🔧 关键点：\nresp.getWriter()：拿到输出流； out.println()：把内容写出去； 内容可以是 HTML、JSON、XML、文件下载等。 📌 阶段五：线程并发（多个用户同时访问） 💬 大白话：\n想象你开了家面馆，只有一个厨师（HelloServlet 实例），但来了 10 个客人（10 个请求）。 怎么办？ 你让 10 个服务员（线程）轮流找厨师下单，厨师做好一碗就递给对应服务员。\n👉 一个 Servlet 实例，被多个线程并发调用。\n⚠️ 危险点：\nprivate int requestCount = 0; // 共享变量！ 如果多个线程同时修改它，可能出现“计数不准”（线程安全问题）。 但在本例中，我们只是演示，不深究锁机制。\n🧪 实验：亲自验证生命周期 步骤 1：启动应用\n运行 Spring Boot 或传统 Web 项目，启动 Tomcat。\n步骤 2：第一次访问\n浏览器打开：\nhttp://localhost:8080/hello 控制台输出：\n🔧 HelloServlet 正在初始化！这是第一次启动！ ⚡ 请求进来了！准备处理... 🟢 正在处理第 1 次 GET 请求，来自: 127.0.0.1 👉 init() 只执行了一次！\n步骤 3：刷新几次\n再刷新 2 次页面。\n控制台输出：\n⚡ 请求进来了！准备处理... 🟢 正在处理第 2 次 GET 请求，来自: 127.0.0.1 ⚡ 请求进来了！准备处理... 🟢 正在处理第 3 次 GET 请求，来自: 127.0.0.1 步骤 4：关闭服务器\n🛑 HelloServlet 正在销毁！再见！ 👉 destroy() 在最后执行！\n🎯 总结：Servlet 工作全流程 阶段 发生了什么 类比 1. 路由 URL → Servlet 类 门牌号找房东 2. 初始化 new HelloServlet() → init() 房东搬进来，打扫房子 3. 服务 每次请求 → service() → doGet 房东接待租客 4. 响应 resp.getWriter().println(...) 给租客递钥匙 5. 并发 多个线程共享一个实例 一个房东服务多个租客 6. 销毁 服务器关闭 → destroy() 房东搬走，打扫卫生 ✅ 一句话总结 Servlet 就是一个长期住在服务器里的“Java 小程序”，它有一个固定的“上岗-工作-下班”流程，能接收请求、动态生成网页、并发服务多人，是 Java Web 的基石。\n🚀 下一步建议 你现在可以：\n把上面的 HelloServlet 跑起来，亲眼看看日志； 改成 doPost，用 Postman 发 POST 请求； 加一个参数：?name=小明，让网页显示“你好，小明！”； 研究 Filter（过滤器）——在 Servlet 前后加“安检门”。 容器这个东东？ 大白话通俗解释： 容器就是“装对象的大盒子”，它在程序启动时就把所有需要的对象一次性“造好”，然后一直管着它们——什么时候用、用多少、用完怎么销毁，都由盒子说了算。你写的类只是“图纸”，容器负责按图纸造东西、把东西放进盒子，并在盒子的生命周期里随时给你调用。\n原理层面：\n启动阶段：容器读配置（XML、注解或 Java 代码），把每个要管理的类变成对象（实例化），并把它们之间的依赖关系也一次性配好。 运行阶段：程序里用到的对象都直接从盒子里拿，容器保证每次拿到的都是“已经装好、随时能用”的完整对象。 销毁阶段：程序关闭，容器把盒子里所有对象一次性清理掉，避免内存泄漏。 和注解的关系： 注解只是“贴标签”，告诉容器“这个类要放进盒子”“这两个对象之间有依赖”。真正干活的还是容器本身——它看到标签后，按标签指示去实例化、装配、管理生命周期。没有容器，注解就只是个标签，什么都不会发生。\n一句话总结： 容器 = 自动化“对象管家”，负责“造对象、管对象、销毁对象”，你只需要用注解或配置告诉它“管哪些、怎么管”。\n我的疑问：容器是如何装东西 Servlet 启动时，容器（Tomcat/Jetty 等）会按下面两步决定“把哪些对象装进容器”：\n读配置 容器先解析 web.xml 或扫描类路径下的注解（@WebServlet、@WebFilter 等）。 这些配置里明确写了“哪个类要被装进容器”，例如： Hello com.example.HelloServlet 或\n@WebServlet(\"/hello\") public class HelloServlet extends HttpServlet { ... } 只要出现这样的声明，容器就知道“这个类需要被实例化并放进自己的管理池”。\n被装进去的对象既可以是官方自带的（比如 HttpServlet、Filter 接口的实现），也可以是你自己写的类。\n官方提供基础能力（如 HttpServlet、Filter），但具体业务逻辑要你自己写。 你写好类后，只要在配置里声明，容器就会把它当成普通对象一样加载、实例化、初始化，然后放进容器里统一管理。 一句话：\n“装什么”完全由你在配置里写什么决定；官方只负责提供“能被装”的基础接口和工具，真正的业务对象都是你自定义的。\n代码片段演示具体过程 🔍 代码：@WebServlet(\"/hello\")\n@WebServlet(\"/hello\") public class HelloServlet extends HttpServlet { ... } 我们分三部分来看：\n✅ 第一部分：@WebServlet(\"/hello\") —— 贴标签的人 💬 大白话：\n这就像是在你家门上贴了一张“快递员专用贴纸”，写着：\n“快递员（Tomcat）：如果有人寄东西到 /hello 这个地址，请送到这家！”\n这个注解就是告诉 Servlet 容器：“我这个类是一个 Servlet，能处理 /hello 这个路径的请求。”\n🧠 原理：\n@WebServlet 是 Java EE 的标准注解（来自 javax.servlet.annotation.WebServlet）。 当 Tomcat 启动时，它会扫描整个项目的类路径（classpath），找所有带有 @WebServlet 注解的类。 一旦发现，就记录下来：“HelloServlet 类负责处理 /hello 请求”。 👉 所以说，不是所有类都会被装进容器，只有你打了标签的才会被发现和加载。\n✅ 第二部分：public class HelloServlet —— 你要造的房子 💬 大白话：\n这是你自己设计的一栋小房子（Java 类），你起名叫 HelloServlet。\n它本来只是图纸（.java 文件），没人知道它能干啥。\n但因为你贴了 @WebServlet 标签，快递公司（Tomcat）就知道：“哦，这栋房子是收快递的驿站，得把它建起来，安排人值班。”\n🧠 原理：\nTomcat 发现这个类后，会通过反射（Class.forName()）加载它； 然后调用 new HelloServlet() 创建一个实例； 把这个实例放进自己的“Servlet 池”里，准备后续复用。 👉 所以：类是你写的，对象是容器帮你 new 出来的。\n✅ 第三部分：extends HttpServlet —— 房子必须符合国家标准 💬 大白话：\n你想开个驿站，国家规定必须满足几个条件：\n有收件窗口 有发件流程 有安全制度 HttpServlet 就是“国家认证的驿站模板”。你继承它，就等于承诺：“我家符合标准，能合法接单。”\n🧠 原理：\nHttpServlet 是 JDK 提供的一个抽象类，实现了基本的 HTTP 协议处理逻辑； 它内部已经写好了： 如何区分 GET / POST 请求 如何调用 doGet() 或 doPost() 如何设置响应头等基础功能 你只需要重写 doGet() 或 doPost()，写自己的业务逻辑就行。 比如：\n@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) { resp.getWriter().println(\"你好，世界！\"); } 👉 相当于你在“收件窗口”贴了个告示：“来取件的人，每人送一瓶水。”\n🚀 完整流程：从启动到访问，容器是怎么操作的？ 阶段 容器做了什么 1. 启动 Tomcat 启动，开始扫描所有 .class 文件 2. 扫描 发现 HelloServlet.class 上有 @WebServlet(\"/hello\") 3. 注册 把这个类登记到“路由表”：/hello → HelloServlet.class 4. 实例化 调用 new HelloServlet() 创建一个实例 5. 初始化 调用它的 init() 方法（只一次） 6. 等待请求 开始监听 8080 端口 7. 收到请求 用户访问 /hello，容器查路由表，找到 HelloServlet 8. 分发处理 调用该实例的 service() → 自动转到 doGet() 9. 返回响应 你的代码生成 HTML，返回给浏览器 ✅ 这些对象是官方的还是自定义的？ 对象类型 来源 举例 框架提供的 官方（Java EE / Tomcat） HttpServlet, HttpServletRequest, Filter 接口 你自己写的 自定义 HelloServlet, LoginFilter, UserDao 容器管理的 只要是你打了标签的类，容器都会管 所有 @WebServlet, @WebFilter, @WebListener 👉 所以答案是：\n类是你自己写的，但容器根据你打的标签（如 @WebServlet）决定是否把它装进去，并负责它的生命周期。\n🎯 举个生活化的比喻 想象你在小区里想开一家“代收快递”的小店：\n你写了个店 → public class HelloServlet 你申请了资质 → @WebServlet(\"/hello\") 你用了标准柜台 → extends HttpServlet 物业（Tomcat）审核通过 → 扫描到注解，允许入驻 物业给你分配铺位 → 实例化并放入 Servlet 池 居民寄快递写地址 /hello → 浏览器访问 /hello 物业把快递转交给你 → 容器调用你的 doGet() 如果没有贴资质标签？—— 物业不知道你是个合法驿站，直接忽略你。\n✅ 总结一句话 @WebServlet 是你给类贴的“上岗证”，容器是“人事主管”，它只招聘持证上岗的 Servlet；你写的类是自定义的，但它必须继承 HttpServlet 这个“标准模板”，才能被容器识别、创建、管理和调用。\n对象是怎么在网络上传输的 一句话先给结论： TCP 连接建立后，浏览器（客户端）把“纯文本请求”发过去；服务器收到后，由 Servlet 容器先把这段文本解析成 HttpServletRequest 对象，再调用你的 Servlet；响应时，你的 Servlet 代码往 HttpServletResponse 对象里写数据，容器再把它转成纯文本发回浏览器。\n下面拆成三步，用大白话讲清楚：\n1. 浏览器怎么“发” 浏览器只懂 HTTP 协议，它把请求拼成一段符合 HTTP 格式的纯文本（请求行 + 头 + 空行 + 数据），然后通过 TCP 把这段文本发出去。\n→ 它不会“发对象”，发的是纯文本。\n2. 服务器怎么“收并转成对象” Tomcat 这类 Servlet 容器监听在 8080（或 80）端口，收到 TCP 流后：\n先读取整段文本； 按 HTTP 协议规范把文本拆成“请求行、头、正文”等部分； 用这些部分填充 HttpServletRequest 对象的各个字段（getMethod()、getHeader()、getParameter() 等）； 同时准备一个空的 HttpServletResponse 对象，交给你的 Servlet 代码往里写响应内容。 → “把文本变成对象”这一步，是容器在接收到请求后、调用你代码之前完成的。\n3. 响应怎么“从对象回到文本” 你的 Servlet 代码往 HttpServletResponse 对象里写内容（setHeader、getWriter.println 等）； 容器把对象里的状态和正文再拼成符合 HTTP 协议的纯文本，通过 TCP 发回浏览器； 浏览器收到后，按协议解析这段文本，渲染页面。 → “把对象变回文本”这一步，是容器在你的 Servlet 执行完之后、把响应写回网络之前完成的。\n一句话再总结： 浏览器只和“文本”打交道；容器负责“文本 ↔ 对象”的双向翻译；你写的 Servlet 只需要操作对象，不用管底层 TCP 和 HTTP 文本格式。\n响应对象怎么把它写回文本的，然后发回客户端的 简单一句话： Servlet 容器把 HttpServletResponse 对象里的“状态、头、正文”按 HTTP 协议拼成一段纯文本，再通过 TCP 发回浏览器。\n具体过程分三步：\n你往对象里写内容 在 doGet/doPost 里，你调用\nresp.setStatus(200) resp.setHeader(\"Content-Type\", \"text/html\") resp.getWriter().println(\"OK\") 这些数据都先存在 HttpServletResponse 对象里，还没发出去。 容器把对象“翻译”成 HTTP 响应文本 容器在你的方法执行完后，会把对象里的内容按顺序拼成一段符合 HTTP 协议的纯文本：\nHTTP/1.1 200 OK Content-Type: text/html Content-Length: 14 OK 这一步就是“把对象写回文本”。\n通过 TCP 把文本发回浏览器 容器拿到这段文本后，调用底层 Socket 的输出流，把字节写进 TCP 缓冲区，操作系统再通过网络把字节流送回浏览器。\n浏览器收到后，再按 HTTP 协议把这段文本拆开，渲染页面。\nrequestInitialized(ServletRequestEvent e) ，描述下里面的逻辑 requestInitialized(ServletRequestEvent e) 的执行逻辑可以概括为一条链式流程：\n容器感知请求到达 当 HTTP 请求进入 Tomcat 时，容器立即为该请求分配一个线程，并决定调用哪些监听器。 创建事件对象 容器用当前 ServletRequest 实例和 ServletContext 构造出一个新的 ServletRequestEvent 对象，把请求与上下文绑定到该事件。 触发监听器 容器遍历所有已注册的 ServletRequestListener，依次调用它们的 requestInitialized 方法，并把刚创建的 ServletRequestEvent 对象作为实参传入。 执行监听逻辑 监听器方法体内的代码开始执行： 通过 e.getServletRequest() 拿到原始请求对象； 可以读取请求的 IP、URL、参数等信息； 可以记录日志、统计访问量、设置请求属性等。 继续请求处理 监听器执行完毕后，容器继续把请求交给 Filter 链或目标 Servlet，整个请求流程正常进行。 一句话总结： 容器把“刚到达的请求”包装成一个事件对象，然后挨个通知所有监听器“请求开始了”，监听器拿到事件后即可对请求进行预处理或记录，之后请求继续向下流转。\n","wordCount":"1128","inLanguage":"en","datePublished":"2025-11-17T23:58:00+08:00","dateModified":"2025-11-17T23:58:00+08:00","author":{"@type":"Person","name":"您的姓名"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://ljj1992.fun/posts/servlet%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},"publisher":{"@type":"Organization","name":"star徐的博客","logo":{"@type":"ImageObject","url":"http://ljj1992.fun/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://ljj1992.fun/ accesskey=h title="star徐的博客 (Alt + H)">star徐的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://ljj1992.fun/ title=首页><span>首页</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://ljj1992.fun/>Home</a>&nbsp;»&nbsp;<a href=http://ljj1992.fun/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">servlet基础知识</h1><div class=post-meta><span title='2025-11-17 23:58:00 +0800 +0800'>November 17, 2025</span>&nbsp;·&nbsp;<span>您的姓名</span></div></header><div class=post-content><h1 id=servlet基础知识>servlet基础知识<a hidden class=anchor aria-hidden=true href=#servlet基础知识>#</a></h1><p>作为安全爱好者的基础性研究</p><p>Servlet：名字的由来</p><p>Servlet = “Server” + “Applet”
早期 Java 里，Applet 是跑在浏览器里的小程序；Servlet 则是跑在 <strong>服务器端</strong> 的小程序，所以叫 “Server Applet”，简称 Servlet。</p><hr><p><strong>它在解决什么问题？</strong></p><ol><li><strong>动态内容</strong>：HTML 只能写静态页面，而网页需要“千人千面”——登录状态、购物车、论坛帖子等都得实时变化。</li><li><strong>性能瓶颈</strong>：传统 CGI 为每个请求开一个进程，开销大、响应慢。</li><li><strong>跨平台</strong>：CGI 脚本依赖操作系统，移植困难。</li></ol><p>ervlet 把“生成动态页面”这件事搬到 Java 世界：一次编写，到处运行；用线程代替进程，性能大幅提升。</p><hr><p><strong>作用一句话</strong></p><p>接收浏览器发来的请求 → 在服务器端用 Java 代码处理 → 动态生成 HTML/JSON 等响应内容 → 再送回浏览器。</p><p><strong>底层逻辑与框架</strong></p><table><thead><tr><th>阶段</th><th>动作</th><th>关键角色</th></tr></thead><tbody><tr><td>1. 请求到达</td><td>浏览器发 HTTP 请求到 Web 服务器（如 Tomcat）</td><td>Web 服务器</td></tr><tr><td>2. 路由到 Servlet</td><td>服务器根据 URL 把请求交给对应的 Servlet 类</td><td>Servlet 容器</td></tr><tr><td>3. 生命周期</td><td>容器负责：加载类 → 创建实例 → 调用 <code>init()</code> → 多次 <code>service()</code> → 最终 <code>destroy()</code></td><td>Servlet 本身</td></tr><tr><td>4. 处理请求</td><td><code>service()</code> 方法根据 HTTP 方法（GET/POST）调用 <code>doGet()</code>/<code>doPost()</code>，开发者只写业务逻辑</td><td>HttpServlet</td></tr><tr><td>5. 生成响应</td><td>通过 <code>HttpServletResponse</code> 写回 HTML、JSON 或文件</td><td>Servlet</td></tr><tr><td>6. 线程复用</td><td>同一个 Servlet 实例被多个线程共享，避免频繁创建/销毁</td><td>JVM 线程池</td></tr></tbody></table><p><strong>核心优势</strong></p><ul><li><strong>高性能</strong>：线程级并发，不是进程级。</li><li><strong>可移植</strong>：任何支持 Java 的服务器都能跑。</li><li><strong>功能全</strong>：Session、Cookie、过滤器、监听器一应俱全。</li><li><strong>可扩展</strong>：配合 JSP、Filter、Listener 构成完整的 Java Web 体系。</li></ul><h2 id=servlet-的完整生命周期和工作流程>Servlet 的完整生命周期和工作流程<a hidden class=anchor aria-hidden=true href=#servlet-的完整生命周期和工作流程>#</a></h2><p>用大白话 + 原理 + 代码演示，<strong>把每一个阶段掰开揉碎</strong>，分析每个阶段它到底做了点什么：</p><blockquote><p><strong>从浏览器点下回车开始，到服务器返回网页结束，中间到底发生了什么？</strong></p></blockquote><p>🧭 <strong>全局流程图（先看个全景）</strong></p><pre tabindex=0><code>用户请求 → Tomcat 接收 → 找到对应 Servlet → 创建/复用实例 → 调用 doGet/doPost → 生成响应 → 返回网页
                      ↑         ↑              ↑
                  路由匹配   生命周期     业务逻辑执行
</code></pre><h3 id=我们分-5-个阶段-来讲>我们分 <strong>5 个阶段</strong> 来讲：<a hidden class=anchor aria-hidden=true href=#我们分-5-个阶段-来讲>#</a></h3><ol><li>✅ <strong>阶段一：路由到 Servlet（URL 找类）</strong></li><li>✅ <strong>阶段二：Servlet 生命周期（创建、初始化、销毁）</strong></li><li>✅ <strong>阶段三：处理请求（doGet/doPost）</strong></li><li>✅ <strong>阶段四：生成响应（写回 HTML/JSON）</strong></li><li>✅ <strong>阶段五：线程并发（多个用户同时访问）</strong></li></ol><p>每个阶段都配 <strong>代码 + 逐行解释 + 大白话 + 原理说明</strong>。</p><hr><h3 id=-阶段一路由到-servleturl-找类>📌 <strong>阶段一：路由到 Servlet（URL 找类）</strong><a hidden class=anchor aria-hidden=true href=#-阶段一路由到-servleturl-找类>#</a></h3><p>💬 大白话：</p><p>你访问 <code>http://localhost:8080/hello</code>，Tomcat 怎么知道该让哪个 Java 类来处理？
靠的是 <strong>映射规则</strong>，就像“门牌号”一样，告诉服务器：“/hello 这个地址归 HelloServlet 管”。</p><p>🔧 <strong>两种方式设置路由</strong>：</p><p><strong>方式一：用注解（推荐）</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@WebServlet</span>(<span style=color:#e6db74>&#34;/hello&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloServlet</span> <span style=color:#66d9ef>extends</span> HttpServlet { ... }
</span></span></code></pre></div><p><strong>方式二：写 web.xml</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;servlet&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet-name&gt;</span>Hello<span style=color:#f92672>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet-class&gt;</span>com.example.HelloServlet<span style=color:#f92672>&lt;/servlet-class&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/servlet&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;servlet-mapping&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet-name&gt;</span>Hello<span style=color:#f92672>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;url-pattern&gt;</span>/hello<span style=color:#f92672>&lt;/url-pattern&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/servlet-mapping&gt;</span>
</span></span></code></pre></div><p>👉 无论哪种方式，最终结果都是：<strong>URL → Servlet 类 的映射表</strong></p><hr><h3 id=-阶段二servlet-生命周期创建--初始化--使用--销毁>📌 阶段二：Servlet 生命周期（创建 → 初始化 → 使用 → 销毁）<a hidden class=anchor aria-hidden=true href=#-阶段二servlet-生命周期创建--初始化--使用--销毁>#</a></h3><p>Servlet 不是“用一次就扔”，而是“一次创建，长期服役”。</p><p>🔄 生命周期三阶段：</p><table><thead><tr><th>阶段</th><th>方法</th><th>何时触发</th><th>调用几次</th></tr></thead><tbody><tr><td>初始化</td><td><code>init()</code></td><td>第一次请求到达时</td><td>1次</td></tr><tr><td>服务</td><td><code>service()</code> → <code>doGet()</code>/<code>doPost()</code></td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td><code>destroy()</code></td><td>服务器关闭或卸载应用</td><td>1次</td></tr></tbody></table><blockquote><p>💡 注意：<strong>一个 Servlet 类只创建一个实例</strong>，但会被多个线程同时调用！</p></blockquote><hr><h4 id=-代码演示带生命周期日志的-helloservlet>📄 代码演示：带生命周期日志的 HelloServlet<a hidden class=anchor aria-hidden=true href=#-代码演示带生命周期日志的-helloservlet>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> com.example;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.servlet.ServletException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.servlet.annotation.WebServlet;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.servlet.http.HttpServlet;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.servlet.http.HttpServletRequest;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> javax.servlet.http.HttpServletResponse;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.IOException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.PrintWriter;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 1. 告诉 Tomcat：这个类处理 /hello 路径的请求</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@WebServlet</span>(<span style=color:#e6db74>&#34;/hello&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloServlet</span> <span style=color:#66d9ef>extends</span> HttpServlet {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> requestCount <span style=color:#f92672>=</span> 0; <span style=color:#75715e>// 记录被访问了多少次</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 初始化阶段：Tomcat 创建这个类的实例后，自动调用 init()</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>() <span style=color:#66d9ef>throws</span> ServletException {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;🔧 HelloServlet 正在初始化！这是第一次启动！&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 服务阶段：每次有请求来，都会调用 service()，它会自动分发到 doGet 或 doPost</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>service</span>(HttpServletRequest req, HttpServletResponse resp)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throws</span> ServletException, IOException {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;⚡ 请求进来了！准备处理...&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>service</span>(req, resp); <span style=color:#75715e>// 调用父类逻辑，根据请求方法决定走 doGet 还是 doPost</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 处理 GET 请求</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doGet</span>(HttpServletRequest req, HttpServletResponse resp)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throws</span> ServletException, IOException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 每处理一次，计数器 +1</span>
</span></span><span style=display:flex><span>        requestCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;🟢 正在处理第 %d 次 GET 请求，来自: %s%n&#34;</span>,
</span></span><span style=display:flex><span>                requestCount, req.<span style=color:#a6e22e>getRemoteAddr</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 设置响应内容类型为 HTML</span>
</span></span><span style=display:flex><span>        resp.<span style=color:#a6e22e>setContentType</span>(<span style=color:#e6db74>&#34;text/html;charset=UTF-8&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取输出流，用来写回网页内容</span>
</span></span><span style=display:flex><span>        PrintWriter out <span style=color:#f92672>=</span> resp.<span style=color:#a6e22e>getWriter</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 写出 HTML 页面</span>
</span></span><span style=display:flex><span>        out.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;&lt;h1&gt;你好，世界！&lt;/h1&gt;&#34;</span>);
</span></span><span style=display:flex><span>        out.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;&lt;p&gt;你是第 &lt;strong&gt;&#34;</span> <span style=color:#f92672>+</span> requestCount <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&lt;/strong&gt; 个访问者&lt;/p&gt;&#34;</span>);
</span></span><span style=display:flex><span>        out.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;&lt;p&gt;你的 IP 是：&#34;</span> <span style=color:#f92672>+</span> req.<span style=color:#a6e22e>getRemoteAddr</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&lt;/p&gt;&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 当服务器关闭时，自动调用 destroy()</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>destroy</span>() {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;🛑 HelloServlet 正在销毁！再见！&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>destroy</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>🔍 逐行解释（重点！）</strong></p><table><thead><tr><th style=text-align:center>行</th><th style=text-align:center>代码</th></tr></thead><tbody><tr><td style=text-align:center><code>@WebServlet("/hello")</code></td><td style=text-align:center>给这个类贴个“门牌号”：谁访问 <code>/hello</code>，就找它</td></tr><tr><td style=text-align:center><code>extends HttpServlet</code></td><td style=text-align:center>继承父类，获得处理 HTTP 请求的能力（比如自动区分 GET/POST）</td></tr><tr><td style=text-align:center><code>init()</code></td><td style=text-align:center>第一次请求来之前，Tomcat 会调用一次，适合做“准备工作”（比如连接数据库）</td></tr><tr><td style=text-align:center><code>service()</code></td><td style=text-align:center>每次请求都先进这里，然后它自动判断是 GET 还是 POST，再转发给 <code>doGet</code> 或 <code>doPost</code></td></tr><tr><td style=text-align:center><code>super.service(...)</code></td><td style=text-align:center>调用父类的标准流程，不要删！</td></tr><tr><td style=text-align:center><code>doGet()</code></td><td style=text-align:center>专门处理 GET 请求（比如浏览器地址栏访问）</td></tr><tr><td style=text-align:center><code>requestCount++</code></td><td style=text-align:center>记录总共被访问了多少次（注意：这是成员变量！多个线程共享）</td></tr><tr><td style=text-align:center><code>resp.setContentType(...)</code></td><td style=text-align:center>告诉浏览器：“我要返回的是 HTML，用 UTF-8 编码”</td></tr><tr><td style=text-align:center><code>PrintWriter out = resp.getWriter()</code></td><td style=text-align:center>拿到“笔”，可以往响应里写内容</td></tr><tr><td style=text-align:center><code>out.println(...)</code></td><td style=text-align:center>把 HTML 内容一行行写回去</td></tr><tr><td style=text-align:center><code>destroy()</code></td><td style=text-align:center>服务器关闭前调用，适合做“收尾工作”（比如关闭数据库连接）</td></tr></tbody></table><h3 id=-阶段三处理请求dogetdopost>📌 阶段三：处理请求（doGet/doPost）<a hidden class=anchor aria-hidden=true href=#-阶段三处理请求dogetdopost>#</a></h3><p><strong>💬 大白话：</strong></p><p>你可以把 <code>doGet</code> 想象成一个“服务员”，他每天上班（服务期），只要客人点单（发请求），他就按菜单（代码）上菜（返回网页）。</p><p>🔧 <strong>HttpServletRequest 是什么？</strong></p><p>它是“请求包裹”，里面装着：</p><ul><li>用户的 IP（<code>getRemoteAddr()</code>）</li><li>请求参数（<code>getParameter("name")</code>）</li><li>请求头（User-Agent、Cookie 等）</li><li>Session 信息</li></ul><p><strong>🔧 HttpServletResponse 是什么？</strong></p><p>它是“响应包裹”，你要把生成的内容（HTML、JSON）塞进去，然后“打包发回去”。</p><hr><h3 id=-阶段四生成响应写回-html>📌 阶段四：生成响应（写回 HTML）<a hidden class=anchor aria-hidden=true href=#-阶段四生成响应写回-html>#</a></h3><p><strong>💬 大白话：</strong></p><p>你不是在写网页，而是在“拼字符串”。
Java 代码像厨师一样，把 HTML 片段一个个拼起来，最后做成一道“动态菜”。</p><p><strong>🔧 关键点：</strong></p><ul><li><code>resp.getWriter()</code>：拿到输出流；</li><li><code>out.println()</code>：把内容写出去；</li><li>内容可以是 HTML、JSON、XML、文件下载等。</li></ul><hr><h3 id=-阶段五线程并发多个用户同时访问>📌 阶段五：线程并发（多个用户同时访问）<a hidden class=anchor aria-hidden=true href=#-阶段五线程并发多个用户同时访问>#</a></h3><p><strong>💬 大白话：</strong></p><p>想象你开了家面馆，只有一个厨师（HelloServlet 实例），但来了 10 个客人（10 个请求）。
怎么办？
你让 10 个服务员（线程）轮流找厨师下单，厨师做好一碗就递给对应服务员。</p><p>👉 <strong>一个 Servlet 实例，被多个线程并发调用。</strong></p><p><strong>⚠️ 危险点：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> requestCount <span style=color:#f92672>=</span> 0; <span style=color:#75715e>// 共享变量！</span>
</span></span></code></pre></div><p>如果多个线程同时修改它，可能出现“计数不准”（线程安全问题）。
但在本例中，我们只是演示，不深究锁机制。</p><hr><h3 id=-实验亲自验证生命周期>🧪 实验：亲自验证生命周期<a hidden class=anchor aria-hidden=true href=#-实验亲自验证生命周期>#</a></h3><p><strong>步骤 1：启动应用</strong></p><p>运行 Spring Boot 或传统 Web 项目，启动 Tomcat。</p><p><strong>步骤 2：第一次访问</strong></p><p>浏览器打开：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span>http:<span style=color:#75715e>//localhost:8080/hello</span>
</span></span></code></pre></div><p>控制台输出：</p><pre tabindex=0><code>🔧 HelloServlet 正在初始化！这是第一次启动！
⚡ 请求进来了！准备处理...
🟢 正在处理第 1 次 GET 请求，来自: 127.0.0.1
</code></pre><p>👉 <code>init()</code> 只执行了一次！</p><p><strong>步骤 3：刷新几次</strong></p><p>再刷新 2 次页面。</p><p>控制台输出：</p><pre tabindex=0><code>⚡ 请求进来了！准备处理...
🟢 正在处理第 2 次 GET 请求，来自: 127.0.0.1

⚡ 请求进来了！准备处理...
🟢 正在处理第 3 次 GET 请求，来自: 127.0.0.1
</code></pre><p><strong>步骤 4：关闭服务器</strong></p><pre tabindex=0><code>🛑 HelloServlet 正在销毁！再见！
</code></pre><p>👉 <code>destroy()</code> 在最后执行！</p><hr><h3 id=-总结servlet-工作全流程>🎯 总结：Servlet 工作全流程<a hidden class=anchor aria-hidden=true href=#-总结servlet-工作全流程>#</a></h3><table><thead><tr><th>阶段</th><th>发生了什么</th><th>类比</th></tr></thead><tbody><tr><td>1. 路由</td><td>URL → Servlet 类</td><td>门牌号找房东</td></tr><tr><td>2. 初始化</td><td><code>new HelloServlet()</code> → <code>init()</code></td><td>房东搬进来，打扫房子</td></tr><tr><td>3. 服务</td><td>每次请求 → <code>service()</code> → <code>doGet</code></td><td>房东接待租客</td></tr><tr><td>4. 响应</td><td><code>resp.getWriter().println(...)</code></td><td>给租客递钥匙</td></tr><tr><td>5. 并发</td><td>多个线程共享一个实例</td><td>一个房东服务多个租客</td></tr><tr><td>6. 销毁</td><td>服务器关闭 → <code>destroy()</code></td><td>房东搬走，打扫卫生</td></tr></tbody></table><hr><h4 id=-一句话总结>✅ 一句话总结<a hidden class=anchor aria-hidden=true href=#-一句话总结>#</a></h4><blockquote><p><strong>Servlet 就是一个长期住在服务器里的“Java 小程序”，它有一个固定的“上岗-工作-下班”流程，能接收请求、动态生成网页、并发服务多人，是 Java Web 的基石。</strong></p></blockquote><hr><h3 id=-下一步建议>🚀 下一步建议<a hidden class=anchor aria-hidden=true href=#-下一步建议>#</a></h3><p>你现在可以：</p><ol><li>把上面的 <code>HelloServlet</code> 跑起来，亲眼看看日志；</li><li>改成 <code>doPost</code>，用 Postman 发 POST 请求；</li><li>加一个参数：<code>?name=小明</code>，让网页显示“你好，小明！”；</li><li>研究 <code>Filter</code>（过滤器）——在 Servlet 前后加“安检门”。</li></ol><h2 id=容器这个东东>容器这个东东？<a hidden class=anchor aria-hidden=true href=#容器这个东东>#</a></h2><p><strong>大白话通俗解释：</strong>
容器就是“装对象的大盒子”，它在程序启动时就把所有需要的对象一次性“造好”，然后一直管着它们——什么时候用、用多少、用完怎么销毁，都由盒子说了算。你写的类只是“图纸”，容器负责按图纸造东西、把东西放进盒子，并在盒子的生命周期里随时给你调用。</p><p><strong>原理层面：</strong></p><ol><li>启动阶段：容器读配置（XML、注解或 Java 代码），把每个要管理的类变成对象（实例化），并把它们之间的依赖关系也一次性配好。</li><li>运行阶段：程序里用到的对象都直接从盒子里拿，容器保证每次拿到的都是“已经装好、随时能用”的完整对象。</li><li>销毁阶段：程序关闭，容器把盒子里所有对象一次性清理掉，避免内存泄漏。</li></ol><p><strong>和注解的关系：</strong>
注解只是“贴标签”，告诉容器“这个类要放进盒子”“这两个对象之间有依赖”。真正干活的还是容器本身——它看到标签后，按标签指示去实例化、装配、管理生命周期。没有容器，注解就只是个标签，什么都不会发生。</p><p><strong>一句话总结：</strong>
容器 = 自动化“对象管家”，负责“造对象、管对象、销毁对象”，你只需要用注解或配置告诉它“管哪些、怎么管”。</p><h3 id=我的疑问容器是如何装东西>我的疑问：容器是如何装东西<a hidden class=anchor aria-hidden=true href=#我的疑问容器是如何装东西>#</a></h3><p>Servlet 启动时，容器（Tomcat/Jetty 等）会按下面两步决定“把哪些对象装进容器”：</p><ol><li>读配置
容器先解析 web.xml 或扫描类路径下的注解（@WebServlet、@WebFilter 等）。</li><li>这些配置里明确写了“哪个类要被装进容器”，例如：</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;servlet&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet-name&gt;</span>Hello<span style=color:#f92672>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;servlet-class&gt;</span>com.example.HelloServlet<span style=color:#f92672>&lt;/servlet-class&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/servlet&gt;</span>
</span></span></code></pre></div><p>或</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@WebServlet</span>(<span style=color:#e6db74>&#34;/hello&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloServlet</span> <span style=color:#66d9ef>extends</span> HttpServlet { ... }
</span></span></code></pre></div><p>只要出现这样的声明，容器就知道“这个类需要被实例化并放进自己的管理池”。</p><p>被装进去的对象既可以是官方自带的（比如 HttpServlet、Filter 接口的实现），也可以是你自己写的类。</p><ul><li>官方提供基础能力（如 HttpServlet、Filter），但具体业务逻辑要你自己写。</li><li>你写好类后，只要在配置里声明，容器就会把它当成普通对象一样加载、实例化、初始化，然后放进容器里统一管理。</li></ul><p>一句话：</p><p>“装什么”完全由你在配置里写什么决定；官方只负责提供“能被装”的基础接口和工具，真正的业务对象都是你自定义的。</p><h3 id=代码片段演示具体过程>代码片段演示具体过程<a hidden class=anchor aria-hidden=true href=#代码片段演示具体过程>#</a></h3><p><strong>🔍 代码：<code>@WebServlet("/hello")</code></strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@WebServlet</span>(<span style=color:#e6db74>&#34;/hello&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HelloServlet</span> <span style=color:#66d9ef>extends</span> HttpServlet { ... }
</span></span></code></pre></div><p>我们分三部分来看：</p><hr><h4 id=-第一部分webservlethello--贴标签的人>✅ 第一部分：<code>@WebServlet("/hello")</code> —— 贴标签的人<a hidden class=anchor aria-hidden=true href=#-第一部分webservlethello--贴标签的人>#</a></h4><p><strong>💬 大白话：</strong></p><p>这就像是在你家门上贴了一张“快递员专用贴纸”，写着：</p><blockquote><p>“快递员（Tomcat）：如果有人寄东西到 <code>/hello</code> 这个地址，请送到这家！”</p></blockquote><p>这个注解就是告诉 <strong>Servlet 容器</strong>：“我这个类是一个 Servlet，能处理 <code>/hello</code> 这个路径的请求。”</p><p><strong>🧠 原理：</strong></p><ul><li><code>@WebServlet</code> 是 Java EE 的标准注解（来自 <code>javax.servlet.annotation.WebServlet</code>）。</li><li>当 Tomcat 启动时，它会<strong>扫描整个项目的类路径</strong>（classpath），找所有带有 <code>@WebServlet</code> 注解的类。</li><li>一旦发现，就记录下来：“<code>HelloServlet</code> 类负责处理 <code>/hello</code> 请求”。</li></ul><p>👉 所以说，<strong>不是所有类都会被装进容器，只有你打了标签的才会被发现和加载。</strong></p><hr><h4 id=-第二部分public-class-helloservlet--你要造的房子>✅ 第二部分：<code>public class HelloServlet</code> —— 你要造的房子<a hidden class=anchor aria-hidden=true href=#-第二部分public-class-helloservlet--你要造的房子>#</a></h4><p><strong>💬 大白话：</strong></p><p>这是你自己设计的一栋小房子（Java 类），你起名叫 <code>HelloServlet</code>。</p><p>它本来只是图纸（<code>.java</code> 文件），没人知道它能干啥。</p><p>但因为你贴了 <code>@WebServlet</code> 标签，快递公司（Tomcat）就知道：“哦，这栋房子是收快递的驿站，得把它建起来，安排人值班。”</p><p><strong>🧠 原理：</strong></p><ul><li>Tomcat 发现这个类后，会通过反射（<code>Class.forName()</code>）加载它；</li><li>然后调用 <code>new HelloServlet()</code> 创建一个实例；</li><li>把这个实例放进自己的“Servlet 池”里，准备后续复用。</li></ul><p>👉 所以：<strong>类是你写的，对象是容器帮你 new 出来的。</strong></p><hr><h4 id=-第三部分extends-httpservlet--房子必须符合国家标准>✅ 第三部分：<code>extends HttpServlet</code> —— 房子必须符合国家标准<a hidden class=anchor aria-hidden=true href=#-第三部分extends-httpservlet--房子必须符合国家标准>#</a></h4><p><strong>💬 大白话：</strong></p><p>你想开个驿站，国家规定必须满足几个条件：</p><ul><li>有收件窗口</li><li>有发件流程</li><li>有安全制度</li></ul><p><code>HttpServlet</code> 就是“国家认证的驿站模板”。你继承它，就等于承诺：“我家符合标准，能合法接单。”</p><p><strong>🧠 原理：</strong></p><ul><li><code>HttpServlet</code> 是 JDK 提供的一个抽象类，实现了基本的 HTTP 协议处理逻辑；</li><li>它内部已经写好了：<ul><li>如何区分 GET / POST 请求</li><li>如何调用 <code>doGet()</code> 或 <code>doPost()</code></li><li>如何设置响应头等基础功能</li></ul></li><li>你只需要重写 <code>doGet()</code> 或 <code>doPost()</code>，写自己的业务逻辑就行。</li></ul><p>比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doGet</span>(HttpServletRequest req, HttpServletResponse resp) {
</span></span><span style=display:flex><span>    resp.<span style=color:#a6e22e>getWriter</span>().<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;你好，世界！&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>👉 相当于你在“收件窗口”贴了个告示：“来取件的人，每人送一瓶水。”</p><hr><h3 id=-完整流程从启动到访问容器是怎么操作的>🚀 完整流程：从启动到访问，容器是怎么操作的？<a hidden class=anchor aria-hidden=true href=#-完整流程从启动到访问容器是怎么操作的>#</a></h3><table><thead><tr><th>阶段</th><th>容器做了什么</th></tr></thead><tbody><tr><td>1. 启动</td><td>Tomcat 启动，开始扫描所有 <code>.class</code> 文件</td></tr><tr><td>2. 扫描</td><td>发现 <code>HelloServlet.class</code> 上有 <code>@WebServlet("/hello")</code></td></tr><tr><td>3. 注册</td><td>把这个类登记到“路由表”：<code>/hello → HelloServlet.class</code></td></tr><tr><td>4. 实例化</td><td>调用 <code>new HelloServlet()</code> 创建一个实例</td></tr><tr><td>5. 初始化</td><td>调用它的 <code>init()</code> 方法（只一次）</td></tr><tr><td>6. 等待请求</td><td>开始监听 8080 端口</td></tr><tr><td>7. 收到请求</td><td>用户访问 <code>/hello</code>，容器查路由表，找到 <code>HelloServlet</code></td></tr><tr><td>8. 分发处理</td><td>调用该实例的 <code>service()</code> → 自动转到 <code>doGet()</code></td></tr><tr><td>9. 返回响应</td><td>你的代码生成 HTML，返回给浏览器</td></tr></tbody></table><h3 id=-这些对象是官方的还是自定义的>✅ 这些对象是官方的还是自定义的？<a hidden class=anchor aria-hidden=true href=#-这些对象是官方的还是自定义的>#</a></h3><table><thead><tr><th>对象类型</th><th>来源</th><th>举例</th></tr></thead><tbody><tr><td><strong>框架提供的</strong></td><td>官方（Java EE / Tomcat）</td><td><code>HttpServlet</code>, <code>HttpServletRequest</code>, <code>Filter</code> 接口</td></tr><tr><td><strong>你自己写的</strong></td><td>自定义</td><td><code>HelloServlet</code>, <code>LoginFilter</code>, <code>UserDao</code></td></tr><tr><td><strong>容器管理的</strong></td><td>只要是你打了标签的类，容器都会管</td><td>所有 <code>@WebServlet</code>, <code>@WebFilter</code>, <code>@WebListener</code></td></tr></tbody></table><p>👉 所以答案是：</p><blockquote><p><strong>类是你自己写的，但容器根据你打的标签（如 @WebServlet）决定是否把它装进去，并负责它的生命周期。</strong></p></blockquote><hr><h3 id=-举个生活化的比喻>🎯 举个生活化的比喻<a hidden class=anchor aria-hidden=true href=#-举个生活化的比喻>#</a></h3><p>想象你在小区里想开一家“代收快递”的小店：</p><ol><li><strong>你写了个店</strong> → <code>public class HelloServlet</code></li><li><strong>你申请了资质</strong> → <code>@WebServlet("/hello")</code></li><li><strong>你用了标准柜台</strong> → <code>extends HttpServlet</code></li><li><strong>物业（Tomcat）审核通过</strong> → 扫描到注解，允许入驻</li><li><strong>物业给你分配铺位</strong> → 实例化并放入 Servlet 池</li><li><strong>居民寄快递写地址 <code>/hello</code></strong> → 浏览器访问 <code>/hello</code></li><li><strong>物业把快递转交给你</strong> → 容器调用你的 <code>doGet()</code></li></ol><p>如果没有贴资质标签？—— 物业不知道你是个合法驿站，直接忽略你。</p><hr><h3 id=-总结一句话>✅ 总结一句话<a hidden class=anchor aria-hidden=true href=#-总结一句话>#</a></h3><blockquote><p><code>@WebServlet</code> 是你给类贴的“上岗证”，容器是“人事主管”，它只招聘持证上岗的 Servlet；你写的类是自定义的，但它必须继承 <code>HttpServlet</code> 这个“标准模板”，才能被容器识别、创建、管理和调用。</p></blockquote><hr><h2 id=对象是怎么在网络上传输的>对象是怎么在网络上传输的<a hidden class=anchor aria-hidden=true href=#对象是怎么在网络上传输的>#</a></h2><p>一句话先给结论：
<strong>TCP 连接建立后，浏览器（客户端）把“纯文本请求”发过去；服务器收到后，由 Servlet 容器先把这段文本解析成 <code>HttpServletRequest</code> 对象，再调用你的 Servlet；响应时，你的 Servlet 代码往 <code>HttpServletResponse</code> 对象里写数据，容器再把它转成纯文本发回浏览器。</strong></p><p>下面拆成三步，用大白话讲清楚：</p><hr><h3 id=1-浏览器怎么发>1. 浏览器怎么“发”<a hidden class=anchor aria-hidden=true href=#1-浏览器怎么发>#</a></h3><p>浏览器只懂 HTTP 协议，它把请求拼成一段符合 HTTP 格式的纯文本（请求行 + 头 + 空行 + 数据），然后通过 TCP 把这段文本发出去。</p><p>→ 它不会“发对象”，发的是<strong>纯文本</strong>。</p><hr><h3 id=2-服务器怎么收并转成对象>2. 服务器怎么“收并转成对象”<a hidden class=anchor aria-hidden=true href=#2-服务器怎么收并转成对象>#</a></h3><p>Tomcat 这类 Servlet 容器监听在 8080（或 80）端口，收到 TCP 流后：</p><ul><li>先读取整段文本；</li><li>按 HTTP 协议规范把文本拆成“请求行、头、正文”等部分；</li><li>用这些部分填充 <code>HttpServletRequest</code> 对象的各个字段（getMethod()、getHeader()、getParameter() 等）；</li><li>同时准备一个空的 <code>HttpServletResponse</code> 对象，交给你的 Servlet 代码往里写响应内容。</li></ul><p>→ <strong>“把文本变成对象”这一步，是容器在接收到请求后、调用你代码之前完成的。</strong></p><hr><h3 id=3-响应怎么从对象回到文本>3. 响应怎么“从对象回到文本”<a hidden class=anchor aria-hidden=true href=#3-响应怎么从对象回到文本>#</a></h3><ol><li>你的 Servlet 代码往 <code>HttpServletResponse</code> 对象里写内容（setHeader、getWriter.println 等）；</li><li>容器把对象里的状态和正文再拼成符合 HTTP 协议的纯文本，通过 TCP 发回浏览器；</li><li>浏览器收到后，按协议解析这段文本，渲染页面。</li></ol><p>→ <strong>“把对象变回文本”这一步，是容器在你的 Servlet 执行完之后、把响应写回网络之前完成的。</strong></p><hr><p>一句话再总结：
<strong>浏览器只和“文本”打交道；容器负责“文本 ↔ 对象”的双向翻译；你写的 Servlet 只需要操作对象，不用管底层 TCP 和 HTTP 文本格式。</strong></p><h3 id=响应对象怎么把它写回文本的然后发回客户端的>响应对象怎么把它写回文本的，然后发回客户端的<a hidden class=anchor aria-hidden=true href=#响应对象怎么把它写回文本的然后发回客户端的>#</a></h3><p>简单一句话：
Servlet 容器把 <code>HttpServletResponse</code> 对象里的“状态、头、正文”按 HTTP 协议拼成一段纯文本，再通过 TCP 发回浏览器。</p><p>具体过程分三步：</p><ol><li><p>你往对象里写内容
在 <code>doGet</code>/<code>doPost</code> 里，你调用</p><ul><li><code>resp.setStatus(200)</code></li><li><code>resp.setHeader("Content-Type", "text/html")</code></li><li><code>resp.getWriter().println("&lt;h1>OK&lt;/h1>")</code>
这些数据都先存在 <code>HttpServletResponse</code> 对象里，还没发出去。</li></ul></li><li><p>容器把对象“翻译”成 HTTP 响应文本
容器在你的方法执行完后，会把对象里的内容按顺序拼成一段符合 HTTP 协议的纯文本：</p><pre tabindex=0><code>HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 14

&lt;h1&gt;OK&lt;/h1&gt;
</code></pre></li><li><p>这一步就是“把对象写回文本”。</p></li><li><p>通过 TCP 把文本发回浏览器
容器拿到这段文本后，调用底层 <code>Socket</code> 的输出流，把字节写进 TCP 缓冲区，操作系统再通过网络把字节流送回浏览器。</p></li></ol><p>浏览器收到后，再按 HTTP 协议把这段文本拆开，渲染页面。</p><h3 id=requestinitializedservletrequestevent-e-描述下里面的逻辑>requestInitialized(ServletRequestEvent e) ，描述下里面的逻辑<a hidden class=anchor aria-hidden=true href=#requestinitializedservletrequestevent-e-描述下里面的逻辑>#</a></h3><p><code>requestInitialized(ServletRequestEvent e)</code> 的执行逻辑可以概括为一条链式流程：</p><ol><li><strong>容器感知请求到达</strong>
当 HTTP 请求进入 Tomcat 时，容器立即为该请求分配一个线程，并决定调用哪些监听器。</li><li><strong>创建事件对象</strong>
容器用当前 <code>ServletRequest</code> 实例和 <code>ServletContext</code> 构造出一个新的 <code>ServletRequestEvent</code> 对象，把请求与上下文绑定到该事件。</li><li><strong>触发监听器</strong>
容器遍历所有已注册的 <code>ServletRequestListener</code>，依次调用它们的 <code>requestInitialized</code> 方法，并把刚创建的 <code>ServletRequestEvent</code> 对象作为实参传入。</li><li><strong>执行监听逻辑</strong>
监听器方法体内的代码开始执行：<ul><li>通过 <code>e.getServletRequest()</code> 拿到原始请求对象；</li><li>可以读取请求的 IP、URL、参数等信息；</li><li>可以记录日志、统计访问量、设置请求属性等。</li></ul></li><li><strong>继续请求处理</strong>
监听器执行完毕后，容器继续把请求交给 Filter 链或目标 Servlet，整个请求流程正常进行。</li></ol><p>一句话总结：
容器把“刚到达的请求”包装成一个事件对象，然后挨个通知所有监听器“请求开始了”，监听器拿到事件后即可对请求进行预处理或记录，之后请求继续向下流转。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://ljj1992.fun/tags/java/>Java</a></li><li><a href=http://ljj1992.fun/tags/servlet/>Servlet</a></li><li><a href=http://ljj1992.fun/tags/web%E5%BC%80%E5%8F%91/>Web开发</a></li><li><a href=http://ljj1992.fun/tags/%E7%BC%96%E7%A8%8B/>编程</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://ljj1992.fun/>star徐的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>